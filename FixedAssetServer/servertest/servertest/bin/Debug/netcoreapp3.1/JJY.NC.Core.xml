<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JJY.NC.Core</name>
    </assembly>
    <members>
        <member name="T:JJY.NC.Core.Controllers.Args.IArgsBase1">
            <summary>
            用于拦截器匹配参数校验
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.Args.ArgsBaseHelper1">
            <summary>
            参数校验扩展方法
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Controllers.Args.ArgsBaseHelper1.Volit(JJY.NC.Core.Controllers.Args.IArgsBase,System.String,System.Collections.Generic.IList{Microsoft.AspNetCore.Mvc.Abstractions.ParameterDescriptor})">
            <summary>
            参数校验
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.Args.IArgsBase">
            <summary>
            用于拦截器匹配参数校验
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.Args.ArgsBaseHelper">
            <summary>
            参数校验扩展方法
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Controllers.Args.ArgsBaseHelper.Volit(JJY.NC.Core.Controllers.Args.IArgsBase)">
            <summary>
            参数校验
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:JJY.NC.Core.Controllers.Args.ArgsFilterAttribute">
            <summary>
            定义此参数是否参与校验，默认校验不为null
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.Args.CheckPower">
            <summary>
            权限检查,方法级别
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JJY.NC.Core.Controllers.Args.CheckPowerAttribute" -->
        <member name="P:JJY.NC.Core.Controllers.Args.CheckPowerAttribute.Power">
            <summary>
            是否执行权限检查
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.Args.Result`1">
            <summary>
            统一返回类型
            0 成功
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JJY.NC.Core.Controllers.Args.Result`1.code">
            <summary>
            请求状态
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Controllers.Args.Result`1.time">
            <summary>
            请求返回10位时间戳
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Controllers.Args.Result`1.key">
            <summary>
            请求自带key
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Controllers.Args.Result`1.msg">
            <summary>
            请求返回消息
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Controllers.Args.Result`1.description">
            <summary>
            请求返回消息描述
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Controllers.Args.Result`1.output">
            <summary>
            请求返回数据体
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.BaseController">
            <summary>
            自定义Controller 基类，可不实现 [ApiController] 及[Route("[controller]")] 
            注释前加【xxx】或者[xxx]即可参与swagger排序 
            
            默认支持RPC，约束为 具有无参构造、只支持post方法、post方法为单级不可变路由
            
            支持 swagger 时，需生成xml注释。默认在非 config.json 即线上无模式启动时支持 swagger。
            屏蔽接口及Controller 使用  [ApiExplorerSettings(IgnoreApi = true)]
            使用 swagger 时 Controller 中过程方法不允许为 public。
            使用 swagger 时 Controller 中过程方法不允许为 public。
            使用 swagger 时 Controller 中过程方法不允许为 public。
            
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Controllers.BaseController.IsRpc">
            <summary>
            是否是RPC请求,当前为消息处理体有效
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Controllers.BaseController.Logger">
            <summary>
            日志默认实现器 log4net
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Controllers.BaseController.GetBodyStr">
            <summary>
            获取 Content-Type:text/html;charset=UTF-8 时的Body字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Controllers.HelloWord">
            <summary>
            【97】 默认服务存活页面
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Controllers.HelloWord.Test">
            <summary>
            页面Test
            </summary>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Controllers.JWTController">
            <summary>
            [0] JWT使用RS256,验证地址 https://www.box3.cn/tools/jwt.html
            JS中RS256签名,长度1024 类型 OPENSSL_PKCS1_OAEP_PADDING PKCS#1 验证地址 https://www.bejson.com/enc/rsa/
            JWT与JS使用相同公钥
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Controllers.JWTController.RSACreatKeys">
            <summary>
            RSA JS_OAEP CreatKey
            </summary>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Controllers.JWTController.JSEncode(System.String)">
            <summary>
            JS_OAEP Encode
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Controllers.JWTController.JSDecode(System.String)">
            <summary>
            JS_OAEP Decode
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Controllers.JWTController.Encode(JJYRest.Request{System.String,JJY.NC.Core.Controllers.Args.CheckPower})">
            <summary>
            编码JWT消息
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Controllers.JWTController.Check(JJYRest.Request{System.String})">
            <summary>
            检查JWT是否可用
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Controllers.JWTController.Decode(JJYRest.Request{System.String})">
            <summary>
            解码JWT消息
            </summary>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Controllers.LogController">
            <summary>
            【66】 日志控制页面
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.QRCode">
            <summary>
            【50】 根据传入的字符串生成二维码
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Controllers.SendMessageController">
            <summary>
            [66] 消息推送控制器
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JJY.NC.Core.Controllers.SendMessageController.SendTo(System.String,System.String)" -->
        <member name="P:JJY.NC.Core.Cores.Jog.SaveLevel">
            <summary>
            日志等级，dev调试模式下为All，线上默认Error
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Cores.Jog.NB(NewLife.Log.LogLevel)">
            <summary>
            根据key指定输出日志
            </summary>
            <param name="key">输出文件名称</param>
        </member>
        <member name="M:JJY.NC.Core.Cores.Jog.Debug(System.String,System.Object[])">
            <summary>
            Debug 会输出到控制台
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:JJY.NC.Core.Helpers.DbSafeHelper">
            <summary>
            数据库安全助手类
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.SERVER_KEY">
            <summary>
            服务器Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.PORT_KEY">
            <summary>
            端口Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.USER_KEY">
            <summary>
            用户Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.PWD_KEY">
            <summary>
            密码Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.HIS_SERVER_KEY">
            <summary>
            HIS服务器Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.HIS_PORT_KEY">
            <summary>
            HIS端口Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.HIS_USER_KEY">
            <summary>
            HIS用户Key
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DbSafeHelper.HIS_PWD_KEY">
            <summary>
            HIS密码Key
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.DbSafeHelper.GetYBDbConnectionString(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            获取医保数据库连接字符串
            </summary>
            <param name="dbConnectionStringTpl"></param>
            <param name="server"></param>
            <param name="port"></param>
            <param name="user"></param>
            <param name="pwd"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Helpers.DbSafeHelper.GetHisDbConnectionString(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            获取医保数据库连接字符串
            </summary>
            <param name="dbConnectionStringTpl"></param>
            <param name="server"></param>
            <param name="port"></param>
            <param name="user"></param>
            <param name="pwd"></param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Helpers.DownLoadFileHelper">
            <summary>
            文件助手类
            </summary>
        </member>
        <member name="F:JJY.NC.Core.Helpers.DownLoadFileHelper.DownloadFileDirectory">
            <summary>
            下载文件目录
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.DownLoadFileHelper.SaveToFile(System.Byte[],System.String,System.String)">
            <summary>
            保存至文件
            </summary>
            <param name="content"></param>
            <param name="saveFilePath"></param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Helpers.EncryptHelper">
            <summary>
            加解密助手类
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.AESEncrypt(System.String,System.String)">
            <summary> 
            AES加密 
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.AESDecrypt(System.String,System.String)">
            <summary> 
            AES解密 
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.DESEncrypt(System.String,System.String)">
            <summary> 
            DES加密 
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.DESDecrypt(System.String,System.String)">
            <summary> 
            DES解密 
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.Base64Encode(System.String)">
            <summary>
            base64编码
            </summary>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.Base64Decode(System.String)">
            <summary>
            base64解码
            </summary>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Helpers.EncryptHelper.GetAesKey(System.String)">
            <summary>
            获取Aes加解密合法长度的Key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Helpers.ExceptionMessageHelper.GetMessage(System.Exception,System.Int32)">
            <summary>
            通过递归获取异常信息的所有Message Exception.Message
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Helpers.ExceptionMessageHelper.GetDetailInfo(System.Exception,System.Int32)">
            <summary>
            获取异常详细信息
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Helpers.MappingHelper.MappingTo``1(System.Object,System.Boolean)">
            <summary>
            反射进行数据转换
            </summary>
            <typeparam name="TOut"></typeparam>
            <param name="tIn"></param>
            <param name="hldxx"> 忽略大小写 </param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Helpers.SqlBaseDataMapTo`2">
            <summary>
            只能从参数向数据库转换
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="T:JJY.NC.Core.Helpers.SortComparers.StringAscSpecialComparer">
            <summary>
            使用 字符串char按位排序，即Asc排序
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Helpers.SortComparers.NaturalCompare">
            <summary>
            自然排序
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Models.FastXCode.TestDAL.ExportYBModels">
            <summary>
            导出数据库模型
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Models.FastXCode.TestDAL.Export1">
            <summary>
            导出数据库模型
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Models.AutoMappingBase`2.GetSTDIngoreD(`1)">
            <summary>
            正向忽略 转换数据 列表
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Models.AutoMappingBase`2.GetSTDActionD(`1)">
            <summary>
            不同映射转换
            </summary>
            <param name="destination"></param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Ji.MQ.DistributedLock">
            <summary>
            基于Redis的分布式锁
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.DistributedLock.#ctor(System.String)">
            <summary>
            分布式锁 - Redis
            "server=103.151.229.60:36379;password=1qazxcvbnm;db=11"
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.DistributedLock.Init(System.String,System.Action,System.Int32,System.Int32,System.Boolean)">
            <summary>
            开启挂载分布式锁
            </summary>
            <param name="key"></param>
            <param name="act"> 如果异步,则会立即放弃锁 </param>
            <param name="expire"> act执行超时毫秒</param>        
            <param name="lockwaitspan"> 锁定执行超时毫秒</param>
            <param name="autorelease"> 是否执行完成自动释放</param>
        </member>
        <member name="T:JJY.NC.Core.Ji.MQ.MessageQueue">
            <summary>
            不会被同时重复消费的消息队列
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.MessageQueue.#ctor(System.String)">
            <summary>
            使用场景为重复广播风暴下的消息处理
            不会被同时重复消费的消息队列 使用 InitReciver初始化
            "server=103.151.229.60:36379;password=1qazxcvbnm;db=11"
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.MessageQueue.InitReciver(System.String,System.String,System.Action{JJY.NC.Core.Ji.MQ.TopicMessage},System.Int32,System.Boolean)">
            <summary>
            初始化为接收器
            相同 groupname 和 topic 单例消费
            </summary>
            <param name="groupname"></param>
            <param name="topic"></param>
            <param name="act"></param>
            <param name="actexpire"> 消息超时可重复广播时间,默认10s</param>
            <param name="issender"> 是否为发送器,发送器时不订阅消息</param>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.MessageQueue.InitSender(System.String)">
            <summary>
            初始化为发送器
            </summary>
            <param name="groupname"></param>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.MessageQueue.Send(System.String,System.String,System.String)">
            <summary>
            发送消息,非处理中的消息才会被发送
            $"{this.GroupName}_{this.Topic}_{key}" 作为判断依据
            </summary>
            <param name="msg">发送消息内容</param>
        </member>
        <member name="T:JJY.NC.Core.Ji.MQ.MQBus">
            <summary>
            消息队列总线
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Ji.MQ.Redis.LockQueue">
            <summary>
            基于Redis的消息锁队列 未完成,或者说待确认无法实现,后续研究
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.WorkWechat.GetQYAccessToken(System.String,System.String)">
            <summary>
            获取企业微信的accessToken
            </summary>
            <param name="corpid">企业微信ID</param>
            <param name="corpsecret">管理组密钥</param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.WorkWechat.PostWebRequest(System.String,System.String,System.Text.Encoding)">
            <summary>
            Post数据接口
            </summary>
            <param name="postUrl">接口地址</param>
            <param name="paramData">提交json数据</param>
            <param name="dataEncode">编码方式</param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Ji.MQ.WorkWechat.SendText(System.String,System.String)">
            <summary>
            推送信息
            </summary>
            <param name="corpid">企业微信ID</param>
            <param name="corpsecret">管理组密钥</param>
            <param name="paramData">提交的数据json</param>
            <param name="dataEncode">编码方式</param>
            <returns></returns>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendText.text">
            <summary>
            要发送的文本，必须小写，企业微信API不识别大写。
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.Text.content">
            <summary>
            要发送的文本内容字段，必须小写，企业微信API不识别大写。
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase">
            <summary>
            企业微信发送消息的基础消息内容
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase.touser">
            <summary>
            UserID列表（消息接收者，多个接收者用‘|’分隔）。特殊情况：指定为@all，则向关注该企业应用的全部成员发送
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase.toparty">
            <summary>
            PartyID列表，多个接受者用‘|’分隔。当touser为@all时忽略本参数
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase.totag">
            <summary>
            TagID列表，多个接受者用‘|’分隔。当touser为@all时忽略本参数
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase.msgtype">
            <summary>
            消息类型
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase.agentid">
            <summary>
            企业应用的id，整型。可在应用的设置页面查看
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Ji.MQ.WorkWechat.CorpSendBase.safe">
            <summary>
            表示是否是保密消息，0表示否，1表示是，默认0
            </summary>
        </member>
        <member name="T:JJY.NC.Core.MiddleWares.ActionFilter">
            <summary>
            前置拦截器，用于判断传递参数约束
            </summary>
        </member>
        <member name="M:JJY.NC.Core.MiddleWares.AllowOriginFilter.OnActionExecuting(Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext)">
            <summary>
            默认允许跨域
            </summary>
            <param name="filterContext"></param>
        </member>
        <member name="T:JJY.NC.Core.MiddleWares.AuthorizationFilter">
            <summary>
            SSO 适配器
            </summary>
        </member>
        <member name="T:JJY.NC.Core.MiddleWares.CheckArgsFilter">
            <summary>
            前置拦截器 增强型判断参数，使用方式为 
            检查 缺少参数、参数值不被允许、sql注入
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JJY.NC.Core.MiddleWares.ExceptionFilter" -->
        <member name="M:JJY.NC.Core.MiddleWares.StateCodeFilterHelper.UseStateCodeFilter(Microsoft.AspNetCore.Builder.IApplicationBuilder)">
            <summary>
            自定义 http 状态码返回
            </summary>
            <param name="builder"></param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Nets.JJYRest.IResponse">
            <summary>
             请求示例
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Nets.JJYRest.ResponseHelper.To``1(RestEase.Response{``0},System.String,System.String)">
            <summary>
            Test Code
            </summary>
            <typeparam name="R"></typeparam>
            <param name="response"></param>
            <param name="successcode"></param>
            <returns></returns>
        </member>
        <member name="T:JJY.NC.Core.Nets.JJYRest.IRestService">
            <summary>
              var client = PTClient.Creat(UrlPath);
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Nets.JJYRest.IRestService.UrlPath">
            <summary>
            服务后缀
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Nets.JJYRest.IRestService.PostAsync(System.Object)">
            <summary>
            返回体为string的调用
            </summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JJY.NC.Core.Nets.JJYRest.IRestService.PostModelAsync``1(System.Object)" -->
        <member name="T:JJY.NC.Core.Nets.JJYRest.RestBaseAction`2">
            <summary>
            Restful 接口快速操作适配基类
            </summary>
            <typeparam name="inputArgs"></typeparam>
            <typeparam name="outputArgs"></typeparam>
        </member>
        <member name="P:JJY.NC.Core.Nets.JJYRest.RestBaseClient`1.TimeOut">
            <summary>
            服务默认超时时间
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Nets.Jroxies.Jroxy">
            <summary>
             Jroxy.StartProxyLocal("tcp://127.0.0.1:9904", "tcp://127.0.0.1:1433");
             Jroxy.StartProxyClient("tcp://win.jiujiayi.ltd:9903", "tcp://127.0.0.1:1433", 9904);
             Jroxy.StartProxyServer(9903);
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.Jroxy.CreatRemoteClient(System.String)">
            <summary>
            创建新的客户端连接
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.Jroxy.StartProxyLocal(System.String,System.String)">
            <summary>
            开启本地转发
            </summary>
            <param name="from"></param>
            <param name="to"></param>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.Jroxy.StartProxyClient(System.String,System.String,System.String,System.Int32)">
            <summary>
            开启服务端转发客户端
            </summary>
            <param name="appname"></param>
            <param name="serveruri"></param>
            <param name="localuri"></param>
            <param name="localtoserverport"></param>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.Jroxy.StartProxyServer(System.Int32)">
            <summary>
            开启服务端转发服务
            </summary>
            <param name="port"></param>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.JroxyClient.Start">
            <summary>
            开始转发本地端口至服务端端口
            </summary>
            <param name="serverport"></param>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.JroxyLocal.Start(System.String,System.String)">
            <summary>
            开启本地端口转发
            </summary>
            <param name="from"></param>
            <param name="to"></param>
        </member>
        <member name="T:JJY.NC.Core.Nets.Jroxies.JroxyType">
            <summary>
            发送命令，精简在1024字节内
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Nets.Jroxies.JroxyType.InitClient">
            <summary>
            初始化客户端
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.JroxyType.SendMsg(NewLife.Net.ISocketClient,System.String)">
            <summary>
            发送自定义消息
            </summary>
            <param name="client"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Nets.Jroxies.JroxyType.SendMsg(NewLife.Net.INetSession,System.String)">
            <summary>
            发送自定义消息
            </summary>
            <param name="client"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Nets.PingHelper.PingIpOrDomainName(System.String)">
            <summary>
            用于检查IP地址或域名是否可以使用TCP/IP协议访问(使用Ping命令),true表示Ping成功,false表示Ping失败
            </summary>
            <param name="strIpOrDName">输入参数,表示IP地址或域名</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:JJY.NC.Core.Nets.RestSharpTest">
            <summary>
            client.Proxy = new WebProxy("http://127.0.0.1:8888/", true);
            </summary>
        </member>
        <member name="P:JJY.NC.Core.SettingTest.Name">
            <summary>系统名称</summary>
        </member>
        <member name="M:JJY.NC.Core.Utils.ConfigHelper.GetSection(System.String[])">
            <summary>
            检查是否存在某级节点,非null时存在
            使用 ConfigHelper.Section["xxx"]["xxx"] as NotifyDynamic  !=null 判断;
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Utils.ConfigHelper.GetConfig(System.String,System.String@)">
            <summary>
            从 Configuration 中获取配置信息 
            </summary>
            <param name="key"> Key </param>
            <param name="value"> [out] 传递查询到的信息 </param>
            <returns> 成功返回 null，失败返回失败信息 </returns>
        </member>
        <member name="F:JJY.NC.Core.Utils.DateTimeHelper.TimeFormats">
            <summary>
            R => GMT 格式
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Utils.DateTimeHelper.ToTimeCanNull(System.String)">
            <summary>
            时间转换，支持 CTS => GMT
            </summary>
            <param name="dtr"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.NC.Core.Starts.StartMgr.Init">
            <summary>
            分布式初始化器
            </summary>
        </member>
        <member name="E:JJY.NC.Core.Starts.StartService.BeforeRun">
            <summary>
              服务启动前执行
            不能在此方法中执行导入，暂未发现为啥导入不了
            </summary>
        </member>
        <member name="E:JJY.NC.Core.Starts.StartService.BehindConfig">
            <summary>
            配置文件加载后
            </summary>
        </member>
        <member name="E:JJY.NC.Core.Starts.StartService.BehindRun">
            <summary>
            服务启动后执行
            不能在此方法中执行导入，暂未发现为啥导入不了
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Starts.StartService.ServiceSetup">
            <summary>
            全局静态启动服务
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Starts.StartService.SingleCache">
            <summary>
            单例静态数据缓存,此为单服务所有,Sqlite
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Starts.StartService.DistributedCache">
            <summary>
            使用 Get Set
            分布式缓存,默认使用 数据库缓存 使用Redis时则直接用Redis
            </summary>
        </member>
        <member name="T:JJY.NC.Core.Starts.ServiceSetup">
            <summary>
            使用oledb连接数据库需要导入下面连接工厂
            DbProviderFactories.RegisterFactory("MySql.Data.MySqlClient", MySqlClientFactory.Instance);
            DbProviderFactories.RegisterFactory("System.Data.SqlClient", SqlClientFactory.Instance);
            DbProviderFactories.RegisterFactory("System.Data.OracleClient", OracleClientFactory.Instance);
            </summary>
        </member>
        <member name="P:JJY.NC.Core.Starts.ServiceSetup.RPCTypes">
            <summary>
            RPC 支持接口缓存
            </summary>
        </member>
        <member name="M:JJY.NC.Core.Starts.ServiceSetup.MatchFilters(Microsoft.AspNetCore.Mvc.Filters.FilterCollection)">
            <summary>
            处理全局过滤器
            </summary>
            <param name="fc"></param>
        </member>
        <member name="M:JJY.NC.Core.Starts.ServiceSetup.Configure(Microsoft.AspNetCore.Builder.IApplicationBuilder,Microsoft.AspNetCore.Hosting.IWebHostEnvironment)">
            <summary>
            IOC挂载完成,启动前
            </summary>
            <param name="app"></param>
            <param name="env"></param>
        </member>
        <member name="M:JJY.Core.Tools.NotifyObject.NotificationObject.RaisePropertyChanged(System.String)">
            <summary>
            触发事件
            </summary>
            <param name="propertyName">更改的属性名</param>
        </member>
        <member name="M:JJY.Core.Tools.NotifyObject.NotificationObject.RaisePropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>
            触发事件
            </summary>
            <param name="args">事件对象</param>
        </member>
        <member name="M:JJY.Core.Tools.NotifyObject.NotificationObject.RaiseRegisterCallback(System.String)">
            <summary>
            触发注册的更改回调
            </summary>
            <param name="e">属性参数</param>
        </member>
        <member name="M:JJY.Core.Tools.NotifyObject.NotificationObject.RegisterChangedCallback``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Action{System.Object})">
            <summary>
            注册属性更改通知回调
            </summary>
            <typeparam name="T"></typeparam>
            <param name="changedCallback"></param>
        </member>
        <member name="M:JJY.Core.Tools.NotifyObject.NotificationObject.RegisterChangedCallback(System.String,System.Action{System.Object})">
            <summary>
            注册属性更改通知回调
            </summary>
            <param name="propertyName"></param>
            <param name="changedCallback"></param>
        </member>
        <member name="M:JJY.Core.Tools.NotifyObject.NotificationObject.ExtractPropertyName``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            通过属性的lambda表达式获取属性的名称，注:如果是A.B.C的形式，则最终返回C
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propertyExpression"></param>
            <returns></returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            查找成员的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="memberInfo">目标成员</param>
            <returns>特性</returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttributes``1(System.Reflection.MemberInfo)">
            <summary>
            查找成员的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="memberInfo">目标成员</param>
            <returns>特性集合</returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttribute``1(System.Reflection.Assembly)">
            <summary>
            查找程序集的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="assembly">目标程序集</param>
            <returns>特性</returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttributes``1(System.Reflection.Assembly)">
            <summary>
            查找程序集的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="assembly">目标程序集</param>
            <returns>特性集合</returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttribute``1(System.String)">
            <summary>
            查找程序集的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="assemblyFile">目标程序集</param>
            <returns>特性</returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttributes``1(System.String)">
            <summary>
            查找程序集的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="assemblyFile">目标程序集</param>
            <returns>特性集合</returns>
        </member>
        <member name="M:JJY.Core.Tools.Helper.AttributeHelper.GetAttribute``1(System.Enum)">
            <summary>
            查找枚举值的特性
            </summary>
            <typeparam name="T">特性类型</typeparam>
            <param name="memberInfo">枚举值</param>
            <returns>特性</returns>
        </member>
        <member name="T:JJY.Core.Services.RestSharpExtension.ServiceRequest">
            <summary>
            Container for data used to make requests.
            </summary>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.ServiceRequest.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:JJY.Core.Services.RestSharpExtension.ServiceRequest"/> class.
            </summary>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.ServiceRequest.#ctor(RestSharp.Method)">
            <summary>
            Sets Method property to value of method
            
            </summary>
            <param name="method">Method to use for this request</param>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.ServiceRequest.#ctor(System.String)">
            <summary>
            Sets Resource property
            
            </summary>
            <param name="resource">Resource to use for this request</param>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.ServiceRequest.#ctor(System.String,RestSharp.Method,System.String)">
            <summary>
            Sets Resource and Method properties
            
            </summary>
            <param name="resource">Resource to use for this request</param><param name="method">Method to use for this request</param>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.ServiceRequest.#ctor(System.Uri)">
            <summary>
            Sets Resource property
            
            </summary>
            <param name="resource">Resource to use for this request</param>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.ServiceRequest.#ctor(System.Uri,RestSharp.Method)">
            <summary>
            Sets Resource and Method properties
            
            </summary>
            <param name="resource">Resource to use for this request</param><param name="method">Method to use for this request</param>
        </member>
        <member name="T:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer">
            <summary>
            Default JSON serializer for request bodies
            Doesn't currently use the SerializeAs attribute, defers to Newtonsoft's attributes
            </summary>
        </member>
        <member name="P:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.Default">
            <summary>
            Gets the default NewtonsoftJsonSerializer instance.
            </summary>
            <value>
            The default.
            </value>
        </member>
        <member name="F:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer._default">
            <summary>
            The default instance holder.
            </summary>
        </member>
        <member name="P:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.DateFormat">
            <summary>
            Unused for JSON Serialization
            </summary>
        </member>
        <member name="P:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.RootElement">
            <summary>
            Unused for JSON Serialization
            </summary>
        </member>
        <member name="P:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.Namespace">
            <summary>
            Unused for JSON Serialization
            </summary>
        </member>
        <member name="P:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.ContentType">
            <summary>
            Content type for serialized content
            </summary>
        </member>
        <member name="F:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer._serializer">
            <summary>
            The serializer implementation.
            </summary>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer"/> class.
            </summary>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.#ctor(Newtonsoft.Json.JsonSerializer)">
            <summary>
            Initializes a new instance of the <see cref="T:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer"/> class.
            </summary>
            <param name="serializer">The serializer.</param>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.Serialize(System.Object)">
            <summary>
            Serialize the object as JSON
            </summary>
            <param name="obj">Object to serialize</param>
            <returns>JSON as String</returns>
        </member>
        <member name="M:JJY.Core.Services.RestSharpExtension.NewtonsoftJsonSerializer.Deserialize``1(RestSharp.IRestResponse)">
            <summary>
            Deserializes the specified response.
            </summary>
            <typeparam name="T">The response type.</typeparam>
            <param name="response">The response.</param>
            <returns>The strongly-typed deserialized response.</returns>
        </member>
        <member name="M:System.ArgsHelper.NewResult``1(``0,System.String)">
            <summary>
            返回具有null的全属性json，默认推荐 NewResultJsonStr
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="recivekey"></param>
            <returns></returns>
        </member>
        <member name="M:System.ArgsHelper.NewResultError``1(``0,System.String,System.String,System.String)">
            <summary>
            新返回结果-失败
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="recivekey"></param>
            <param name="msg">提示信息</param>
            <param name="description">请求返回的信息描述</param>
            <returns></returns>
        </member>
        <member name="M:System.ArgsHelper.GetResultData``1(System.Object)">
            <summary>
            获取NewResult的data强类型值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:System.ArgsHelper.NewMessageResult``1(``0,System.Int32)">
            <summary>
            返回 放在msg里面，默认-1执行失败
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:System.ArgsHelper.NewResultJsonStr``1(``0,System.String)">
            <summary>
            直接返回 json 字符串,且忽略null字段
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="recivekey"></param>
            <returns></returns>
        </member>
        <member name="M:System.ArgsHelper.NewResultJson``1(``0,System.String)">
            <summary>
            返回经过 gzip 压缩的字符串
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="recivekey"></param>
            <returns></returns>
        </member>
        <member name="M:System.ArgsHelper.ExceptionResult(System.String,System.Exception,System.String)">
            <summary>
            服务异常时返回
            </summary>
            <param name="data"></param>
            <param name="ex"></param>
            <param name="recivekey"></param>
            <returns></returns>
        </member>
        <member name="T:System.CheckAttribute">
            <summary>
            参数检查特性
            </summary>
        </member>
        <member name="P:System.CheckAttribute.NotAllowValue">
            <summary>
            不允许的值，string时不为null和空白
            </summary>
        </member>
        <member name="P:System.CheckAttribute.SqlInjection">
            <summary>
            检查Sql注入
            </summary>
        </member>
        <member name="P:System.CheckAttribute.Error">
            <summary>
            错误提示字符
            </summary>
        </member>
        <member name="P:System.CheckAttribute.JudgeNames">
            <summary>
            判断属性
            </summary>
        </member>
        <member name="M:System.CheckAttribute.#ctor(System.String[])">
            <summary>
            三个一组
            1 属性名称  2 属性不允许的值  3 错误提示
            </summary>
            <param name="JudgeNames"></param>
        </member>
        <member name="T:System.LogX">
            <summary> 迹。新日志及统计系统 </summary>
        </member>
        <member name="M:System.LogX.Crash(System.Exception)">
            <summary>
            记录 崩溃
            崩溃数据会被上传
            </summary>
        </member>
        <member name="M:System.LogX.Error(System.Exception,System.String)">
            <summary>
            记录异常消息
            </summary>
            <param name="ex"></param>
            <param name="msg"></param>
        </member>
        <member name="M:System.LogX.Warn(System.String)">
            <summary>
            记录 警告
            </summary>
        </member>
        <member name="M:System.LogX.Debug(System.String)">
            <summary>
            记录 调试信息
            </summary>
        </member>
        <member name="M:System.LogX.Info(System.String)">
            <summary>
            记录 输出信息
            </summary>
        </member>
        <member name="M:System.LogX.NB(System.String)">
            <summary>
            根据key指定输出日志
            </summary>
            <param name="key">输出文件名称</param>
        </member>
        <member name="M:System.LogX.Tip(System.String,System.TipType)">
            <summary>
            只进行提示
            </summary>
        </member>
        <member name="M:System.LogX.Finalize">
            <summary> 析构函数 </summary>
        </member>
        <member name="M:System.LogX.Dispose(System.Boolean)">
            <summary> Dispose 重载 </summary>
            <param name="disposing"> true 时释放所有资源，false 释放非托管资源 </param>
        </member>
        <member name="M:System.LogX.Dispose">
            <summary> 手动释放资源 </summary>
        </member>
        <member name="M:System.LogX.ReleaseTrust">
            <summary> 释放托管数据 </summary>
        </member>
        <member name="M:System.LogX.ReleaseUnTrust">
            <summary> 释放非托管数据 </summary>
        </member>
        <member name="T:System.DefaultLogSave">
            <summary>
            系统自带默认日志输出器，默认使用 NewLife.Log   //NewLife.Log.XTrace.Log.Fatal();
            </summary>
        </member>
        <member name="M:System.ILogReport.Init">
            <summary>
            初始化日志上报
            </summary>
        </member>
        <member name="T:System.AES_Java">
            <summary>
            用来匹配Java的AES操作
            </summary>
        </member>
        <member name="M:System.AES_Java.Encrypt_HMACSHA256_Java(System.String,System.String,System.Text.Encoding)">
            <summary>
            匹配Java的 HMACSHA256 加密
            </summary>
            <param name="secret"></param>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:System.AES_Java.Decrypt_HMACSHA256_Java(System.String,System.String,System.Text.Encoding)">
            <summary>
            匹配 Java 的 HMACSHA256 解密
            </summary>
            <param name="aeskey"></param>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:System.ICacheHelper.GetNB``1(NewLife.Caching.ICache,System.String)">
            <summary>
            db 获取内部缓存
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cache"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ICacheHelper.SetNB``1(NewLife.Caching.ICache,System.String,``0,System.Int32)">
            <summary>
            db 设置内部缓存
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cache"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.JsonHelper.JsonToXML(System.String,System.String)">
            <summary>
            将Json转化为XML
            </summary>
        </member>
        <member name="M:System.JsonHelper.ToJson(System.Object)">
            <summary>
            生成所有字符串,包含null
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.JsonHelper.ToJsonStr(System.Object)">
            <summary>
            生成字符串,时间和dataset特殊处理
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.JsonHelper.JsonCopy``1(System.Object)">
            <summary>
            JsonConvert的扩展方法，通过序列化与反序列化，实现对象的转化
            </summary>
            <typeparam name="T">目标类型</typeparam>
            <param name="obj">操作对象</param>
            <returns>返回复制后的对象</returns>
        </member>
        <member name="M:System.JsonHelper.AllTokens(Newtonsoft.Json.Linq.JObject)">
            <summary>
            获取json所有JToken
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.JsonHelper.GetJsonPropValue(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.String)">
            <summary>
            获取json节点的值
            </summary>
            <param name="tokens"></param>
            <param name="propName"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimeHelper.ToWeek(System.DayOfWeek,System.String)">
            <summary>
            获取星期几中文
            </summary>
            <param name="week"></param>
            <param name="front"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimeHelper.ConvertToInt(System.DateTime)">
            <summary>
            日期转换成Int
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="F:System.TimeHelper.TimeFormats">
            <summary>
            R => GMT 格式
            </summary>
        </member>
        <member name="M:System.TimeHelper.ToTimeCanNull(System.String)">
            <summary>
            时间转换，支持 CTS => GMT
            </summary>
            <param name="dtr"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimeHelper.GetTimeStamp(System.DateTime,System.Int32)">
            <summary>
            获取时间戳
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.TimeHelper.ConvertDateTimeToInt(System.DateTime)">
            <summary>  
            将c# DateTime时间格式转换为Unix时间戳格式  
            </summary>  
            <param name="time">时间</param>  
            <returns>long</returns>  
        </member>
        <!-- Badly formed XML comment ignored for member "M:System.TimeHelper.ConvertStringToDateTime(System.String)" -->
        <member name="M:System.TimeHelper.GetDateTimeFrom1970Ticks(System.Int64)">
            <summary>
            时间戳转为C#格式时间10位
            </summary>
            <param name="timeStamp">Unix时间戳格式</param>
            <returns>C#格式时间</returns>
        </member>
        <member name="M:System.TimeHelper.IsTime(System.Int64,System.Double)">
            <summary>
            验证时间戳
            </summary>
            <param name="time"></param>
            <param name="interval">差值（分钟）</param>
            <returns></returns>
        </member>
        <member name="M:System.TimeHelper.IsTime(System.String)">
            <summary>
            判断时间戳是否正确（验证前8位）
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:System.AppInfo">
            <summary>  </summary>
        </member>
        <member name="P:System.AppInfo.IsInDev">
            <summary>
            是否运行在dev模式
            </summary>
        </member>
        <member name="P:System.JDBSHelper.DefaultDb">
            <summary>
            默认数据源
            </summary>
        </member>
        <member name="M:System.JDBSHelper.DoSql_DS(System.String)">
            <summary>
            默认执行sql返回ds
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:System.JDBSHelper.DoSql_DT(System.String)">
            <summary>
            默认执行sql返回dt
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:System.JDBSHelper.DoSql_DC(System.String)">
            <summary>
            执行sql语句并返回map集合。
            在多源数据库时不推荐，未动态解析语句因此不保证跨数据库一定正确。
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:System.JDBSHelper.DoSql_Type``1(System.String)">
            <summary>
            执行sql返回实体集合
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:System.JDBSHelper.QueryPageDataBySql(System.String,System.String,NewLife.Data.PageParameter,System.String)">
            <summary>
            返回DbTable，总数独立计算
            </summary>
            <param name="sql">需要查询的sql语句</param>
            <param name="keyFieldName">用于分页的字段</param>
            <param name="pager">分页</param>
            <param name="connName">数据库连接</param>
        </member>
        <member name="M:System.Jeb`1.J_Find(System.String,System.Object)">
            <summary>
            根据指定单列查找
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.Jeb`1.J_DoSql(System.String)">
            <summary>
            执行sql 语句
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:System.Jeb`1.J_DoWhere(System.String,System.Int32)">
            <summary>
            执行 Where 查询，其中必须以 where 开头，禁止为空查全部
            </summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:System.Jebp.J_Inserts``1(System.Collections.Generic.IList{``0})">
            <summary>
            批量插入
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="data"></param>
        </member>
        <member name="T:System.INotifyPropertyChangedHelper">
            <summary></summary>
        </member>
        <member name="M:System.NotifyDynamicHelper.Get(System.NotifyDynamic,System.String)">
            <summary>
            获取单个值的 ToString
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.NotifyDynamicHelper.Get(System.NotifyDynamic)">
            <summary>
            获取所有值的 ToString
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.NotifyDynamicHelper.GetValue(System.NotifyDynamic)">
            <summary>
            获取所有值
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:System.NotifyDynamic.DefaultValue">
            <summary>
            找不到属性时的默认值，默认 string.Empty
            </summary>
        </member>
        <member name="P:System.NotifyDynamic.Item(System.String)">
            <summary>
            实现key索引
            </summary>
            <param name="pn"></param>
            <returns></returns>
        </member>
        <member name="P:System.NotifyDynamic.Properties">
            <summary>
            当前动态类所拥有的属性列表
            </summary>
        </member>
        <member name="E:System.NotifyDynamic.PropertyChanged">
            <summary>
            属性通知
            </summary>
        </member>
        <member name="M:System.NotifyDynamic.GetValue(System.String)">
            <summary>
            获取属性值
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.NotifyDynamic.SetValue(System.String,System.Object)">
            <summary>
            设置属性值
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:System.HttpHelper.SendHttpRequest(System.String,System.String)">
            <summary>
            发送请求
            </summary>
            <param name="url">Url地址</param>
            <param name="data">数据</param>
        </member>
        <member name="M:System.HttpHelper.GetData(System.String)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:System.HttpHelper.SendPostHttpRequest(System.String,System.String,System.String)">
            <summary>
            发送请求
            </summary>
            <param name="url">Url地址</param>
            <param name="method">方法（post或get）</param>
            <param name="method">数据类型</param>
            <param name="requestData">数据</param>
        </member>
        <member name="M:System.HttpHelper.SendGetHttpRequest(System.String,System.String)">
            <summary>
            发送请求
            </summary>
            <param name="url">Url地址</param>
            <param name="method">方法（post或get）</param>
            <param name="method">数据类型</param>
            <param name="requestData">数据</param>
        </member>
        <member name="T:System.Collections.Generic.CollectionHelper">
            <summary>集合扩展</summary>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToArray``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>集合转为数组，加锁确保安全</summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="index">数组偏移量。大于0时，新数组将空出来前面一截，把数据拷贝到后面</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>集合转为数组，加锁确保安全</summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToKeyArray``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToValueArray``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToDictionary(System.Object)">
            <summary>目标匿名参数对象转为字典</summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Merge(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object,System.Boolean,System.String[])">
            <summary>合并字典参数</summary>
            <param name="dic">字典</param>
            <param name="target">目标对象</param>
            <param name="overwrite">是否覆盖同名参数</param>
            <param name="excludes">排除项</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToNullable``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>转为可空字典</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Take``1(System.Collections.Generic.Queue{``0},System.Int32)">
            <summary>从队列里面获取指定个数元素</summary>
            <typeparam name="T"></typeparam>
            <param name="collection">消费集合</param>
            <param name="count">元素个数</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Take``1(System.Collections.Concurrent.IProducerConsumerCollection{``0},System.Int32)">
            <summary>从消费集合里面获取指定个数元素</summary>
            <typeparam name="T"></typeparam>
            <param name="collection">消费集合</param>
            <param name="count">元素个数</param>
            <returns></returns>
        </member>
        <member name="T:System.Collections.Generic.ListExtension">
            <summary>扩展List，支持遍历中修改元素</summary>
        </member>
        <member name="M:System.Collections.Generic.ListExtension.Find``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>线程安全，搜索并返回第一个，支持遍历中修改元素</summary>
            <param name="list">实体列表</param>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.ListExtension.FindAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>线程安全，搜索并返回第一个，支持遍历中修改元素</summary>
            <param name="list">实体列表</param>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="T:System.Utility">
            <summary>工具类</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/utility
            
            采用静态架构，允许外部重载工具类的各种实现<seealso cref="T:System.DefaultConvert"/>。
            所有类型转换均支持默认值，默认值为该default(T)，在转换失败时返回默认值。
            </remarks>
        </member>
        <member name="P:System.Utility.Convert">
            <summary>类型转换提供者</summary>
            <remarks>重载默认提供者<seealso cref="T:System.DefaultConvert"/>并赋值给<see cref="P:System.Utility.Convert"/>可改变所有类型转换的行为</remarks>
        </member>
        <member name="M:System.Utility.ToInt(System.Object,System.Int32)">
            <summary>转为整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix秒）</summary>
            <remarks>Int16/UInt32/Int64等，可以先转为最常用的Int32后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToLong(System.Object,System.Int64)">
            <summary>转为长整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix毫秒）</summary>
            <remarks></remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDouble(System.Object,System.Double)">
            <summary>转为浮点数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）</summary>
            <remarks>Single可以先转为最常用的Double后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToBoolean(System.Object,System.Boolean)">
            <summary>转为布尔型，转换失败时返回默认值。支持大小写True/False、0和非零</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTime(System.Object)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTimeUTC(System.Object)">
            <summary>
            装换为UTC时间
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTime(System.Object,System.DateTime)">
            <summary>转为时间日期，转换失败时返回默认值</summary>
            <remarks><see cref="F:System.DateTime.MinValue"/>不是常量无法做默认值</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTimeOffset(System.Object)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTimeOffset(System.Object,System.DateTimeOffset)">
            <summary>转为时间日期，转换失败时返回默认值</summary>
            <remarks><see cref="F:System.DateTimeOffset.MinValue"/>不是常量无法做默认值</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.Trim(System.DateTime,System.String)">
            <summary>去掉时间日期秒后面部分，可指定毫秒</summary>
            <param name="value">时间日期</param>
            <param name="format">格式字符串，默认s格式化到秒，ms格式化到毫秒</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.Trim(System.DateTimeOffset,System.String)">
            <summary>去掉时间日期秒后面部分，可指定毫秒</summary>
            <param name="value">时间日期</param>
            <param name="format">格式字符串，默认s格式化到秒，ms格式化到毫秒</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串，对UTC时间加后缀</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时（DateTime.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTimeOffset,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss +08:00完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时（DateTimeOffset.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToString(System.DateTime,System.String,System.String)">
            <summary>时间日期转为指定格式字符串</summary>
            <param name="value">待转换对象</param>
            <param name="format">格式化字符串</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToGMK(System.UInt64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToGMK(System.Int64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.GetTrue(System.Exception)">
            <summary>获取内部真实异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.GetMessage(System.Exception)">
            <summary>获取异常消息</summary>
            <param name="ex">异常</param>
            <returns></returns>
        </member>
        <member name="T:System.DefaultConvert">
            <summary>默认转换</summary>
        </member>
        <member name="M:System.DefaultConvert.ToInt(System.Object,System.Int32)">
            <summary>转为整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToLong(System.Object,System.Int64)">
            <summary>转为长整数。支持字符串、全角、字节数组（小端）、时间（Unix毫秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDouble(System.Object,System.Double)">
            <summary>转为浮点数</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToBoolean(System.Object,System.Boolean)">
            <summary>转为布尔型。支持大小写True/False、0和非零</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDateTime(System.Object,System.DateTime,System.Boolean)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <param name="toutc">是否返回UTC时间</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDateTimeOffset(System.Object,System.DateTimeOffset)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDBC(System.String)">
            <summary>全角为半角</summary>
            <remarks>全角半角的关系是相差0xFEE0</remarks>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToFullString(System.DateTime,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串</summary>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToFullString(System.DateTimeOffset,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串</summary>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToString(System.DateTime,System.String,System.String)">
            <summary>时间日期转为指定格式字符串</summary>
            <param name="value">待转换对象</param>
            <param name="format">格式化字符串</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.GetTrue(System.Exception)">
            <summary>获取内部真实异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.GetMessage(System.Exception)">
            <summary>获取异常消息</summary>
            <param name="ex">异常</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToGMK(System.UInt64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="T:System.ConcurrentDictionaryExtensions">
            <summary>并发字典扩展</summary>
        </member>
        <member name="M:System.ConcurrentDictionaryExtensions.Remove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>从并发字典中删除</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:System.EndPointExtensions">
            <summary>网络结点扩展</summary>
        </member>
        <member name="M:System.EndPointExtensions.ToAddress(System.Net.EndPoint)">
            <summary>
            
            </summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:System.EndPointExtensions.ToAddress(System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:System.EndPointExtensions.ToEndPoint(System.String)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.EndPointExtensions.ToEndPoints(System.String)">
            <summary>
            
            </summary>
            <param name="addresses"></param>
            <returns></returns>
        </member>
        <member name="T:System.IO.PathHelper">
            <summary>路径操作帮助</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/path_helper
            </remarks>
        </member>
        <member name="P:System.IO.PathHelper.BasePath">
            <summary>基础目录。GetBasePath依赖于此，默认为当前应用程序域基础目录。用于X组件内部各目录，专门为函数计算而定制</summary>
            <remarks>
            为了适应函数计算，该路径将支持从命令行参数和环境变量读取
            </remarks>
        </member>
        <member name="P:System.IO.PathHelper.BaseDirectory">
            <summary>基础目录。GetBasePath依赖于此，默认为当前应用程序域基础目录。已弃用，请使用BasePath</summary>
            <remarks>
            为了适应函数计算，该路径将支持从命令行参数和环境变量读取
            </remarks>
        </member>
        <member name="M:System.IO.PathHelper.GetFullPath(System.String)">
            <summary>获取文件或目录基于应用程序域基目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetBasePath(System.String)">
            <summary>获取文件或目录的全路径，过滤相对目录。用于X组件内部各目录，专门为函数计算而定制</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetCurrentPath(System.String)">
            <summary>获取文件或目录基于当前目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.EnsureDirectory(System.String,System.Boolean)">
            <summary>确保目录存在，若不存在则创建</summary>
            <remarks>
            斜杠结尾的路径一定是目录，无视第二参数；
            默认是文件，这样子只需要确保上一层目录存在即可，否则如果把文件当成了目录，目录的创建会导致文件无法创建。
            </remarks>
            <param name="path">文件路径或目录路径，斜杠结尾的路径一定是目录，无视第二参数</param>
            <param name="isfile">该路径是否是否文件路径。文件路径需要取目录部分</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CombinePath(System.String,System.String[])">
            <summary>合并多段路径</summary>
            <param name="path"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.AsFile(System.String)">
            <summary>文件路径作为文件信息</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.ReadBytes(System.IO.FileInfo,System.Int32,System.Int32)">
            <summary>从文件中读取数据</summary>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.WriteBytes(System.IO.FileInfo,System.Byte[],System.Int32)">
            <summary>把数据写入文件指定位置</summary>
            <param name="file"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.ReadText(System.IO.FileInfo,System.Text.Encoding)">
            <summary>读取所有文本，自动检测编码</summary>
            <remarks>性能较File.ReadAllText略慢，可通过提前检测BOM编码来优化</remarks>
            <param name="file"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.WriteText(System.IO.FileInfo,System.String,System.Text.Encoding)">
            <summary>把文本写入文件，自动检测编码</summary>
            <param name="file"></param>
            <param name="text"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyToIfNewer(System.IO.FileInfo,System.String)">
            <summary>复制到目标文件，目标文件必须已存在，且源文件较新</summary>
            <param name="fi">源文件</param>
            <param name="destFileName">目标文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.OpenRead(System.IO.FileInfo,System.Boolean,System.Action{System.IO.Stream})">
            <summary>打开并读取</summary>
            <param name="file">文件信息</param>
            <param name="compressed">是否压缩</param>
            <param name="func">要对文件流操作的委托</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.OpenWrite(System.IO.FileInfo,System.Boolean,System.Action{System.IO.Stream})">
            <summary>打开并写入</summary>
            <param name="file">文件信息</param>
            <param name="compressed">是否压缩</param>
            <param name="func">要对文件流操作的委托</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.Extract(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>解压缩</summary>
            <param name="fi"></param>
            <param name="destDir"></param>
            <param name="overwrite">是否覆盖目标同名文件</param>
        </member>
        <member name="M:System.IO.PathHelper.Compress(System.IO.FileInfo,System.String)">
            <summary>压缩文件</summary>
            <param name="fi"></param>
            <param name="destFile"></param>
        </member>
        <member name="M:System.IO.PathHelper.AsDirectory(System.String)">
            <summary>路径作为目录信息</summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetAllFiles(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>获取目录内所有符合条件的文件，支持多文件扩展匹配</summary>
            <param name="di">目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyTo(System.IO.DirectoryInfo,System.String,System.String,System.Boolean,System.Action{System.String})">
            <summary>复制目录中的文件</summary>
            <param name="di">源目录</param>
            <param name="destDirName">目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <param name="callback">复制每一个文件之前的回调</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyToIfNewer(System.IO.DirectoryInfo,System.String,System.String,System.Boolean,System.Action{System.String})">
            <summary>对比源目录和目标目录，复制双方都存在且源目录较新的文件</summary>
            <param name="di">源目录</param>
            <param name="destDirName">目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <param name="callback">复制每一个文件之前的回调</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyIfNewer(System.IO.DirectoryInfo,System.String[],System.String,System.Boolean)">
            <summary>从多个目标目录复制较新文件到当前目录</summary>
            <param name="di">当前目录</param>
            <param name="source">多个目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.Compress(System.IO.DirectoryInfo,System.String)">
            <summary>压缩</summary>
            <param name="di"></param>
            <param name="destFile"></param>
        </member>
        <member name="T:System.Web.Script.Serialization.ScriptIgnoreAttribute">
            <summary>忽略Json序列化</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:System.APIStarter" -->
        <member name="M:System.APIStarter.LoadSwaggerXML">
            <summary>
            加载swagger中自定xml
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.StarterHelper">
            <summary>
             Starter.Default(args, typeof(Program));
            </summary>
        </member>
        <member name="T:System.CMDHelper">
            <summary> Windows 专属命令 </summary>
        </member>
        <member name="M:System.CMDHelper.OpenUrl(System.String)">
            <summary>
            默认使用Chrome打卡网页，无时使用系统默认
            </summary>
            <param name="url"></param>
        </member>
        <member name="T:System.ProcessHelper">
            <summary></summary>
        </member>
        <member name="M:System.StringHelper.ToASCII(System.String)">
            <summary> string 转换到 byte[] </summary>
            <param name="body"> 将要转换的 string </param>
            <returns> 返回转换后的 byte[] </returns>
        </member>
        <member name="F:System.StringHelper.DoubleByte">
            <summary> 全角转半角 </summary>
        </member>
        <member name="M:System.StringHelper.ToSingleByte(System.Char)">
            <summary>
            转半角
            </summary>
        </member>
        <member name="M:System.StringHelper.ToDoubleByte(System.Char)">
            <summary>
            转全角
            </summary>
        </member>
        <member name="M:System.StringHelper.ToSingleByte(System.String)">
            <summary>
            转半角
            </summary>
        </member>
        <member name="M:System.StringHelper.ToDoubleByte(System.String)">
            <summary>
            转全角
            </summary>
        </member>
        <member name="M:System.StringHelper.TakeString(System.String,System.Int32,System.Int32)">
            <summary>
            字符串中取字符串
            </summary>
        </member>
        <member name="M:System.StringHelper.ToUrlEncode(System.String,System.Boolean)">
            <summary> Url 转义 默认使用Utf8编码 等同于HttpUtility.UrlEncode </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.ToUrlEncodeHw(System.String,System.Boolean)">
            <summary>
            韩文UrlEncode 
            </summary>
            <param name="obj"></param>
            <param name="encod"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.ToHtmlEncode(System.String)">
            <summary>
            转义 Html 字符至可发送字符 不考虑性能
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.ToHtmlDecode(System.String)">
            <summary>
            转义 Html 字符至可读字符 不考虑性能
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.ToUrlEncode(System.String,System.Text.Encoding,System.Boolean)">
            <summary> Url 转义 等同于HttpUtility.UrlEncode </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.CreateFloder(System.String)">
            <summary>
            mkdir -p
            </summary>
        </member>
        <member name="M:System.StringHelper.CheckForFileName(System.String)">
            <summary> 验证文件名是否合法 </summary>
            <param name="fileName"> 需要检测的文件名 </param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.ToDX(System.Int32)">
            <summary>
            数字转大写
            </summary>
            <param name="Num">数字</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.UnicodeToString(System.String)">
            <summary>
            Unicode 转字符串 \u开头的字符串
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.SystemInfo.IsInDocker(Microsoft.Extensions.Configuration.IConfiguration)">
            <summary>
            是否在Docker中运行,在有 --restart=always  时，关闭端口即关闭docker，使其自动重启即更新
            </summary>
            <param name="Configuration"></param>
            <returns></returns>
        </member>
        <member name="T:System.XmlData">
            <summary> 保存和读取 xml 数据 </summary>
        </member>
        <member name="M:System.XmlData.XmlToObject``1(System.IO.FileInfo)">
            <summary> 从XML读取数据 </summary>
            <typeparam name="T"> 读取的数据类型 </typeparam>
            <param name="fileInfo"> 包含数据的文件 FileInfo 信息 </param>
            <returns> 返回为 null 的时候读取失败 </returns>
        </member>
        <member name="M:System.XmlData.XmlToObject``1(System.String)">
            <summary> 从XML读取数据 </summary>
            <typeparam name="T"> 读取的数据类型 </typeparam>
            /// 
            <param name="FullPath"> 包含数据的文件路径 </param>
            <returns> Tpye = C ， 返回为null的时候读取失败 </returns>
        </member>
        <member name="M:System.XmlData.XmlToString``1(``0,System.String)">
            <summary> 写入数据到 XML </summary>
            <typeparam name="T"> 读取的数据类型 </typeparam>
            <param name="obj">      将要写入的数据 </param>
            <param name="fullpath"> 写 =入的文件路径 </param>
            <returns> 返回为 null 的时候写入成功 </returns>
        </member>
        <member name="M:System.XmlData.XmlToObject_Stream``1(System.IO.Stream)">
            <summary> 从XML读取数据 </summary>
            <typeparam name="T"> 读取的数据类型 </typeparam>
            <param name="stream"> 包含数据的数据流 </param>
            <returns> Tpye = C ， 返回为null的时候读取失败 </returns>
        </member>
        <member name="T:System.XmlAction">
            <summary> 封装对与Xml读写操作的类 <see cref="T:System.String" /> </summary>
        </member>
        <member name="M:System.ByteHelper.ConvertToHexString(System.Byte[])">
            <summary> 转换为十六进制 </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:System.ClassInfoHelper.FindField(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary> 从当前类型一直向上查找指定名称的字段 </summary>
            <param name="type">        查找的起始类型 </param>
            <param name="fieldName">   字段的名称 </param>
            <param name="bindingAttr"> 搜索的标志 </param>
            <returns> 返回查询到的 FieldInfo </returns>
        </member>
        <member name="M:System.ClassInfoHelper.FindProperty(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary> 从当前类型一直向上查找指定名称的属性 </summary>
            <param name="type">        查找的起始类型 </param>
            <param name="propertyName">   属性的名称 </param>
            <param name="bindingAttr"> 搜索的标志 </param>
            <returns> 返回查询到的 PropertyInfo </returns>
        </member>
        <member name="M:System.ClassInfoHelper.FindProperty``1(System.Object,System.String,System.Reflection.BindingFlags)">
            <summary> 从当前类型一直向上查找指定名称的属性 </summary>
            <param name="data">         查找的起始类型 </param>
            <param name="propertyName"> 属性的名称 </param>
            <param name="bindingAttr">  搜索的标志 </param>
            <returns> 返回查询到的 PropertyInfo </returns>
        </member>
        <member name="M:System.ClassInfoHelper.FindFieldInAssembly``1(System.Reflection.Assembly,System.Reflection.BindingFlags)">
            <summary> 查询当前程序集所拥有的指定类型字段字段元数据集合 </summary>
            <typeparam name="T"> 指定查询的类型 </typeparam>
            <param name="assembly">    查选的程序集 </param>
            <param name="bindingAttr"> 查询的指定参数 </param>
            <returns> 查询到的字段元数据集合 </returns>
        </member>
        <member name="M:System.ClassInfoHelper.FindStaticFieldValueInAssembly``1(System.Reflection.Assembly,System.Reflection.BindingFlags)">
            <summary> 查询当前程序集所拥有的指定类型静态字段集合 </summary>
            <typeparam name="T"> 指定查询的类型 </typeparam>
            <param name="assembly">    查选的程序集 </param>
            <param name="bindingAttr"> 查询的指定参数 </param>
            <returns> 查询到指定静态类型的值集合 </returns>
        </member>
        <member name="M:System.ClassInfoHelper.FindInterfacesInAssembly``1(System.Reflection.Assembly,System.Reflection.BindingFlags)">
            <summary> 查询当前程序集所拥有的指定类型接口的接口元数据集合 </summary>
            <typeparam name="T"> 指定查询类型的接口 </typeparam>
            <param name="assembly">    查选的程序集 </param>
            <param name="bindingAttr"> 查询的指定参数 </param>
            <returns> 查询到的字段元数据集合 </returns>
        </member>
        <member name="M:System.ClassInfoHelper.DeepCopy``1(``0,``0)">
            <summary> 复制源所有公开的属性值,因为会降低性能，因此不推荐大量使用 </summary>
        </member>
        <member name="T:System.CNDate">
            <summary>
            农历属性
            </summary>
        </member>
        <member name="F:System.CNDate.cnIntYear">
            <summary>
            农历年(整型)
            </summary>
        </member>
        <member name="F:System.CNDate.cnIntMonth">
            <summary>
            农历月份(整型)
            </summary>
        </member>
        <member name="F:System.CNDate.cnIntDay">
            <summary>
            农历天(整型)
            </summary>
        </member>
        <member name="F:System.CNDate.cnStrYear">
            <summary>
            农历年(支干)
            </summary>
        </member>
        <member name="F:System.CNDate.cnStrMonth">
            <summary>
            农历月份(字符)
            </summary>
        </member>
        <member name="F:System.CNDate.cnStrDay">
            <summary>
            农历天(字符)
            </summary>
        </member>
        <member name="F:System.CNDate.cnAnm">
            <summary>
            农历属象
            </summary>
        </member>
        <member name="F:System.CNDate.cnSolarTerm">
            <summary>
            二十四节气
            </summary>
        </member>
        <member name="F:System.CNDate.cnFtvl">
            <summary>
            阴历节日
            </summary>
        </member>
        <member name="F:System.CNDate.cnFtvs">
            <summary>
            阳历节日
            </summary>
        </member>
        <member name="T:System.ChinaDate">
            <summary>
            公历转农历
            </summary>
        </member>
        <member name="M:System.ChinaDate.lYearDays(System.Int32)">
            <summary>
            传回农历y年的总天数
            </summary>
        </member>
        <member name="M:System.ChinaDate.leapDays(System.Int32)">
            <summary>
            传回农历y年闰月的天数
            </summary>
        </member>
        <member name="M:System.ChinaDate.leapMonth(System.Int32)">
            <summary>
            传回农历y年闰哪个月 1-12 , 没闰传回 0
            </summary>
        </member>
        <member name="M:System.ChinaDate.monthDays(System.Int32,System.Int32)">
            <summary>
            传回农历y年m月的总天数
            </summary>
        </member>
        <member name="M:System.ChinaDate.AnimalsYear(System.Int32)">
            <summary>
            传回农历y年的生肖
            </summary>
        </member>
        <member name="M:System.ChinaDate.cyclicalm(System.Int32)">
            <summary>
            传入月日的offset 传回干支,0=甲子
            </summary>
        </member>
        <member name="M:System.ChinaDate.cyclical(System.Int32)">
            <summary>
            传入offset 传回干支, 0=甲子
            </summary>
        </member>
        <member name="M:System.ChinaDate.Lunar(System.Int32,System.Int32)">
            <summary>
            传出农历.year0 .month1 .day2 .yearCyl3 .monCyl4 .dayCyl5 .isLeap6
            </summary>
        </member>
        <member name="M:System.ChinaDate.calElement(System.Int32,System.Int32,System.Int32)">
            <summary>
            传出y年m月d日对应的农历.year0 .month1 .day2 .yearCyl3 .monCyl4 .dayCyl5 .isLeap6
            </summary>
        </member>
        <member name="M:System.ChinaDate.GetDaysByMonth(System.Int32,System.Int32)">
            <summary>
            传回公历y年m月的总天数
            </summary>
        </member>
        <member name="M:System.ChinaDate.GetMondayDateByDate(System.DateTime)">
            <summary>
            根据日期值获得周一的日期
            </summary>
            <param name="dt">输入日期</param>
            <returns>周一的日期</returns>
        </member>
        <member name="M:System.ChinaDate.getChinaDate(System.DateTime)">
            <summary>
            获取农历
            </summary>
        </member>
        <member name="T:System.ChineseCalendar">
            <summary>
            中国日历
            </summary>
        </member>
        <member name="T:System.ChineseCalendar.SolarHolidayStruct">
            <summary>
            阳历
            </summary>
        </member>
        <member name="T:System.ChineseCalendar.LunarHolidayStruct">
            <summary>
            农历
            </summary>
        </member>
        <member name="F:System.ChineseCalendar.LunarDateArray">
             <summary>
             来源于网上的农历数据
             </summary>
             <remarks>
             数据结构如下，共使用17位数据
             第17位：表示闰月天数，0表示29天   1表示30天
             第16位-第5位（共12位）表示12个月，其中第16位表示第一月，如果该月为30天则为1，29天为0
             第4位-第1位（共4位）表示闰月是哪个月，如果当年没有闰月，则置0
            </remarks>
        </member>
        <member name="M:System.ChineseCalendar.#ctor(System.DateTime)">
            <summary>
            用一个标准的公历日期来初使化
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            用农历的日期来初使化
            </summary>
            <param name="cy">农历年</param>
            <param name="cm">农历月</param>
            <param name="cd">农历日</param>
            <param name="LeapFlag">闰月标志</param>
        </member>
        <member name="M:System.ChineseCalendar.GetChineseMonthDays(System.Int32,System.Int32)">
            <summary>
            //传回农历y年m月的总天数
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.GetChineseLeapMonth(System.Int32)">
            <summary>
            传回农历 y年闰哪个月 1-12 , 没闰传回 0
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.GetChineseLeapMonthDays(System.Int32)">
            <summary>
            传回农历y年闰月的天数
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.GetChineseYearDays(System.Int32)">
            <summary>
            取农历年一年的天数
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.GetChineseHour(System.DateTime)">
            <summary>
            获得当前时间的时辰
            </summary> 
        </member>
        <member name="M:System.ChineseCalendar.CheckDateLimit(System.DateTime)">
            <summary>
            检查公历日期是否符合要求
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.CheckChineseDateLimit(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            检查农历日期是否合理
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.ConvertNumToChineseNum(System.Char)">
            <summary>
            将0-9转成汉字形式
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.BitTest32(System.Int32,System.Int32)">
            <summary>
            测试某位是否为真
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.ConvertDayOfWeek(System.DayOfWeek)">
            <summary>
            将星期几转成数字表示
            </summary>
        </member>
        <member name="M:System.ChineseCalendar.CompareWeekDayHoliday(System.DateTime,System.Int32,System.Int32,System.Int32)">
            <summary>
            比较当天是不是指定的第周几
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.newCalendarHoliday">
            <summary>
            计算中国农历节日
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.WeekDayHoliday">
            <summary>
            按某月第几周第几日计算的节日
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.DateHoliday">
            <summary>
            按公历日计算的节日
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.Date">
            <summary>
            取对应的公历日期
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.WeekDay">
            <summary>
            取星期几
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.WeekDayStr">
            <summary>
            周几的字符
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.DateString">
            <summary>
            公历日期中文表示法 如一九九七年七月一日
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.IsLeapYear">
            <summary>
            当前是否公历闰年
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseConstellation">
            <summary>
            28星宿计算
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseHour">
            <summary>
            时辰
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.IsChineseLeapMonth">
            <summary>
            是否闰月
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.IsChineseLeapYear">
            <summary>
            当年是否有闰月
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseDay">
            <summary>
            农历日
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseDayString">
            <summary>
            农历日中文表示
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseMonth">
            <summary>
            农历的月份
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseMonthString">
            <summary>
            农历月份字符串
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseYear">
            <summary>
            取农历年份
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseYearString">
            <summary>
            取农历年字符串如，一九九七年
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseDateString">
            <summary>
            取农历日期表示法：农历一九九七年正月初五
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.ChineseTwentyFourDay">
            <summary>
            定气法计算二十四节气,二十四节气是按地球公转来计算的，并非是阴历计算的
            </summary>
            <remarks>
            节气的定法有两种。古代历法采用的称为"恒气"，即按时间把一年等分为24份，
            每一节气平均得15天有余，所以又称"平气"。现代农历采用的称为"定气"，即
            按地球在轨道上的位置为标准，一周360°，两节气之间相隔15°。由于冬至时地
            球位于近日点附近，运动速度较快，因而太阳在黄道上移动15°的时间不到15天。
            夏至前后的情况正好相反，太阳在黄道上移动较慢，一个节气达16天之多。采用
            定气时可以保证春、秋两分必然在昼夜平分的那两天。
            </remarks>
        </member>
        <member name="P:System.ChineseCalendar.Constellation">
            <summary>
            计算指定日期的星座序号 
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.Animal">
            <summary>
            计算属相的索引，注意虽然属相是以农历年来区别的，但是目前在实际使用中是按公历来计算的
            鼠年为1,其它类推
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.AnimalString">
            <summary>
            取属相字符串
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.GanZhiYearString">
            <summary>
            取农历年的干支表示法如 乙丑年
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.GanZhiMonthString">
            <summary>
            取干支的月表示字符串，注意农历的闰月不记干支
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.GanZhiDayString">
            <summary>
            取干支日表示法
            </summary>
        </member>
        <member name="P:System.ChineseCalendar.GanZhiDateString">
            <summary>
            取当前日期的干支表示法如 甲子年乙丑月丙庚日
            </summary>
        </member>
        <member name="T:System.CollectionUtils">
            <summary>
            表示集合扩展。
            </summary>
        </member>
        <member name="M:System.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            获取枚举数是否为null或者为空。
            </summary>
            <typeparam name="T">类型。</typeparam>
            <param name="items">迭代器。</param>
            <returns>如果迭代器为null或者空，返回true。否则返回false。</returns>
        </member>
        <member name="M:System.CollectionUtils.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
             判断某项在集合中的索引
            </summary>
            <typeparam name="T">Type of collection</typeparam>
            <param name="collection">集合</param>
            <param name="targetItem">目标项</param>
            <returns>如果存在则返回索引，如果不存在则返回-1</returns>
        </member>
        <member name="T:System.CollectionExtensions">
            <summary>
            A set of collection extension methods
            </summary>
        </member>
        <member name="M:System.CollectionExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Enumerates a collection and executes a predicate against each item
            </summary>
            <typeparam name="T">Type of elements</typeparam>
            <param name="collection">Collection</param>
            <param name="action">Action to execute on each element</param>
        </member>
        <member name="M:System.CollectionExtensions.AddRange``1(System.Collections.ObjectModel.ObservableCollection{``0},System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Add a range of IEnumerable collection to an existing Collection.
             </summary>
            <typeparam name="T">Type of collection</typeparam>
            <param name="collection">Collection</param>
             <param name="items">Items to add</param>
        </member>
        <member name="M:System.Check.HaveInjection(System.String)">
            <summary>
            是否含有注入字符串
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:System.DecimalUtility.ConvertNumToZHUpperCase(System.Decimal)">
            <summary>
            转中文大写数字
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.DecimalUtility.ToFixed(System.Decimal,System.Int32)">
            <summary>
            截取指定位数
            </summary>
            <param name="d"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:System.DecimalUtility.ToFixed(System.Double,System.Int32)">
            <summary>
             截取指定位数
            </summary>
            <param name="d"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:System.DesUtil.DESEncrypt(System.String,System.String,System.String)">
            <summary>
            DES加密
            </summary>
            <param name="plainStr">明文字符串</param>
            <returns>密文</returns>
        </member>
        <member name="M:System.DesUtil.DESDecrypt(System.String,System.String,System.String)">
            <summary>
            DES解密
            </summary>
            <param name="encryptStr">密文字符串</param>
            <returns>明文</returns>
        </member>
        <member name="P:System.FileData.MD5">
            <summary>
            摒弃的，现不用MD5
            </summary>
        </member>
        <member name="M:System.DirectoryHelper.Copy(System.IO.DirectoryInfo,System.String,System.IO.FileAttributes)">
            <summary> 将目录及其内容拷贝到新位置。 </summary>
            <param name="dir"></param>
            <param name="targetDirName">目标路径</param>
        </member>
        <member name="M:System.ExpressionHelper.ExtractPropertyName``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary> 获取当前的委托名称 </summary>
            <typeparam name="T">当前发送线程通知的类型</typeparam>
            <param name="propertyExpression">反射获取类型名称的委托</param>
            <returns> 当前的委托名称 </returns>
        </member>
        <member name="T:System.FileHelper">
            <summary> 获取文件的编码格式 </summary>
        </member>
        <member name="M:System.FileHelper.GetEncodingType(System.IO.FileInfo)">
            <summary> 给定文件的路径，读取文件的二进制数据，判断文件的编码类型 </summary> <param name="fileinfo">文件路径</param> <returns>文件的编码类型</returns>
        </member>
        <member name="M:System.FileHelper.GetType(System.IO.FileStream)">
            <summary> 通过给定的文件流，判断文件的编码类型 </summary> <param name="fs">文件流</param> <returns>文件的编码类型</returns>
        </member>
        <member name="M:System.FileHelper.IsUTF8Bytes(System.Byte[])">
            <summary> 判断是否是不带 BOM 的 UTF8 格式 </summary> <param name="data"></param> <returns></returns>
        </member>
        <member name="M:System.FileHelper.ReadText(System.IO.FileInfo)">
            <summary> 根据文件编码格式，自动读取文件的内容 </summary>
            <param name="fileinfo"></param>
            <returns></returns>
        </member>
        <member name="M:System.FileHelper.GetName(System.IO.FileInfo)">
            <summary> 获取文件名称（不含后缀名） </summary>
            <param name="fileinfo"></param>
            <returns></returns>
        </member>
        <member name="M:System.FileHelper.CreatFile(System.String)">
            <summary> 确保文件存在，如果不存在则新建 此项非绝对，比如 1，在没有权限的文件夹下创建 2，此文件无后缀名，且已经存在与文件同名的文件夹时 </summary>
            <param name="fullpath"></param>
        </member>
        <member name="M:System.FileHelper.SaveAllToFile(System.String,System.String)">
            <summary>
            保存所有字符串到文件中
            </summary>
            <param name="path"></param>
            <param name="body"></param>
        </member>
        <member name="M:System.FileHelper.CreatFile(System.IO.FileInfo)">
            <summary> 确保文件存在，如果不存在则新建 此项非绝对，比如 1，在没有权限的文件夹下创建 2，此文件无后缀名，且已经存在与文件同名的文件夹时 </summary>
            <param name="fileinfo"></param>
        </member>
        <member name="M:System.FilesHelper.GetFileContent(System.String)">
            <summary>
            获取指定文件的二进制内容
            </summary>
            <param name="filePath">文件路径</param>
            <returns></returns>
        </member>
        <member name="M:System.FilesHelper.CreateTempFile">
            <summary>
            创建文件到临时目录
            </summary>
            <returns>返回文件在临时文件夹中的绝对路径</returns>
        </member>
        <member name="M:System.FilesHelper.SaveToTempFile(System.Byte[])">
            <summary>
            保存文件到临时目录
            </summary>
            <param name="content">文件内容</param>
            <returns>返回文件在临时文件夹中的绝对路径</returns>
        </member>
        <member name="M:System.FilesHelper.ClearTempFile">
            <summary>
            删除目录下所有子目录及文件
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.EnumFormula">
            <summary>
            EnumFormula
            </summary>
        </member>
        <member name="T:System.FormulaDeal">
            <summary>
            FormulaDeal
            </summary>
        </member>
        <member name="M:System.ListExtensions.ToDataTable(System.Collections.IList)">
            <summary>
            将指定的集合转换成DataTable。
            </summary>
            <param name="list">将指定的集合。</param>
            <returns>返回转换后的DataTable。</returns>
        </member>
        <member name="M:System.ListHelper.Reshuffle``1(System.Collections.Generic.List{``0})">
            <summary>
            打乱
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:System.LnkHelper1.WriteLnk(System.Reflection.Assembly,System.String)">
            <summary>
            var startuppath = Environment.GetFolderPath(Environment.SpecialFolder.Startup);
            typeof(MainWindow).Assembly.WriteLnk(startuppath);
            </summary>
            <param name="assembly"></param>
            <param name="savepath"></param>
        </member>
        <member name="M:System.PinYin.GetCodstring(System.String)">
            <summary>
            取汉字拼音的首字母
            </summary>
            <param name="UnName">汉字</param>
            <returns>首字母</returns>
        </member>
        <member name="T:System.PinyinHelper">
            <summary>  
            中文获取拼音  
            </summary>  
        </member>
        <member name="M:System.PinyinHelper.GetPinyin(System.String)">
            <summary>  
            获得汉字的拼音，非中文直接输出,忽略中文符号  
            </summary>  
            <param name="chineseChars">汉字字符串</param>  
            <returns>拼音</returns>  
        </member>
        <member name="M:System.PinyinHelper.GetPinyinFirstLetter(System.String)">
            <summary>
            获取拼音首字母
            </summary>
            <param name="chineseChar">汉字文本</param>
            <returns>拼音首字母</returns>
        </member>
        <member name="M:System.PinyinHelper.GetPinyinInitials(System.String,System.Boolean)">
            <summary>
            获取汉字拼音大写首字母
            </summary>
            <param name="txt">汉字文本</param>
            <param name="isYaopin">是否是药品，如果是则为true,默认为false</param>
            <returns></returns>
        </member>
        <member name="M:System.RegexHelper.IsLegalFileName(System.String)">
            <summary> 是否为合法文件名称 </summary>
        </member>
        <member name="T:System.ResourceHelper">
            <summary>
            资源帮助类
            </summary>
        </member>
        <member name="M:System.ResourceHelper.GetResourceManager(System.Reflection.Assembly)">
            <summary>
            获取程序集中默认资源文件(Resources)的ResourceManager
            </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetCallingAssemblyResourceObject(System.String)">
            <summary>
            获取调用当前正在执行的方法的方法所在的Assembly中默认资源文件(Resources)的Object资源
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetCallingAssemblyResourceString(System.String)">
            <summary>
            获取调用当前正在执行的方法的方法所在的Assembly中默认资源文件(Resources)的字符串资源
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetCallingAssemblyResourceStream(System.String)">
            <summary>
            获取调用当前正在执行的方法的方法所在的Assembly中默认资源文件(Resources)的流资源
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetResourceObject(System.Reflection.Assembly,System.String)">
            <summary>
            获取指定Assembly中中默认资源文件(Resources)的Object资源
            </summary>
            <param name="assembly"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetResourceString(System.Reflection.Assembly,System.String)">
            <summary>
            获取指定Assembly中中默认资源文件(Resources)的字符串资源
            </summary>
            <param name="assembly"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetResourceStream(System.Reflection.Assembly,System.String)">
            <summary>
            获取指定Assembly中中默认资源文件(Resources)的流资源
            </summary>
            <param name="assembly"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetResourceObject(System.Type,System.String)">
            <summary>
            获取指定资源文件类类型的Object资源
            </summary>
            <param name="assembly"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetResourceString(System.Type,System.String)">
            <summary>
            获取指定资源文件类类型的字符串资源
            </summary>
            <param name="assembly"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.ResourceHelper.GetResourceStream(System.Type,System.String)">
            <summary>
            获取指定资源文件类类型中的字符串资源
            </summary>
            <param name="assembly"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:System.RMBHelper">
            <summary>
            人民币大小写金额转换
            </summary>
        </member>
        <member name="M:System.RMBHelper.RMBAmount(System.Double)">
            <summary>
            人民币大写金额
            </summary>
            <param name="value">人民币数字金额值</param>
            <returns>返回人民币大写金额</returns>
        </member>
        <member name="M:System.RMBHelper.ConvertIntToUppercaseAmount(System.String)">
            <summary>
            转换整数为大写金额
            最高精度为垓，保留小数点后4位，实际精度为亿兆已经足够了，理论上精度无限制，如下所示：
            序号:...30.29.28.27.26.25.24  23.22.21.20.19.18  17.16.15.14.13  12.11.10.9   8 7.6.5.4  . 3.2.1.0
            单位:...垓兆亿万仟佰拾        京亿万仟佰拾       兆万仟佰拾      亿仟佰拾     万仟佰拾元 . 角分厘毫
            数值:...1000000               000000             00000           0000         00000      . 0000
            下面列出网上搜索到的数词单位：
            元、十、百、千、万、亿、兆、京、垓、秭、穰、沟、涧、正、载、极
            </summary>
            <param name="capValue">整数值</param>
            <returns>返回大写金额</returns>
        </member>
        <member name="M:System.RMBHelper.ConvertDecToUppercaseAmount(System.String,System.Boolean)">
            <summary>
            转换小数为大写金额
            </summary>
            <param name="capValue">小数值</param>
            <param name="addZero">是否增加零位</param>
            <returns>返回大写金额</returns>
        </member>
        <member name="M:System.SpellCode.GetPYM(System.String)">
            <summary>
            取得字符串首字母
            </summary>
            <param name="IndexTxt"></param>
            <returns></returns>
        </member>
        <member name="M:System.SpellCode.GetPYM(System.Char)">
            <summary>
            得到单个字符的首字母
            </summary>
            <param name="chapter"></param>
            <returns></returns>
        </member>
        <member name="M:System.SpellCode.GetWBM(System.String)">
            <summary>
            生成五笔码
            </summary>
            <param name="InputText"></param>
            <returns></returns>
        </member>
        <member name="M:System.StreamHelper.GetRateText(System.Double)">
            <summary> 转换字节长度为 M </summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.MatchExceptStart(System.String)">
            <summary>
            从第一个匹配项后取剩下字符串
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.MatchOne(System.String,System.String,System.Boolean)">
            <summary>
            获取 _???_ 中第一个匹配字符串
            </summary>
            <param name="body"></param>
            <param name="key"></param>
            <param name="isconse"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.MatchAll(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            获取 _???_ 中所有匹配字符串
            </summary>
            <param name="body"></param>
            <param name="key"> _???_ 为分隔符获取中间匹配项 </param>
            <param name="isconse">是否包含分割内容</param>
            <param name="isone">是否只取第一个</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.GetHtmlMatchValue(System.String)">
            <summary>
            获取 html 匹配项的value值
            </summary>
            <param name="body"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.ToSFormate(System.Nullable{System.Decimal},System.String)">
            <summary>
            转换为指定格式字符串
            </summary>
            <param name="obj"></param>
            <param name="formate"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.ReplaceLast(System.String,System.String,System.String,System.StringComparison)">
            <summary> 替换最后一个匹配字符串 </summary>
            <param name="str">            原字符串 </param>
            <param name="oldStr">         即将被替换的字符串 </param>
            <param name="newStr">         即将替换的字符串, null =&gt; string.Empty </param>
            <param name="comparisonType"> 字符串检查类型 </param>
            <returns> 返回替换后的字符串 </returns>
        </member>
        <member name="M:System.StringHelper2.ReplaceAllToSpace(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            转换所有匹配项到空白
            </summary>
            <param name="str"></param>
            <param name="oldStr"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.ContainsChineseChar(System.String)">
            <summary> 检测是否包含中文字符 </summary>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.IsAnyEqual(System.String,System.String[])">
            <summary> 是否匹配某一项字符 </summary>
            <param name="str">       </param>
            <param name="comparison"></param>
            <param name="parmas">    </param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper2.IsAnyEqual(System.String,System.StringComparison,System.String[])">
            <summary> 是否匹配某一项字符 </summary>
            <param name="str">       </param>
            <param name="comparison"></param>
            <param name="parmas">    </param>
            <returns></returns>
        </member>
        <member name="M:System.TaskManager.StartNews``1(System.Action{System.Collections.Generic.IEnumerable{``0}},System.Func{``0}[])">
            <summary>
            开始新的任务
            </summary>
            <param name="completeAction">任务完成时执行</param>
            <param name="actions">任务集合</param>
        </member>
        <member name="M:System.TimerHelper.GetTimeStamp(System.DateTime)">
            <summary> 转换标准时间为时间戳 </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimerHelper.GetTimeStampWithMs(System.DateTime)">
            <summary> 转换标准时间为时间戳，包含毫秒部分，占用三位 </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimerHelper.ToDateTimeOf10(System.Int64)">
            <summary>
            十位 long 时间戳 转当地时间
            </summary>
            <param name="timeStamp"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimerHelper.ToStamp10(System.DateTime)">
            <summary>
            当地时间转10位时间戳
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:System.TimerHelper.ToView(System.DateTime)">
            <summary>
            ToString("yyyy-MM-dd HH:mm:ss.fff")
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:System.ValidatorHelper.IsMatch(System.String,System.String)">
            <summary>  
            验证字符串是否匹配正则表达式描述的规则  
            </summary>  
            <param name="inputStr">待验证的字符串</param>  
            <param name="patternStr">正则表达式字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsMatch(System.String,System.String,System.Boolean)">
            <summary>  
            验证字符串是否匹配正则表达式描述的规则  
            </summary>  
            <param name="inputStr">待验证的字符串</param>  
            <param name="patternStr">正则表达式字符串</param>  
            <param name="ifIgnoreCase">匹配时是否不区分大小写</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsMatch(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>  
            验证字符串是否匹配正则表达式描述的规则  
            </summary>  
            <param name="inputStr">待验证的字符串</param>  
            <param name="patternStr">正则表达式字符串</param>  
            <param name="ifIgnoreCase">匹配时是否不区分大小写</param>  
            <param name="ifValidateWhiteSpace">是否验证空白字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsNumber(System.String)">
            <summary>  
            验证数字(double类型)  
            [可以包含负号和小数点]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsInteger(System.String)">
            <summary>  
            验证整数  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIntegerNotNagtive(System.String)">
            <summary>  
            验证非负整数  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIntegerPositive(System.String)">
            <summary>  
            验证正整数  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsDecimal(System.String)">
            <summary>  
            验证小数  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsEnglishCharacter(System.String)">
            <summary>  
            验证只包含英文字母  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIntegerAndEnglishCharacter(System.String)">
            <summary>  
            验证只包含数字和英文字母  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsChineseCharacter(System.String)">
            <summary>  
            验证只包含汉字  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIntegerLength(System.String,System.Int32,System.Int32)">
            <summary>  
            验证数字长度范围（数字前端的0计长度）  
            [若要验证固定长度，可传入相同的两个长度数值]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <param name="lengthBegin">长度范围起始值（含）</param>  
            <param name="lengthEnd">长度范围结束值（含）</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsStringInclude(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>  
            验证字符串包含内容  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <param name="withEnglishCharacter">是否包含英文字母</param>  
            <param name="withNumber">是否包含数字</param>  
            <param name="withChineseCharacter">是否包含汉字</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsStringLength(System.String,System.Int32,System.Int32)">
            <summary>  
            验证字符串长度范围  
            [若要验证固定长度，可传入相同的两个长度数值]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <param name="lengthBegin">长度范围起始值（含）</param>  
            <param name="lengthEnd">长度范围结束值（含）</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsStringLengthOnlyNumberAndEnglishCharacter(System.String,System.Int32,System.Int32)">
            <summary>  
            验证字符串长度范围（字符串内只包含数字和/或英文字母）  
            [若要验证固定长度，可传入相同的两个长度数值]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <param name="lengthBegin">长度范围起始值（含）</param>  
            <param name="lengthEnd">长度范围结束值（含）</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsStringLengthByInclude(System.String,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>  
            验证字符串长度范围  
            [若要验证固定长度，可传入相同的两个长度数值]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <param name="withEnglishCharacter">是否包含英文字母</param>  
            <param name="withNumber">是否包含数字</param>  
            <param name="withChineseCharacter">是否包含汉字</param>  
            <param name="lengthBegin">长度范围起始值（含）</param>  
            <param name="lengthEnd">长度范围结束值（含）</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsStringByteLength(System.String,System.Int32,System.Int32)">
            <summary>  
            验证字符串字节数长度范围  
            [若要验证固定长度，可传入相同的两个长度数值；每个汉字为两个字节长度]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <param name="lengthBegin">长度范围起始值（含）</param>  
            <param name="lengthEnd">长度范围结束值（含）</param>  
            <returns></returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsDateTime(System.String)">
            <summary>  
            验证日期  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsTelePhoneNumber(System.String)">
            <summary>  
            验证固定电话号码  
            [3位或4位区号；区号可以用小括号括起来；区号可以省略；区号与本地号间可以用减号或空格隔开；可以有3位数的分机号，分机号前要加减号]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsMobilePhoneNumber(System.String)">
            <summary>  
            验证手机号码  
            [可匹配"(+86)013325656352"，括号可以省略，+号可以省略，(+86)可以省略，11位手机号前的0可以省略；11位手机号第二位数可以是3、4、5、8中的任意一个]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsPhoneNumber(System.String)">
            <summary>  
            验证电话号码（可以是固定电话号码或手机号码）  
            [固定电话：[3位或4位区号；区号可以用小括号括起来；区号可以省略；区号与本地号间可以用减号或空格隔开；可以有3位数的分机号，分机号前要加减号]]  
            [手机号码：[可匹配"(+86)013325656352"，括号可以省略，+号可以省略，(+86)可以省略，手机号前的0可以省略；手机号第二位数可以是3、4、5、8中的任意一个]]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsZipCode(System.String)">
            <summary>  
            验证邮政编码  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsEmail(System.String)">
            <summary>  
            验证电子邮箱  
            [@字符前可以包含字母、数字、下划线和点号；@字符后可以包含字母、数字、下划线和点号；@字符后至少包含一个点号且点号不能是最后一个字符；最后一个点号后只能是字母或数字]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsURL(System.String)">
            <summary>  
            验证网址（可以匹配IPv4地址但没对IPv4地址进行格式验证；IPv6暂时没做匹配）  
            [允许省略"://"；可以添加端口号；允许层级；允许传参；域名中至少一个点号且此点号前要有内容]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIPv4(System.String)">
            <summary>  
            验证IPv4地址  
            [第一位和最后一位数字不能是0或255；允许用0补位]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIPv6(System.String)">
            <summary>  
            验证IPv6地址  
            [可用于匹配任何一个合法的IPv6地址]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIDCard15(System.String)">
            <summary>  
            验证一代身份证号（15位数）  
            [长度为15位的数字；匹配对应省份地址；生日能正确匹配]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIDCard18(System.String)">
            <summary>  
            验证二代身份证号（18位数，GB11643-1999标准）  
            [长度为18位；前17位为数字，最后一位(校验码)可以为大小写x；匹配对应省份地址；生日能正确匹配；校验码能正确匹配]  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsIDCard(System.String)">
            <summary>  
            验证身份证号（不区分一二代身份证号）  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsLongitude(System.String)">
            <summary>  
            验证经度  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.ValidatorHelper.IsLatitude(System.String)">
            <summary>  
            验证纬度  
            </summary>  
            <param name="input">待验证的字符串</param>  
            <returns>是否匹配</returns>  
        </member>
        <member name="M:System.GZipHelper.UnGZip(System.String)">
            <summary>
            字符串解压缩
            </summary>
        </member>
        <member name="M:System.GZipHelper.UnGZip(System.String,System.Text.Encoding)">
            <summary>
            字符串解压缩
            </summary>
            <param name="param"></param>
            <param name="encode">编码</param>
            <returns></returns>
        </member>
        <member name="M:System.GZipHelper.GZip(System.String)">
            <summary>
            字符串压缩
            </summary>
            <param name="param"></param>
            <returns></returns>
        </member>
        <member name="M:System.GZipHelper.GZip(System.String,System.Text.Encoding)">
            <summary>
            字符串压缩
            </summary>
            <param name="param"></param>
            <param name="encode"></param>
            <returns></returns>
        </member>
        <member name="M:System.JZip.CompressBase64(System.String)">
            <summary>
            压缩字符串至base64
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:System.JZip.DeCompressBase64(System.String)">
            <summary>
            从base64字符串中还原原字符串
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:System.JZip.ExtractFirst(System.Byte[])">
            <summary>
            解压缩第一个文件并返回文件字节
            </summary>
            <param name="zipbytes"></param>
            <returns></returns>
        </member>
        <member name="M:System.JZip.CompressFirst(System.String)">
            <summary>
            使用当前时间戳压缩字符串为第一个文件
            </summary>
            <param name="data"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:System.ZipTest.UnZipFile(System.String,System.String)">
            <summary>
            解压文件
            </summary>
            <param name="zipFilePath"></param>
            <param name="targetDir"></param>
        </member>
        <member name="T:Service.Core.BatchCronJob">
            <summary>
             JJob.StartNow = true;   BatchCronJob.CreatNew("tttdsdsdtt", "0/5 * * * * ?", init: true).OnExcuting = (j, b) =>    {    System.Console.WriteLine("2222    " + DateTime.Now.ToFullString());    };
            </summary>
        </member>
        <member name="M:Service.Core.BatchCronJob.CreatNew(System.String,System.String,System.String,System.Boolean)">
            <summary>
            创建定时计划任务
            </summary>
            <param name="key"></param>
            <param name="cron"></param>
            <param name="groupname"></param>
            <returns></returns>
        </member>
        <member name="T:Service.Core.BatchSpanJob">
            <summary>
            批量任务
            </summary>
        </member>
        <member name="T:Service.Core.JJob_Cron">
            <summary>
            https://cron.qqe2.com/ cron 在线生成
            </summary>
        </member>
        <member name="P:Service.Core.JJob.StartNow">
            <summary>
            是否启动时立即执行一次
            </summary>
        </member>
        <member name="P:Service.Core.JJob.FirstStart">
            <summary>
            启动不执行时第一次延时时间
            </summary>
        </member>
        <member name="T:his_yb_api.Conotrollers.DataTest">
            <summary>
            【100】 上传测试
            </summary>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.read">
            <summary>
            测试读数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.write">
            <summary>
            测试写数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.exception">
            <summary>
            测试异常返回
            </summary>
            <returns></returns>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.post">
            <summary>
            测试读数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.post1(his_yb_api.Conotrollers.DataTest.pd)">
            <summary>
            测试读数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.transaction">
            <summary>
            测试事务
            </summary>
            <returns></returns>
        </member>
        <member name="M:his_yb_api.Conotrollers.DataTest.downloadfile(System.String)">
            <summary>
            测试直接下载文件
            </summary>
            <returns></returns>
        </member>
        <member name="T:GetIP.Controllers.IP">
            <summary>
            【98】  获取连接IP ，取 RemoteIpAddress 不可伪造
            </summary>
        </member>
        <member name="M:GetIP.Controllers.IP.Get">
            <summary>
            获取请求RemoteIpAddress
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:CloseContactAnalysis.Controllers.MainPage" -->
        <member name="F:CloseContactAnalysis.Controllers.MainPage.ExExts">
            <summary>
            禁止外链文件
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetIndex">
            <summary>
            获取index.html
            </summary>
            <returns></returns>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.Swagger">
            <summary>
            非线上模式时，开启swagger路由
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Root(System.String)">
            <summary>
            获取指定名称文件 
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Static_Css(System.String)">
            <summary>
            获取 static/css/ 指定名称文件 
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Js(System.String)">
            <summary>
            获取 js/ 指定名称文件 
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Css(System.String)">
            <summary>
            获取 css/ 指定名称文件 
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Fonts(System.String)">
            <summary>
            获取 fonts/ 指定名称文件 
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Static_Fonts(System.String)">
            <summary>
            获取 static/fonts/ 指定名称文件 
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile_Static_Js(System.String)">
            <summary>
            获取 static/js/ 指定名称文件 
            </summary>
        </member>
        <member name="M:CloseContactAnalysis.Controllers.MainPage.GetFile(System.String)">
            <summary>
            获取指定路径下文件，不可超出应用程序域根路径
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:cwdata.Actions.TokenController">
            <summary>
            提供默认 Token 存取API，此Token会在根路径下生成token文件保存
            </summary>
        </member>
        <member name="M:cwdata.Actions.TokenController.GetToken">
            <summary>
            获取 Token
            </summary>
            <returns></returns>
        </member>
        <member name="M:cwdata.Actions.TokenController.ReToken(System.String)">
            <summary>
            重置 Token
            </summary>
        </member>
        <member name="T:IniParser.Exceptions.ParsingException">
            <summary>
            Represents an error ococcurred while parsing data 
            </summary>
        </member>
        <member name="T:IniParser.FileIniDataParser">
            <summary>
                Represents an INI data parser for files.
            </summary>
        </member>
        <member name="M:IniParser.FileIniDataParser.#ctor">
            <summary>
                Ctor
            </summary>
        </member>
        <member name="M:IniParser.FileIniDataParser.#ctor(IniParser.Parser.IniDataParser)">
            <summary>
                Ctor
            </summary>
            <param name="parser"></param>
        </member>
        <member name="M:IniParser.FileIniDataParser.ReadFile(System.String)">
            <summary>
                Implements reading ini data from a file.
            </summary>
            <remarks>
                Uses <see cref="P:System.Text.Encoding.Default" /> codification for the file.
            </remarks>
            <param name="filePath">
                Path to the file
            </param>
        </member>
        <member name="M:IniParser.FileIniDataParser.ReadFile(System.String,System.Text.Encoding)">
            <summary>
                Implements reading ini data from a file.
            </summary>
            <param name="filePath">
                Path to the file
            </param>
            <param name="fileEncoding">
                File's encoding.
            </param>
        </member>
        <member name="M:IniParser.FileIniDataParser.SaveFile(System.String,IniParser.Model.IniData)">
            <summary>
                Saves INI data to a file.
            </summary>
            <remarks>
                Creats an ASCII encoded file by default.
            </remarks>
            <param name="filePath">
                Path to the file.
            </param>
            <param name="parsedData">
                IniData to be saved as an INI file.
            </param>
        </member>
        <member name="M:IniParser.FileIniDataParser.WriteFile(System.String,IniParser.Model.IniData,System.Text.Encoding)">
            <summary>
                Writes INI data to a text file.
            </summary>
            <param name="filePath">
                Path to the file.
            </param>
            <param name="parsedData">
                IniData to be saved as an INI file.
            </param>
            <param name="fileEncoding">
                Specifies the encoding used to create the file.
            </param>
        </member>
        <member name="M:IniParser.Helpers.Assert.StringHasNoBlankSpaces(System.String)">
            <summary>
            Asserts that a strings has no blank spaces.
            </summary>
            <param name="s">The string to be checked.</param>
            <returns></returns>
        </member>
        <member name="T:IniParser.Model.Configuration.IniParserConfiguration">
            <summary>
                Defines data for a Parser configuration object.
            </summary>
                With a configuration object you can redefine how the parser
                will detect special items in the ini file by defining new regex
                (e.g. you can redefine the comment regex so it just treat text as
                a comment iff the comment caracter is the first in the line)
                or changing the set of characters used to define elements in
                the ini file (e.g. change the 'comment' caracter from ';' to '#')
                You can also define how the parser should treat errors, or how liberal
                or conservative should it be when parsing files with "strange" formats.
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.SectionStartChar">
            <summary>
                Sets the char that defines the start of a section name.
            </summary>
            <remarks>
                Defaults to character '['
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.SectionEndChar">
            <summary>
                Sets the char that defines the end of a section name.
            </summary>
            <remarks>
                Defaults to character ']'
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.CaseInsensitive">
            <summary>
                Retrieving section / keys by name is done with a case-insensitive
                search.
            </summary>
            <remarks>
                Defaults to false (case sensitive search)
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.CommentChar">
            <summary>
                Sets the char that defines the start of a comment.
                A comment spans from the comment character to the end of the line.
            </summary>
            <remarks>
                Defaults to character ';'
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.CommentString">
            <summary>
                Sets the string that defines the start of a comment.
                A comment spans from the mirst matching comment string
                to the end of the line.
            </summary>
            <remarks>
                Defaults to string ";"
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.NewLineStr">
            <summary>
                Gets or sets the string to use as new line string when formating an IniData structure using a
                IIniDataFormatter. Parsing an ini-file accepts any new line character (Unix/windows)
            </summary>
            <remarks>
                This allows to write a file with unix new line characters on windows (and vice versa)
            </remarks>
            <value>Defaults to value Environment.NewLine</value>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.KeyValueAssigmentChar">
            <summary>
                Sets the char that defines a value assigned to a key
            </summary>
            <remarks>
                Defaults to character '='
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.AssigmentSpacer">
            <summary>
                Sets the string around KeyValuesAssignmentChar
            </summary>
            <remarks>
                Defaults to string ' '
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.AllowKeysWithoutSection">
            <summary>
                Allows having keys in the file that don't belong to any section.
                i.e. allows defining keys before defining a section.
                If set to <c>false</c> and keys without a section are defined,
                the <see cref="T:IniParser.Parser.IniDataParser" /> will stop with an error.
            </summary>
            <remarks>
                Defaults to <c>true</c>.
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.AllowDuplicateKeys">
            <summary>
                If set to <c>false</c> and the <see cref="T:IniParser.Parser.IniDataParser" /> finds duplicate keys in a
                section the parser will stop with an error.
                If set to <c>true</c>, duplicated keys are allowed in the file. The value
                of the duplicate key will be the last value asigned to the key in the file.
            </summary>
            <remarks>
                Defaults to <c>false</c>.
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.OverrideDuplicateKeys">
            <summary>
                Only used if <see cref="P:IniParser.Model.Configuration.IniParserConfiguration.AllowDuplicateKeys" /> is also <c>true</c>
                If set to <c>true</c> when the parser finds a duplicate key, it overrites
                the previous value, so the key will always contain the value of the
                last key readed in the file
                If set to <c>false</c> the first readed value is preserved, so the key will
                always contain the value of the first key readed in the file
            </summary>
            <remarks>
                Defaults to <c>false</c>.
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.ConcatenateDuplicateKeys">
            <summary>
                Gets or sets a value indicating whether duplicate keys are concatenate
                together by <see cref="!:ConcatenateSeparator" />.
            </summary>
            <value>
                Defaults to <c>false</c>.
            </value>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.ThrowExceptionsOnError">
            <summary>
                If <c>true</c> the <see cref="T:IniParser.Parser.IniDataParser" /> instance will thrown an exception
                if an error is found.
                If <c>false</c> the parser will just stop execution and return a null value.
            </summary>
            <remarks>
                Defaults to <c>true</c>.
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.AllowDuplicateSections">
            <summary>
                If set to <c>false</c> and the <see cref="T:IniParser.Parser.IniDataParser" /> finds a duplicate section
                the parser will stop with an error.
                If set to <c>true</c>, duplicated sections are allowed in the file, but only a
                <see cref="T:IniParser.Model.SectionData" /> element will be created in the <see cref="P:IniParser.Model.IniData.Sections" />
                collection.
            </summary>
            <remarks>
                Defaults to <c>false</c>.
            </remarks>
        </member>
        <member name="P:IniParser.Model.Configuration.IniParserConfiguration.AllowCreateSectionsOnFly">
            <summary>
                If set to <c>false</c>, the <see cref="T:IniParser.Parser.IniDataParser" /> stop with a error if you try
                to access a section that was not created previously and the parser will stop with an error.
                If set to <c>true</c>, inexistents sections are created, always returning a valid
                <see cref="T:IniParser.Model.SectionData" /> element.
            </summary>
            <remarks>
                Defaults to <c>false</c>.
            </remarks>
        </member>
        <member name="M:IniParser.Model.Configuration.IniParserConfiguration.#ctor">
            <summary>
                Default values used if an instance of <see cref="T:IniParser.Parser.IniDataParser" />
                is created without specifying a configuration.
            </summary>
            <remarks>
                By default the various delimiters for the data are setted:
                <para>';' for one-line comments</para>
                <para>'[' ']' for delimiting a section</para>
                <para>'=' for linking key / value pairs</para>
                <example>
                    An example of well formed data with the default values:
                    <para>
                    ;section comment<br />
                    [section] ; section comment<br />
                    <br />
                    ; key comment<br />
                    key = value ;key comment<br />
                    <br />
                    ;key2 comment<br />
                    key2 = value<br />
                    </para>
                </example>
            </remarks>
        </member>
        <member name="M:IniParser.Model.Configuration.IniParserConfiguration.#ctor(IniParser.Model.Configuration.IniParserConfiguration)">
            <summary>
                Copy ctor.
            </summary>
            <param name="ori">
                Original instance to be copied.
            </param>
        </member>
        <member name="M:IniParser.Model.Configuration.IniParserConfiguration.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:IniParser.Model.Formatting.DefaultIniDataFormatter.Configuration">
            <summary>
                Configuration used to write an ini file with the proper
                delimiter characters and data.
            </summary>
            <remarks>
                If the <see cref="T:IniParser.Model.IniData" /> instance was created by a parser,
                this instance is a copy of the <see cref="T:IniParser.Model.Configuration.IniParserConfiguration" /> used
                by the parser (i.e. different objects instances)
                If this instance is created programatically without using a parser, this
                property returns an instance of <see cref="T:IniParser.Model.Configuration.IniParserConfiguration" />
            </remarks>
        </member>
        <member name="T:IniParser.Model.Formatting.IIniDataFormatter">
            <summary>
                Formats a IniData structure to an string
            </summary>
        </member>
        <member name="P:IniParser.Model.Formatting.IIniDataFormatter.Configuration">
            <summary>
                Configuration used by this formatter when converting IniData
                to an string
            </summary>
        </member>
        <member name="M:IniParser.Model.Formatting.IIniDataFormatter.IniDataToString(IniParser.Model.IniData)">
            <summary>
                Produces an string given
            </summary>
            <returns>The data to string.</returns>
            <param name="iniData">Ini data.</param>
        </member>
        <member name="T:IniParser.Model.IniData">
            <summary>
                Represents all data from an INI file
            </summary>
        </member>
        <member name="F:IniParser.Model.IniData._sections">
            <summary>
                Represents all sections from an INI file
            </summary>
        </member>
        <member name="F:IniParser.Model.IniData._configuration">
            <summary>
                See property <see cref="P:IniParser.Model.IniData.Configuration" /> for more information. 
            </summary>
        </member>
        <member name="P:IniParser.Model.IniData.Configuration">
            <summary>
                Configuration used to write an ini file with the proper
                delimiter characters and data.
            </summary>
            <remarks>
                If the <see cref="T:IniParser.Model.IniData" /> instance was created by a parser,
                this instance is a copy of the <see cref="T:IniParser.Model.Configuration.IniParserConfiguration" /> used
                by the parser (i.e. different objects instances)
                If this instance is created programatically without using a parser, this
                property returns an instance of <see cref="T:IniParser.Model.Configuration.IniParserConfiguration" />
            </remarks>
        </member>
        <member name="P:IniParser.Model.IniData.Global">
            <summary>
            	Global sections. Contains key/value pairs which are not
            	enclosed in any section (i.e. they are defined at the beginning 
            	of the file, before any section.
            </summary>
        </member>
        <member name="P:IniParser.Model.IniData.Item(System.String)">
            <summary>
            Gets the <see cref="T:IniParser.Model.KeyDataCollection" /> instance 
            with the specified section name.
            </summary>
        </member>
        <member name="P:IniParser.Model.IniData.Sections">
            <summary>
            Gets or sets all the <see cref="T:IniParser.Model.SectionData" /> 
            for this IniData instance.
            </summary>
        </member>
        <member name="P:IniParser.Model.IniData.SectionKeySeparator">
            <summary>
                Used to mark the separation between the section name and the key name 
                when using <see cref="M:IniParser.Model.IniData.TryGetKey(System.String,System.String@)" />. 
            </summary>
            <remarks>
                Defaults to '.'.
            </remarks>
        </member>
        <member name="M:IniParser.Model.IniData.#ctor">
            <summary>
                Initializes an empty IniData instance.
            </summary>
        </member>
        <member name="M:IniParser.Model.IniData.#ctor(IniParser.Model.SectionDataCollection)">
            <summary>
                Initializes a new IniData instance using a previous
                <see cref="T:IniParser.Model.SectionDataCollection" />.
            </summary>
            <param name="sdc">
                <see cref="T:IniParser.Model.SectionDataCollection" /> object containing the
                data with the sections of the file
            </param>
        </member>
        <member name="M:IniParser.Model.IniData.Clone">
            <summary>
                Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
                A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="M:IniParser.Model.IniData.ClearAllComments">
            <summary>
                Deletes all comments in all sections and key values
            </summary>
        </member>
        <member name="M:IniParser.Model.IniData.Merge(IniParser.Model.IniData)">
            <summary>
                Merges the other iniData into this one by overwriting existing values.
                Comments get appended.
            </summary>
            <param name="toMergeIniData">
                IniData instance to merge into this. 
                If it is null this operation does nothing.
            </param>
        </member>
        <member name="M:IniParser.Model.IniData.TryGetKey(System.String,System.String@)">
             <summary>
                 Attempts to retrieve a key, using a single string combining section and 
                 key name.
             </summary>
             <param name="key">
                 The section and key name to retrieve, separated by <see cref="!:IniParserConfiguration.SectionKeySeparator" />.
            
                 If key contains no separator, it is treated as a key in the <see cref="P:IniParser.Model.IniData.Global" /> section.
            
                 Key may contain no more than one separator character.
             </param>
             <param name="value">
                 If true is returned, is set to the value retrieved.  Otherwise, is set
                 to an empty string.
             </param>
             <returns>
                 True if key was found, otherwise false.
             </returns>
             <exception cref="T:System.ArgumentException">
                 key contained multiple separators.
             </exception>
        </member>
        <member name="M:IniParser.Model.IniData.GetKey(System.String)">
             <summary>
                 Retrieves a key using a single input string combining section and key name.
             </summary>
             <param name="key">
                 The section and key name to retrieve, separated by <see cref="!:IniParserConfiguration.SectionKeySeparator" />.
            
                 If key contains no separator, it is treated as a key in the <see cref="P:IniParser.Model.IniData.Global" /> section.
            
                 Key may contain no more than one separator character.
             </param>
             <returns>
                 The key's value if it was found, otherwise null.
             </returns>
             <exception cref="T:System.ArgumentException">
                 key contained multiple separators.
             </exception>
        </member>
        <member name="M:IniParser.Model.IniData.MergeSection(IniParser.Model.SectionData)">
            <summary>
                Merge the sections into this by overwriting this sections.
            </summary>
        </member>
        <member name="M:IniParser.Model.IniData.MergeGlobal(IniParser.Model.KeyDataCollection)">
            <summary>
                Merges the given global values into this globals by overwriting existing values.
            </summary>
        </member>
        <member name="T:IniParser.Model.IniDataCaseInsensitive">
            <summary>
                Represents all data from an INI file exactly as the <see cref="T:IniParser.Model.IniData" />
                class, but searching for sections and keys names is done with
                a case insensitive search.
            </summary>
        </member>
        <member name="M:IniParser.Model.IniDataCaseInsensitive.#ctor">
            <summary>
                Initializes an empty IniData instance.
            </summary>
        </member>
        <member name="M:IniParser.Model.IniDataCaseInsensitive.#ctor(IniParser.Model.SectionDataCollection)">
            <summary>
                Initializes a new IniData instance using a previous
                <see cref="T:IniParser.Model.SectionDataCollection" />.
            </summary>
            <param name="sdc">
                <see cref="T:IniParser.Model.SectionDataCollection" /> object containing the
                data with the sections of the file
            </param>
        </member>
        <member name="M:IniParser.Model.IniDataCaseInsensitive.#ctor(IniParser.Model.IniData)">
            <summary>
            Copies an instance of the <see cref="T:IniParser.Model.IniDataCaseInsensitive" /> class
            </summary>
            <param name="ori">Original </param>
        </member>
        <member name="T:IniParser.Model.KeyData">
            <summary>
                Information associated to a key from an INI file.
                Includes both the value and the comments associated to the key.
            </summary>
        </member>
        <member name="P:IniParser.Model.KeyData.Comments">
            <summary>
            Gets or sets the comment list associated to this key.
            </summary>
        </member>
        <member name="P:IniParser.Model.KeyData.Value">
            <summary>
                Gets or sets the value associated to this key.
            </summary>
        </member>
        <member name="P:IniParser.Model.KeyData.KeyName">
            <summary>
                Gets or sets the name of the key.
            </summary>
        </member>
        <member name="M:IniParser.Model.KeyData.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.KeyData" /> class.
            </summary>
        </member>
        <member name="M:IniParser.Model.KeyData.#ctor(IniParser.Model.KeyData)">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.KeyData" /> class
                from a previous instance of <see cref="T:IniParser.Model.KeyData" />.
            </summary>
            <remarks>
                Data is deeply copied
            </remarks>
            <param name="ori">
                The instance of the <see cref="T:IniParser.Model.KeyData" /> class 
                used to create the new instance.
            </param>
        </member>
        <member name="M:IniParser.Model.KeyData.Clone">
            <summary>
                Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
                A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:IniParser.Model.KeyDataCollection">
            <summary>
                Represents a collection of Keydata.
            </summary>
        </member>
        <member name="F:IniParser.Model.KeyDataCollection._keyData">
            <summary>
            Collection of KeyData for a given section
            </summary>
        </member>
        <member name="P:IniParser.Model.KeyDataCollection.Item(System.String)">
            <summary>
                Gets or sets the value of a concrete key.
            </summary>
            <remarks>
                If we try to assign the value of a key which doesn't exists,
                a new key is added with the name and the value is assigned to it.
            </remarks>
            <param name="keyName">
                Name of the key
            </param>
            <returns>
                The string with key's value or null if the key was not found.
            </returns>
        </member>
        <member name="P:IniParser.Model.KeyDataCollection.Count">
            <summary>
                Return the number of keys in the collection
            </summary>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.KeyDataCollection" /> class.
            </summary>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.#ctor(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.KeyDataCollection" /> class with a given
                search comparer
            </summary>
            <param name="searchComparer">
                Search comparer used to find the key by name in the collection
            </param>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.#ctor(IniParser.Model.KeyDataCollection,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.KeyDataCollection" /> class
                from a previous instance of <see cref="T:IniParser.Model.KeyDataCollection" />.
            </summary>
            <remarks>
                Data from the original KeyDataCollection instance is deeply copied
            </remarks>
            <param name="ori">
                The instance of the <see cref="T:IniParser.Model.KeyDataCollection" /> class 
                used to create the new instance.
            </param>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.AddKey(IniParser.Model.KeyData)">
            <summary>
                Adds a new key to the collection
            </summary>
            <param name="keyData">
                KeyData instance.
            </param>
            <returns>
                <c>true</c> if the key was added  <c>false</c> if a key with the same name already exist 
                in the collection
            </returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.AddKey(System.String,System.String)">
            <summary>
                Adds a new key with the specified name and value to the collection
            </summary>
            <param name="keyName">
                Name of the new key to be added.
            </param>
            <param name="keyValue">
                Value associated to the key.
            </param>
            <returns>
                <c>true</c> if the key was added  <c>false</c> if a key with the same name already exist 
                in the collection.
            </returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.ClearComments">
            <summary>
                Clears all comments of this section
            </summary>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.ContainsKey(System.String)">
            <summary>
            Gets if a specifyed key name exists in the collection.
            </summary>
            <param name="keyName">Key name to search</param>
            <returns><c>true</c> if a key with the specified name exists in the collectoin
            <c>false</c> otherwise</returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.GetKeyData(System.String)">
            <summary>
            Retrieves the data for a specified key given its name
            </summary>
            <param name="keyName">Name of the key to retrieve.</param>
            <returns>
            A <see cref="T:IniParser.Model.KeyData" /> instance holding
            the key information or <c>null</c> if the key wasn't found.
            </returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.RemoveAllKeys">
            <summary>
            	Deletes all keys in this collection.
            </summary>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.RemoveKey(System.String)">
            <summary>
            Deletes a previously existing key, including its associated data.
            </summary>
            <param name="keyName">The key to be removed.</param>
            <returns>
            <c>true</c> if a key with the specified name was removed 
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.SetKeyData(IniParser.Model.KeyData)">
            <summary>
            Sets the key data associated to a specified key.
            </summary>
            <param name="data">The new <see cref="T:IniParser.Model.KeyData" /> for the key.</param>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.GetEnumerator">
            <summary>
            Allows iteration througt the collection.
            </summary>
            <returns>A strong-typed IEnumerator </returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementation needed
            </summary>
            <returns>A weak-typed IEnumerator.</returns>
        </member>
        <member name="M:IniParser.Model.KeyDataCollection.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:IniParser.Model.SectionData">
            <summary>
                Information associated to a section in a INI File
                Includes both the value and the comments associated to the key.
            </summary>
        </member>
        <member name="P:IniParser.Model.SectionData.SectionName">
            <summary>
                Gets or sets the name of the section.
            </summary>
            <value>
                The name of the section
            </value>
        </member>
        <member name="P:IniParser.Model.SectionData.Comments">
            <summary>
                Gets or sets the comment list associated to this section.
            </summary>
            <value>
                A list of strings.
            </value>
        </member>
        <member name="P:IniParser.Model.SectionData.Keys">
            <summary>
                Gets or sets the keys associated to this section.
            </summary>
            <value>
                A collection of KeyData objects.
            </value>
        </member>
        <member name="M:IniParser.Model.SectionData.#ctor(System.String,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.SectionData" /> class.
            </summary>
        </member>
        <member name="M:IniParser.Model.SectionData.#ctor(IniParser.Model.SectionData,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
                Initializes a new instance of the <see cref="T:IniParser.Model.SectionData" /> class
                from a previous instance of <see cref="T:IniParser.Model.SectionData" />.
            </summary>
            <remarks>
                Data is deeply copied
            </remarks>
            <param name="ori">
                The instance of the <see cref="T:IniParser.Model.SectionData" /> class 
                used to create the new instance.
            </param>
            <param name="searchComparer">
                Search comparer.
            </param>
        </member>
        <member name="M:IniParser.Model.SectionData.ClearComments">
            <summary>
                Deletes all comments in this section and key/value pairs
            </summary>
        </member>
        <member name="M:IniParser.Model.SectionData.ClearKeyData">
            <summary>
            Deletes all the key-value pairs in this section.
            </summary>
        </member>
        <member name="M:IniParser.Model.SectionData.Merge(IniParser.Model.SectionData)">
            <summary>
                Merges otherSection into this, adding new keys if they don't exists
                or overwriting values if the key already exists.
            Comments get appended.
            </summary>
            <remarks>
                Comments are also merged but they are always added, not overwritten.
            </remarks>
            <param name="toMergeSection"></param>
        </member>
        <member name="M:IniParser.Model.SectionData.Clone">
            <summary>
                Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
                A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:IniParser.Model.SectionDataCollection">
            <summary>
            <para>Represents a collection of SectionData.</para>
            </summary>
        </member>
        <member name="F:IniParser.Model.SectionDataCollection._sectionData">
            <summary>
            Data associated to this section
            </summary>
        </member>
        <member name="P:IniParser.Model.SectionDataCollection.Count">
            <summary>
            Returns the number of SectionData elements in the collection
            </summary>
        </member>
        <member name="P:IniParser.Model.SectionDataCollection.Item(System.String)">
            <summary>
            Gets the key data associated to a specified section name.
            </summary>
            <value>An instance of as <see cref="T:IniParser.Model.KeyDataCollection" /> class 
            holding the key data from the current parsed INI data, or a <c>null</c>
            value if the section doesn't exist.</value>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:IniParser.Model.SectionDataCollection" /> class.
            </summary>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.#ctor(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:IniParser.Model.SectionDataCollection" /> class.
            </summary>
            <param name="searchComparer">
                StringComparer used when accessing section names
            </param>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.#ctor(IniParser.Model.SectionDataCollection,System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:IniParser.Model.SectionDataCollection" /> class
            from a previous instance of <see cref="T:IniParser.Model.SectionDataCollection" />.
            </summary>
            <remarks>
            Data is deeply copied
            </remarks>
            <param name="ori">
            The instance of the <see cref="T:IniParser.Model.SectionDataCollection" /> class 
            used to create the new instance.</param>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.AddSection(System.String)">
            <summary>
            Creates a new section with empty data.
            </summary>
            <remarks>
            <para>If a section with the same name exists, this operation has no effect.</para>
            </remarks>
            <param name="keyName">Name of the section to be created</param>
            <return><c>true</c> if the a new section with the specified name was added,
            <c>false</c> otherwise</return>
            <exception cref="T:System.ArgumentException">If the section name is not valid.</exception>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.Add(IniParser.Model.SectionData)">
            <summary>
                Adds a new SectionData instance to the collection
            </summary>
            <param name="data">Data.</param>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.Clear">
            <summary>
            Removes all entries from this collection
            </summary>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.ContainsSection(System.String)">
            <summary>
            Gets if a section with a specified name exists in the collection.
            </summary>
            <param name="keyName">Name of the section to search</param>
            <returns>
            <c>true</c> if a section with the specified name exists in the
             collection <c>false</c> otherwise
            </returns>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.GetSectionData(System.String)">
            <summary>
            Returns the section data from a specify section given its name.
            </summary>
            <param name="sectionName">Name of the section.</param>
            <returns>
            An instance of a <see cref="T:IniParser.Model.SectionData" /> class 
            holding the section data for the currently INI data
            </returns>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.SetSectionData(System.String,IniParser.Model.SectionData)">
            <summary>
            Sets the section data for given a section name.
            </summary>
            <param name="sectionName"></param>
            <param name="data">The new <see cref="T:IniParser.Model.SectionData" />instance.</param>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.RemoveSection(System.String)">
             <summary>
            
             </summary>
             <param name="keyName"></param>
             <return><c>true</c> if the section with the specified name was removed, 
             <c>false</c> otherwise</return>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:IniParser.Model.SectionDataCollection.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="T:IniParser.Parser.IniDataParser">
            <summary>
            	Responsible for parsing an string from an ini file, and creating
            	an <see cref="T:IniParser.Model.IniData" /> structure.
            </summary>
        </member>
        <member name="F:IniParser.Parser.IniDataParser._currentCommentListTemp">
            <summary>
                Temp list of comments
            </summary>
        </member>
        <member name="F:IniParser.Parser.IniDataParser._currentSectionNameTemp">
            <summary>
                Tmp var with the name of the seccion which is being process
            </summary>
        </member>
        <member name="P:IniParser.Parser.IniDataParser.Configuration">
            <summary>
                Configuration that defines the behaviour and constraints
                that the parser must follow.
            </summary>
        </member>
        <member name="P:IniParser.Parser.IniDataParser.HasError">
            <summary>
            True is the parsing operation encounter any problem
            </summary>
        </member>
        <member name="P:IniParser.Parser.IniDataParser.Errors">
            <summary>
            Returns the list of errors found while parsing the ini file.
            </summary>
            <remarks>
            If the configuration option ThrowExceptionOnError is false it can contain one element
            for each problem found while parsing; otherwise it will only contain the very same 
            exception that was raised.
            </remarks>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.#ctor">
            <summary>
                Ctor
            </summary>
            <remarks>
                The parser uses a <see cref="T:IniParser.Model.Configuration.IniParserConfiguration" /> by default
            </remarks>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.#ctor(IniParser.Model.Configuration.IniParserConfiguration)">
            <summary>
                Ctor
            </summary>
            <param name="parserConfiguration">
                Parser's <see cref="T:IniParser.Model.Configuration.IniParserConfiguration" /> instance.
            </param>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.Parse(System.String)">
            <summary>
                Parses a string containing valid ini data
            </summary>
            <param name="iniDataString">
                String with data
            </param>
            <returns>
                An <see cref="T:IniParser.Model.IniData" /> instance with the data contained in
                the <paramref name="iniDataString" /> correctly parsed an structured.
            </returns>
            <exception cref="T:IniParser.Exceptions.ParsingException">
                Thrown if the data could not be parsed
            </exception>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.LineContainsAComment(System.String)">
            <summary>
                Checks if a given string contains a comment.
            </summary>
            <param name="line">
                String with a line to be checked.
            </param>
            <returns>
                <c>true</c> if any substring from s is a comment, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.LineMatchesASection(System.String)">
            <summary>
                Checks if a given string represents a section delimiter.
            </summary>
            <param name="line">
                The string to be checked.
            </param>
            <returns>
                <c>true</c> if the string represents a section, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.LineMatchesAKeyValuePair(System.String)">
            <summary>
                Checks if a given string represents a key / value pair.
            </summary>
            <param name="line">
                The string to be checked.
            </param>
            <returns>
                <c>true</c> if the string represents a key / value pair, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.ExtractComment(System.String)">
            <summary>
                Removes a comment from a string if exist, and returns the string without
                the comment substring.
            </summary>
            <param name="line">
                The string we want to remove the comments from.
            </param>
            <returns>
                The string s without comments.
            </returns>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.ProcessLine(System.String,IniParser.Model.IniData)">
            <summary>
                Processes one line and parses the data found in that line
                (section or key/value pair who may or may not have comments)
            </summary>
            <param name="currentLine">The string with the line to process</param>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.ProcessSection(System.String,IniParser.Model.IniData)">
            <summary>
                Proccess a string which contains an ini section.
            </summary>
            <param name="line">
                The string to be processed
            </param>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.ProcessKeyValuePair(System.String,IniParser.Model.IniData)">
            <summary>
                Processes a string containing an ini key/value pair.
            </summary>
            <param name="line">
                The string to be processed
            </param>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.ExtractKey(System.String)">
            <summary>
                Extracts the key portion of a string containing a key/value pair..
            </summary>
            <param name="s">    
                The string to be processed, which contains a key/value pair
            </param>
            <returns>
                The name of the extracted key.
            </returns>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.ExtractValue(System.String)">
            <summary>
                Extracts the value portion of a string containing a key/value pair..
            </summary>
            <param name="s">
                The string to be processed, which contains a key/value pair
            </param>
            <returns>
                The name of the extracted value.
            </returns>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.HandleDuplicatedKeyInCollection(System.String,System.String,IniParser.Model.KeyDataCollection,System.String)">
            <summary>
                Abstract Method that decides what to do in case we are trying to add a duplicated key to a section
            </summary>
        </member>
        <member name="M:IniParser.Parser.IniDataParser.AddKeyToKeyValueCollection(System.String,System.String,IniParser.Model.KeyDataCollection,System.String)">
            <summary>
                Adds a key to a concrete <see cref="T:IniParser.Model.KeyDataCollection" /> instance, checking
                if duplicate keys are allowed in the configuration
            </summary>
            <param name="key">
                Key name
            </param>
            <param name="value">
                Key's value
            </param>
            <param name="keyDataCollection">
                <see cref="T:IniParser.Model.KeyData" /> collection where the key should be inserted
            </param>
            <param name="sectionName">
                Name of the section where the <see cref="T:IniParser.Model.KeyDataCollection" /> is contained. 
                Used only for logging purposes.
            </param>
        </member>
        <member name="T:IniParser.StreamIniDataParser">
            <summary>
                Represents an INI data parser for streams.
            </summary>
        </member>
        <member name="P:IniParser.StreamIniDataParser.Parser">
            <summary>
                This instance will handle ini data parsing and writing
            </summary>
        </member>
        <member name="M:IniParser.StreamIniDataParser.#ctor">
            <summary>
                Ctor
            </summary>
        </member>
        <member name="M:IniParser.StreamIniDataParser.#ctor(IniParser.Parser.IniDataParser)">
            <summary>
                Ctor
            </summary>
            <param name="parser"></param>
        </member>
        <member name="M:IniParser.StreamIniDataParser.ReadData(System.IO.StreamReader)">
            <summary>
                Reads data in INI format from a stream.
            </summary>
            <param name="reader">Reader stream.</param>
            <returns>
                And <see cref="T:IniParser.Model.IniData" /> instance with the readed ini data parsed.
            </returns>
            <exception cref="T:System.ArgumentNullException">
                Thrown if <paramref name="reader" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:IniParser.StreamIniDataParser.WriteData(System.IO.StreamWriter,IniParser.Model.IniData)">
            <summary>
                Writes the ini data to a stream.
            </summary>
            <param name="writer">A write stream where the ini data will be stored</param>
            <param name="iniData">An <see cref="T:IniParser.Model.IniData" /> instance.</param>
            <exception cref="T:System.ArgumentNullException">
                Thrown if <paramref name="writer" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:IniParser.StreamIniDataParser.WriteData(System.IO.StreamWriter,IniParser.Model.IniData,IniParser.Model.Formatting.IIniDataFormatter)">
            <summary>
                Writes the ini data to a stream.
            </summary>
            <param name="writer">A write stream where the ini data will be stored</param>
            <param name="iniData">An <see cref="T:IniParser.Model.IniData" /> instance.</param>
            <param name="formatter">Formaterr instance that controls how the ini data is transformed to a string</param>
            <exception cref="T:System.ArgumentNullException">
                Thrown if <paramref name="writer" /> is <c>null</c>.
            </exception>
        </member>
        <member name="T:IniParser.StringIniParser">
             <summary>
                 Represents an INI data parser for strings.
            
             </summary>
             <remarks>
                 This class is deprecated and kept for backwards compatibility.
                 It's just a wrapper around <see cref="T:IniParser.Parser.IniDataParser" /> class.
                 Please, replace your code.
             </remarks>
        </member>
        <member name="P:IniParser.StringIniParser.Parser">
            <summary>
                This instance will handle ini data parsing and writing
            </summary>
        </member>
        <member name="M:IniParser.StringIniParser.#ctor">
            <summary>
                Ctor
            </summary>
        </member>
        <member name="M:IniParser.StringIniParser.#ctor(IniParser.Parser.IniDataParser)">
            <summary>
                Ctor
            </summary>
            <param name="parser"></param>
        </member>
        <member name="M:IniParser.StringIniParser.ParseString(System.String)">
            <summary>
            Parses a string containing data formatted as an INI file.
            </summary>
            <param name="dataStr">The string containing the data.</param>
            <returns>
            A new <see cref="T:IniParser.Model.IniData" /> instance with the data parsed from the string.
            </returns>
        </member>
        <member name="M:IniParser.StringIniParser.WriteString(IniParser.Model.IniData)">
            <summary>
            Creates a string from the INI data.
            </summary>
            <param name="iniData">An <see cref="T:IniParser.Model.IniData" /> instance.</param>
            <returns>
            A formatted string with the contents of the
            <see cref="T:IniParser.Model.IniData" /> instance object.
            </returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ExportUtil.GetMysqlDDL(System.Object,System.String)">
            <summary>
            根据类型生成mysql建表语句,默认有自增id和时间戳
            </summary>
            <param name="data"></param>
            <param name="tablename"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ExportUtil.GetCS(XCode.DataAccessLayer.IDataTable,System.String)">
            <summary>
            根据 IDataTable 生成实体模型 DAL.Tables
            </summary>
            <param name="dt"></param>
            <param name="defaultdb"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ExportUtil.SaveAllCS(System.Collections.Generic.IList{XCode.DataAccessLayer.IDataTable},System.String,System.String)">
            <summary>
            根据 IDataTable 保存实体类 DAL.Tables
            </summary>
            <param name="dts">生成的表</param>
            <param name="path">存储路径</param>
            <param name="defaultdb">默认db连接名称</param>
        </member>
        <member name="T:XCode.DataAccessLayer.DatabaseType">
            <summary>数据库类型</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.None">
            <summary>无效值</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.Access">
            <summary>MS的Access文件数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.SqlServer">
            <summary>MS的SqlServer数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.Oracle">
            <summary>Oracle数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.MySql">
            <summary>MySql数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.SqlCe">
            <summary>SqlCe数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.SQLite">
            <summary>SQLite数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.PostgreSQL">
            <summary>SqlCe数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DatabaseType.DaMeng">
            <summary>达梦数据库</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.DbBase">
            <summary>数据库基类</summary>
            <remarks>
            数据库类的职责是抽象不同数据库的共同点，理应最小化，保证原汁原味，因此不做缓存等实现。
            对于每一个连接字符串配置，都有一个数据库实例，而不是每个数据库类型一个实例，因为同类型数据库不同版本行为不同。
            </remarks>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.Dispose(System.Boolean)">
            <summary>销毁资源时，回滚未提交事务，并关闭数据库连接</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.ReleaseSession">
            <summary>释放所有会话</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.Type">
            <summary>返回数据库类型。外部DAL数据库类请使用Other</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.Factory">
            <summary>工厂</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.ConnectionString">
            <summary>链接字符串</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.OnSetConnectionString(XCode.DataAccessLayer.ConnectionStringBuilder)">
            <summary>设置连接字符串时允许从中取值或修改，基类用于读取拥有者Owner，子类重写时应调用基类</summary>
            <param name="builder"></param>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.Owner">
            <summary>拥有者</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.DatabaseName">
            <summary>数据库名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.ServerVersion">
            <summary>数据库服务器版本</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.Migration">
            <summary>反向工程。Off 关闭；ReadOnly 只读不执行；On 打开，新建；Full 完全，修改删除</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.TraceSQLTime">
            <summary>跟踪SQL执行时间，大于该阀值将输出日志</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.Readonly">
            <summary>本连接数据只读</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.RetryOnFailure">
            <summary>失败重试。执行命令超时后的重试次数，默认0不重试</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.DataCache">
            <summary>数据层缓存有效期。单位秒</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.TablePrefix">
            <summary>表前缀。所有在该连接上的表名都自动增加该前缀</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.NameFormat">
            <summary>反向工程表名、字段名大小写设置</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.BatchSize">
            <summary>批大小。用于批量操作数据，默认5000</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DbBase._store">
            <summary>保证数据库在每一个线程都有唯一的一个实例</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CreateSession">
            <summary>创建数据库会话，数据库在每一个线程都有唯一的一个实例</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="F:XCode.DataAccessLayer.DbBase._metadata">
            <summary>唯一实例</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CreateMetaData">
            <summary>创建元数据对象，唯一实例</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.OpenConnection">
            <summary>创建连接</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.Support(System.String)">
            <summary>是否支持该提供者所描述的数据库</summary>
            <param name="providerName">提供者</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.GetProviderFactory(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>获取提供者工厂</summary>
            <param name="assemblyFile"></param>
            <param name="className"></param>
            <param name="strict"></param>
            <param name="ignoreError"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>构造分页SQL，优先选择max/min，然后选择not in</summary>
            <remarks>
            两个构造分页SQL的方法，区别就在于查询生成器能够构造出来更好的分页语句，尽可能的避免子查询。
            MS体系的分页精髓就在于唯一键，当唯一键带有Asc/Desc/Unkown等排序结尾时，就采用最大最小值分页，否则使用较次的TopNotIn分页。
            TopNotIn分页和MaxMin分页的弊端就在于无法完美的支持GroupBy查询分页，只能查到第一页，往后分页就不行了，因为没有主键。
            </remarks>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">唯一键。用于not in分页</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.PageSplitMaxMin(System.String,System.Int64,System.Int64,System.String)">
            <summary>按唯一数字最大最小分析</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">唯一键。用于not in分页</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CheckSimpleSQL(System.String)">
            <summary>检查简单SQL语句，比如Select * From table</summary>
            <param name="sql">待检查SQL语句</param>
            <returns>如果是简单SQL语句则返回表名，否则返回子查询(sql) XCode_Temp_a</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CheckOrderClause(System.String@)">
            <summary>检查是否以Order子句结尾，如果是，分割sql为前后两部分</summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <remarks>
            两个构造分页SQL的方法，区别就在于查询生成器能够构造出来更好的分页语句，尽可能的避免子查询。
            MS体系的分页精髓就在于唯一键，当唯一键带有Asc/Desc/Unkown等排序结尾时，就采用最大最小值分页，否则使用较次的TopNotIn分页。
            TopNotIn分页和MaxMin分页的弊端就在于无法完美的支持GroupBy查询分页，只能查到第一页，往后分页就不行了，因为没有主键。
            </remarks>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.LongTextLength">
            <summary>长文本长度</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.ReservedWordsStr">
            <summary>
            保留字字符串，其实可以在首次使用时动态从Schema中加载
            </summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.ReservedWords">
            <summary>
            保留字
            </summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.IsReservedWord(System.String)">
            <summary>是否保留字</summary>
            <param name="word"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatDateTime(System.DateTime)">
            <summary>格式化时间为SQL字符串</summary>
            <remarks>
            优化DateTime转为全字符串，平均耗时从25.76ns降为15.07。
            调用非常频繁，每分钟都有数百万次调用。
            </remarks>
            <param name="dateTime">时间值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">表名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatName(System.String)">
            <summary>格式化名称，如果是关键字，则格式化后返回，否则原样返回</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatName(XCode.DataAccessLayer.IDataTable)">
            <summary>格式化表名，考虑表前缀和Owner</summary>
            <param name="table">表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatName(XCode.DataAccessLayer.IDataColumn)">
            <summary>格式化字段名，考虑大小写</summary>
            <param name="column">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.ChangeUnderline(System.String)">
            <summary>把驼峰命名转为下划线</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatValue(XCode.DataAccessLayer.IDataColumn,System.Object)">
            <summary>格式化数据为SQL数据</summary>
            <param name="column">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.FormatParameterName(System.String)">
            <summary>格式化参数名</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CreateParameter(System.String,System.Object,XCode.DataAccessLayer.IDataColumn)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CreateParameter(System.String,System.Object,System.Type)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CreateParameters(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>创建参数数组</summary>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.CreateParameters(System.Object)">
            <summary>根据对象成员创建参数数组</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.AutoClose">
            <summary>获取 或 设置 自动关闭。每次使用完数据库连接后，是否自动关闭连接，高频操作时设为false可提升性能。默认true</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.SupportSchema">
            <summary>是否支持Schema。默认true</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbBase.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.ShowSQL">
            <summary>是否输出SQL语句，默认为XCode调试开关XCode.Debug</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.SQLMaxLength">
            <summary>SQL最大长度，输出日志时的SQL最大长度，超长截断，默认4096，不截断用0</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbBase.UseParameter">
            <summary>参数化添删改查。默认关闭</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.DbFactory">
            <summary>数据库工厂</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbFactory.Register``1(XCode.DataAccessLayer.DatabaseType)">
            <summary>注册数据库提供者</summary>
            <typeparam name="T"></typeparam>
            <param name="dbType"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbFactory.Create(XCode.DataAccessLayer.DatabaseType)">
            <summary>根据数据库类型创建提供者</summary>
            <param name="dbType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbFactory.GetDefault(System.Type)">
            <summary>根据名称获取默认提供者</summary>
            <param name="dbType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbFactory.GetProviderType(System.String,System.String)">
            <summary>从提供者和连接字符串猜测数据库处理器</summary>
            <param name="connStr"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.DbSession">
            <summary>数据库会话基类</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Dispose(System.Boolean)">
            <summary>销毁资源时，回滚未提交事务，并关闭数据库连接</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:XCode.DataAccessLayer.DbSession.Database">
            <summary>数据库</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbSession.QueryTimes">
            <summary>查询次数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbSession.ExecuteTimes">
            <summary>执行次数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbSession.ThreadID">
            <summary>线程编号，每个数据库会话应该只属于一个线程，该属性用于检查错误的跨线程操作</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.OnException(System.Exception)">
            <summary>当异常发生时触发。关闭数据库连接，或者返还连接到连接池。</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.OnException(System.Exception,System.Data.Common.DbCommand,System.String)">
            <summary>当异常发生时触发。关闭数据库连接，或者返还连接到连接池。</summary>
            <param name="ex"></param>
            <param name="cmd"></param>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Process``1(System.Func{System.Data.Common.DbConnection,``0})">
            <summary>打开连接并执行操作</summary>
            <typeparam name="TResult"></typeparam>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.ShouldRetryOn(System.Exception)">
            <summary>是否应该在该异常上重试</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DbSession.Transaction">
            <summary>数据库事务</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.BeginTransaction(System.Data.IsolationLevel)">
            <summary>开始事务</summary>
            <remarks>
            Read Uncommitted: 允许读取脏数据，一个事务能看到另一个事务还没有提交的数据。（不会阻止其它操作）
            Read Committed: 确保事务读取的数据都必须是已经提交的数据。它限制了读取中间的，没有提交的，脏的数据。
            但是它不能确保当事务重新去读取的时候，读的数据跟上次读的数据是一样的，也就是说当事务第一次读取完数据后，
            该数据是可能被其他事务修改的，当它再去读取的时候，数据可能是不一样的。（数据隐藏，不阻止）
            Repeatable Read: 是一个更高级别的隔离级别，如果事务再去读取同样的数据，先前的数据是没有被修改过的。（阻止其它修改）
            Serializable: 它做出了最有力的保证，除了每次读取的数据是一样的，它还确保每次读取没有新的数据。（阻止其它添删改）
            </remarks>
            <param name="level">事务隔离等级</param>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Commit">
            <summary>提交事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Rollback(System.Boolean)">
            <summary>回滚事务</summary>
            <param name="ignoreException">是否忽略异常</param>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Query(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Query(System.Data.Common.DbCommand)">
            <summary>执行DbCommand，返回记录集</summary>
            <param name="cmd">DbCommand</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Query(System.String,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.QueryCount(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回总记录数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.QueryCount(XCode.DataAccessLayer.SelectBuilder)">
            <summary>执行SQL查询，返回总记录数</summary>
            <param name="builder">查询生成器</param>
            <returns>总记录数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.QueryCountFast(System.String)">
            <summary>快速查询单表记录数，稍有偏差</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Execute(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL语句，返回受影响的行数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Execute(System.Data.Common.DbCommand)">
            <summary>执行DbCommand，返回受影响的行数</summary>
            <param name="cmd">DbCommand</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.ExecuteScalar``1(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL语句，返回结果中的第一行第一列</summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.CreateCommand(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>获取一个DbCommand。</summary>
            <remark>
            配置了连接，并关联了事务。
            连接已打开。
            使用完毕后，必须调用AutoClose方法，以使得在非事务及设置了自动关闭的情况下关闭连接
            </remark>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.OnCreateCommand(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>获取一个DbCommand。</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Insert(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.IEnumerable{NewLife.Data.IExtend})">
            <summary>批量插入</summary>
            <param name="table">数据表</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Update(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},System.Collections.Generic.IEnumerable{NewLife.Data.IExtend})">
            <summary>批量更新</summary>
            <param name="table">数据表</param>
            <param name="columns">要更新的字段，默认所有字段</param>
            <param name="updateColumns">要更新的字段，默认脏数据</param>
            <param name="addColumns">要累加更新的字段，默认累加</param>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Upsert(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},System.Collections.Generic.IEnumerable{NewLife.Data.IExtend})">
            <summary>批量插入或更新</summary>
            <param name="table">数据表</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="updateColumns">主键已存在时，要更新的字段</param>
            <param name="addColumns">主键已存在时，要累加更新的字段</param>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.Truncate(System.String)">
            <summary>清空数据表，标识归零</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.GetSchema(System.Data.Common.DbConnection,System.String,System.String[])">
            <summary>返回数据源的架构信息。缓存10分钟</summary>
            <param name="conn">连接</param>
            <param name="collectionName">指定要返回的架构的名称。</param>
            <param name="restrictionValues">为请求的架构指定一组限制值。</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DbSession.ShowSQL">
            <summary>是否输出SQL语句，默认为XCode调试开关XCode.Debug</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.WriteSQL(System.String)">
            <summary>写入SQL到文本中</summary>
            <param name="sql"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbSession.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:XCode.DataAccessLayer.FileDbBase">
            <summary>文件型数据库</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.FileDbSession">
            <summary>文件型数据库会话</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.FileDbSession.FileName">
            <summary>文件</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.FileDbSession.Truncate(System.String)">
            <summary>清空数据表，标识归零</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.FileDbMetaData">
            <summary>文件型数据库元数据</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.FileDbMetaData.FileName">
            <summary>文件</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.FileDbMetaData.SetSchema(XCode.DataAccessLayer.DDLSchema,System.Object[])">
            <summary>设置数据定义模式</summary>
            <param name="schema"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.FileDbMetaData.CreateDatabase">
            <summary>创建数据库</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.Migration">
            <summary>反向工程</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.Migration.Off">
            <summary>关闭</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.Migration.ReadOnly">
            <summary>只读。异步检查差异，不执行</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.Migration.On">
            <summary>默认。新建表结构</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.Migration.Full">
            <summary>完全。新建、修改、删除</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.NameFormats">
            <summary>名称格式化</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.NameFormats.Default">
            <summary>原样</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.NameFormats.Upper">
            <summary>全大写</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.NameFormats.Lower">
            <summary>全小写</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.NameFormats.Underline">
            <summary>下划线</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.IDatabase">
            <summary>数据库接口</summary>
            <remarks>
            抽象数据库的功能特点。
            对于每一个连接字符串配置，都有一个数据库实例，而不是每个数据库类型一个实例，因为同类型数据库不同版本行为不同。
            </remarks>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.Type">
            <summary>数据库类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.Factory">
            <summary>数据库提供者工厂</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.ConnName">
            <summary>链接名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.ConnectionString">
            <summary>链接字符串</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.Owner">
            <summary>拥有者</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.DatabaseName">
            <summary>数据库名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.ServerVersion">
            <summary>数据库服务器版本</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.ShowSQL">
            <summary>是否输出SQL</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.UseParameter">
            <summary>参数化添删改查。默认关闭</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.RetryOnFailure">
            <summary>失败重试。执行命令超时后的重试次数，默认0不重试</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.Migration">
            <summary>反向工程。Off 关闭；ReadOnly 只读不执行；On 打开，新建；Full 完全，修改删除</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.NameFormat">
            <summary>表名、字段名大小写设置。（No 保持原样输出、Upper 全大写、Lower全小写）</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.CreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.CreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.OpenConnection">
            <summary>创建连接</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.Support(System.String)">
            <summary>是否支持该提供者所描述的数据库</summary>
            <param name="providerName">提供者</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>构造分页SQL</summary>
            <remarks>
            两个构造分页SQL的方法，区别就在于查询生成器能够构造出来更好的分页语句，尽可能的避免子查询。
            MS体系的分页精髓就在于唯一键，当唯一键带有Asc/Desc/Unkown等排序结尾时，就采用最大最小值分页，否则使用较次的TopNotIn分页。
            TopNotIn分页和MaxMin分页的弊端就在于无法完美的支持GroupBy查询分页，只能查到第一页，往后分页就不行了，因为没有主键。
            </remarks>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">唯一键。用于not in分页</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <remarks>
            两个构造分页SQL的方法，区别就在于查询生成器能够构造出来更好的分页语句，尽可能的避免子查询。
            MS体系的分页精髓就在于唯一键，当唯一键带有Asc/Desc/Unkown等排序结尾时，就采用最大最小值分页，否则使用较次的TopNotIn分页。
            TopNotIn分页和MaxMin分页的弊端就在于无法完美的支持GroupBy查询分页，只能查到第一页，往后分页就不行了，因为没有主键。
            </remarks>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.LongTextLength">
            <summary>长文本长度</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.FormatDateTime(System.DateTime)">
            <summary>格式化时间为SQL字符串</summary>
            <param name="dateTime">时间值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.FormatName(System.String)">
            <summary>格式化名称，如果不是关键字，则原样返回</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.FormatName(XCode.DataAccessLayer.IDataTable)">
            <summary>格式化表名，考虑表前缀和Owner</summary>
            <param name="table">表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.FormatName(XCode.DataAccessLayer.IDataColumn)">
            <summary>格式化字段名，考虑大小写</summary>
            <param name="column">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.FormatValue(XCode.DataAccessLayer.IDataColumn,System.Object)">
            <summary>格式化数据为SQL数据</summary>
            <param name="column">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.FormatParameterName(System.String)">
            <summary>格式化参数名</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.CreateParameter(System.String,System.Object,XCode.DataAccessLayer.IDataColumn)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.CreateParameter(System.String,System.Object,System.Type)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.CreateParameters(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>创建参数数组</summary>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDatabase.CreateParameters(System.Object)">
            <summary>根据对象成员创建参数数组</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.AutoClose">
            <summary>获取 或 设置 自动关闭。每次使用完数据库连接后，是否自动关闭连接，高频操作时设为false可提升性能。默认true</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.Readonly">
            <summary>本连接数据只读</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.DataCache">
            <summary>数据层缓存有效期。单位秒</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDatabase.TablePrefix">
            <summary>表前缀。所有在该连接上的表名都自动增加该前缀</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.IDbSession">
            <summary>
            数据库会话接口。
            对应于与数据库的一次会话连接。
            </summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDbSession.Database">
            <summary>数据库</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDbSession.Transaction">
            <summary>数据库事务</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDbSession.QueryTimes">
            <summary>查询次数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDbSession.ExecuteTimes">
            <summary>执行次数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDbSession.ShowSQL">
            <summary>是否输出SQL</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Process``1(System.Func{System.Data.Common.DbConnection,``0})">
            <summary>打开连接并执行操作</summary>
            <typeparam name="TResult"></typeparam>
            <param name="callback"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.BeginTransaction(System.Data.IsolationLevel)">
            <summary>开始事务</summary>
            <remarks>
            Read Uncommitted: 允许读取脏数据，一个事务能看到另一个事务还没有提交的数据。（不会阻止其它操作）
            Read Committed: 确保事务读取的数据都必须是已经提交的数据。它限制了读取中间的，没有提交的，脏的数据。
            但是它不能确保当事务重新去读取的时候，读的数据跟上次读的数据是一样的，也就是说当事务第一次读取完数据后，
            该数据是可能被其他事务修改的，当它再去读取的时候，数据可能是不一样的。（数据隐藏，不阻止）
            Repeatable Read: 是一个更高级别的隔离级别，如果事务再去读取同样的数据，先前的数据是没有被修改过的。（阻止其它修改）
            Serializable: 它做出了最有力的保证，除了每次读取的数据是一样的，它还确保每次读取没有新的数据。（阻止其它添删改）
            </remarks>
            <param name="level">事务隔离等级</param>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Commit">
            <summary>提交事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Rollback(System.Boolean)">
            <summary>回滚事务</summary>
            <param name="ignoreException">是否忽略异常</param>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Query(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>记录集</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Query(System.Data.Common.DbCommand)">
            <summary>执行DbCommand，返回记录集</summary>
            <param name="cmd">DbCommand</param>
            <returns>记录集</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Query(System.String,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.QueryCount(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回总记录数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>总记录数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.QueryCount(XCode.DataAccessLayer.SelectBuilder)">
            <summary>执行SQL查询，返回总记录数</summary>
            <param name="builder">查询生成器</param>
            <returns>总记录数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.QueryCountFast(System.String)">
            <summary>快速查询单表记录数，稍有偏差</summary>
            <param name="tableName">表名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Execute(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL语句，返回受影响的行数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Execute(System.Data.Common.DbCommand)">
            <summary>执行DbCommand，返回受影响的行数</summary>
            <param name="cmd">DbCommand</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.ExecuteScalar``1(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL语句，返回结果中的第一行第一列</summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.CreateCommand(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>创建DbCommand</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Insert(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.IEnumerable{NewLife.Data.IExtend})">
            <summary>批量插入</summary>
            <param name="table">数据表</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Update(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},System.Collections.Generic.IEnumerable{NewLife.Data.IExtend})">
            <summary>批量更新</summary>
            <param name="table">数据表</param>
            <param name="columns">要更新的字段，默认所有字段</param>
            <param name="updateColumns">要更新的字段，默认脏数据</param>
            <param name="addColumns">要累加更新的字段，默认累加</param>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Upsert(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},System.Collections.Generic.IEnumerable{NewLife.Data.IExtend})">
            <summary>批量插入或更新</summary>
            <param name="table">数据表</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="updateColumns">主键已存在时，要更新的字段</param>
            <param name="addColumns">主键已存在时，要累加更新的字段</param>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.Truncate(System.String)">
            <summary>清空数据表，标识归零</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDbSession.GetSchema(System.Data.Common.DbConnection,System.String,System.String[])">
            <summary>返回数据源的架构信息</summary>
            <param name="conn">连接</param>
            <param name="collectionName">指定要返回的架构的名称。</param>
            <param name="restrictionValues">为请求的架构指定一组限制值。</param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.ITransaction">
            <summary>事务对象</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ITransaction.Level">
            <summary>事务隔离级别</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ITransaction.Count">
            <summary>事务计数。当且仅当事务计数等于1时，才提交或回滚。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ITransaction.Executes">
            <summary>执行次数。其决定是否更新缓存</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ITransaction.Tran">
            <summary>数据库事务</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.ITransaction.Check(System.Data.Common.DbCommand,System.Boolean)">
            <summary>获取事务</summary>
            <param name="cmd">命令</param>
            <param name="execute">是否执行增删改</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ITransaction.Begin">
            <summary>增加事务计数</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ITransaction.Commit">
            <summary>提交事务</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ITransaction.Rollback">
            <summary>回滚事务</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.Transaction.Count">
            <summary>事务嵌套层数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.Transaction.Executes">
            <summary>执行次数。其决定是否更新缓存</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.Transaction.ID">
            <summary>事务唯一编号</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.Transaction.Conn">
            <summary>连接对象</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.Transaction.Tran">
            <summary>数据库事务。首次使用打开事务</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.Transaction.Check(System.Data.Common.DbCommand,System.Boolean)">
            <summary>给命令设置事务和连接</summary>
            <param name="cmd">命令</param>
            <param name="execute">是否执行增删改</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.Transaction.Log">
            <summary>日志</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.RemoteDb">
            <summary>远程数据库。一般是分为客户端服务器的中大型数据库，该类数据库支持完整的SQL92</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.RemoteDb.SystemDatabaseName">
            <summary>系统数据库名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.RemoteDb.User">
            <summary>用户名UserID</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.RemoteDbSession">
            <summary>远程数据库会话</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.RemoteDbSession.SystemDatabaseName">
            <summary>系统数据库名</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.RemoteDbMetaData">
            <summary>远程数据库元数据</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.DAL">
            <summary>数据访问层</summary>
            <remarks>
            主要用于选择不同的数据库，不同的数据库的操作有所差别。
            每一个数据库链接字符串，对应唯一的一个DAL实例。
            数据库链接字符串可以写在配置文件中，然后在Create时指定名字；
            也可以直接把链接字符串作为AddConnStr的参数传入。
            </remarks>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.ProviderType">
            <summary>实现了IDatabase接口的数据库类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.DbType">
            <summary>数据库类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.ConnStr">
            <summary>连接字符串</summary>
            <remarks>
            修改连接字符串将会清空<see cref="P:XCode.DataAccessLayer.DAL.Db"/>
            </remarks>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Db">
            <summary>数据库。所有数据库操作在此统一管理，强烈建议不要直接使用该属性，在不同版本中IDatabase可能有较大改变</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Session">
            <summary>数据库会话</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.#ctor(System.String)">
            <summary>构造函数</summary>
            <param name="connName">配置名</param>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Create(System.String)">
            <summary>创建一个数据访问层对象。</summary>
            <param name="connName">配置名</param>
            <returns>对应于指定链接的全局唯一的数据访问层对象</returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.ConnStrs">
            <summary>链接字符串集合</summary>
            <remarks>
            如果需要修改一个DAL的连接字符串，不应该修改这里，而是修改DAL实例的<see cref="P:XCode.DataAccessLayer.DAL.ConnStr"/>属性
            </remarks>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.AddConnStr(System.String,System.String,System.Type,System.String)">
            <summary>添加连接字符串</summary>
            <param name="connName">连接名</param>
            <param name="connStr">连接字符串</param>
            <param name="type">实现了IDatabase接口的数据库类型</param>
            <param name="provider">数据库提供者，如果没有指定数据库类型，则有提供者判断使用哪一种内置类型</param>
        </member>
        <member name="E:XCode.DataAccessLayer.DAL.OnResolve">
            <summary>找不到连接名时调用。支持用户自定义默认连接</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.GetConfig">
            <summary>获取连接字符串的委托。可以二次包装在连接名前后加上标识，存放在配置中心</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.GetFromConfigCenter(System.String)">
            <summary>从配置中心加载连接字符串，并支持定时刷新</summary>
            <param name="connName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.EncodeConnStr(System.String)">
            <summary>连接字符串编码</summary>
            <remarks>明文=>UTF8字节=>Base64</remarks>
            <param name="connstr"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.DecodeConnStr(System.String)">
            <summary>连接字符串解码</summary>
            <remarks>Base64=>UTF8字节=>明文</remarks>
            <param name="connstr"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Tables">
            <summary>取得所有表和视图的构架信息（异步缓存延迟1秒）。设为null可清除缓存</summary>
            <remarks>
            如果不存在缓存，则获取后返回；否则使用线程池线程获取，而主线程返回缓存。
            </remarks>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.GetTables(System.String[])">
            <summary>
            获取所有表架构信息，不传则获取全部表
            </summary>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Export">
            <summary>导出模型</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Export(System.Collections.Generic.IEnumerable{XCode.DataAccessLayer.IDataTable})">
            <summary>导出模型</summary>
            <param name="tables"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Import(System.String)">
            <summary>导入模型</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.ImportFrom(System.String)">
            <summary>导入模型文件</summary>
            <param name="xmlFile"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.CheckDatabase">
            <summary>使用数据库之前检查表架构</summary>
            <remarks>不阻塞，可能第一个线程正在检查表架构，别的线程已经开始使用数据库了</remarks>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.CheckAndAdd(System.String)">
            <summary>检查是否已存在，如果不存在则添加</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.CheckTables">
            <summary>检查数据表架构，不受反向工程启用开关限制，仅检查未经过常规检查的表</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.SetTables(XCode.DataAccessLayer.IDataTable[])">
            <summary>在当前连接上检查指定数据表的架构</summary>
            <param name="tables"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Backup(XCode.DataAccessLayer.IDataTable,System.IO.Stream,System.Action{System.Int64,NewLife.Data.DbTable})">
            <summary>备份单表数据</summary>
            <remarks>
            最大支持21亿行
            </remarks>
            <param name="table">数据表</param>
            <param name="stream">目标数据流</param>
            <param name="progress">进度回调，参数为已处理行数和当前页表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Backup(XCode.DataAccessLayer.IDataTable,System.String)">
            <summary>备份单表数据到文件</summary>
            <param name="table">数据表</param>
            <param name="file">文件。.gz后缀时采用压缩</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.BackupAll(System.Collections.Generic.IList{XCode.DataAccessLayer.IDataTable},System.String,System.Boolean)">
            <summary>备份一批表到指定压缩文件</summary>
            <param name="tables">数据表集合</param>
            <param name="file">zip压缩文件</param>
            <param name="backupSchema">备份架构</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Restore(System.IO.Stream,XCode.DataAccessLayer.IDataTable,System.Action{System.Int32,NewLife.Data.DbTable})">
            <summary>从数据流恢复数据</summary>
            <param name="stream">数据流</param>
            <param name="table">数据表</param>
            <param name="progress">进度回调，参数为已处理行数和当前页表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Restore(System.String,XCode.DataAccessLayer.IDataTable)">
            <summary>从文件恢复数据</summary>
            <param name="file"></param>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.RestoreAll(System.String,XCode.DataAccessLayer.IDataTable[])">
            <summary>从指定压缩文件恢复一批数据到目标库</summary>
            <param name="file">zip压缩文件</param>
            <param name="tables"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Sync(XCode.DataAccessLayer.IDataTable,System.String,System.Boolean,System.Action{System.Int32,NewLife.Data.DbTable})">
            <summary>同步单表数据</summary>
            <remarks>
            把数据同一张表同步到另一个库
            </remarks>
            <param name="table">数据表</param>
            <param name="connName">目标连接名</param>
            <param name="syncSchema">同步架构</param>
            <param name="progress">进度回调，参数为已处理行数和当前页表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.SyncAll(XCode.DataAccessLayer.IDataTable[],System.String,System.Boolean)">
            <summary>备份一批表到另一个库</summary>
            <param name="tables">表名集合</param>
            <param name="connName">目标连接名</param>
            <param name="syncSchema">同步架构</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.QueryTimes">
            <summary>查询次数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.ExecuteTimes">
            <summary>执行次数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.ReadOnly">
            <summary>只读实例。读写分离时，读取操作分走</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Strategy">
            <summary>读写分离策略。忽略时间区间和表名</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>根据条件把普通查询SQL格式化为分页SQL。</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Select(System.String)">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Select(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="builder">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Query(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="builder">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Query(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.SelectCount(XCode.DataAccessLayer.SelectBuilder)">
            <summary>执行SQL查询，返回总记录数</summary>
            <param name="sb">查询生成器</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.SelectCount(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回总记录数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Execute(System.String)">
            <summary>执行SQL语句，返回受影响的行数</summary>
            <param name="sql">SQL语句</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.InsertAndGetIdentity(System.String)">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql"></param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Select(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Execute(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行SQL语句，返回受影响的行数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql"></param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Select(System.String,System.Data.CommandType,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Execute(System.String,System.Data.CommandType,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行SQL语句，返回受影响的行数</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.ExecuteScalar``1(System.String,System.Data.CommandType,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行SQL语句，返回结果中的第一行第一列</summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.BeginTransaction(System.Data.IsolationLevel)">
            <summary>开始事务</summary>
            <remarks>
            Read Uncommitted: 允许读取脏数据，一个事务能看到另一个事务还没有提交的数据。（不会阻止其它操作）
            Read Committed: 确保事务读取的数据都必须是已经提交的数据。它限制了读取中间的，没有提交的，脏的数据。
            但是它不能确保当事务重新去读取的时候，读的数据跟上次读的数据是一样的，也就是说当事务第一次读取完数据后，
            该数据是可能被其他事务修改的，当它再去读取的时候，数据可能是不一样的。（数据隐藏，不阻止）
            Repeatable Read: 是一个更高级别的隔离级别，如果事务再去读取同样的数据，先前的数据是没有被修改过的。（阻止其它修改）
            Serializable: 它做出了最有力的保证，除了每次读取的数据是一样的，它还确保每次读取没有新的数据。（阻止其它添删改）
            </remarks>
            <param name="level">事务隔离等级</param>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Commit">
            <summary>提交事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Rollback">
            <summary>回滚事务，忽略异常</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Store">
            <summary>缓存存储</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Expire">
            <summary>数据层缓存。默认10秒</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.GetTables(System.String)">
            <summary>从Sql语句中截取表名</summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Query``1(System.String,System.Object)">
            <summary>查询Sql并映射为结果集</summary>
            <typeparam name="T">实体类</typeparam>
            <param name="sql">Sql语句</param>
            <param name="param">参数对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Execute(System.String,System.Object)">
            <summary>执行Sql</summary>
            <param name="sql">Sql语句</param>
            <param name="param">参数对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.ExecuteReader(System.String,System.Object)">
            <summary>执行Sql并返回数据读取器</summary>
            <param name="sql"></param>
            <param name="param"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.ExecuteScalar``1(System.String,System.Object)">
            <summary>执行SQL语句，返回结果中的第一行第一列</summary>
            <typeparam name="T">返回类型</typeparam>
            <param name="sql">SQL语句</param>
            <param name="param">参数对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Insert(System.String,System.Object)">
            <summary>插入数据</summary>
            <param name="tableName"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Update(System.String,System.Object,System.Object)">
            <summary>更新数据</summary>
            <param name="tableName"></param>
            <param name="data"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.Delete(System.String,System.Object)">
            <summary>删除数据</summary>
            <param name="tableName"></param>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.WriteDebugLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.LocalFilter">
            <summary>本地过滤器（本线程SQL拦截）</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.Tracer">
            <summary>APM跟踪器</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.GlobalTracer">
            <summary>全局APM跟踪器</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DAL.CreateTable">
            <summary>建立数据表对象</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DAL.SupportBatch">
            <summary>是否支持批操作</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.DaMeng.Type">
            <summary>返回数据库类型。外部DAL数据库类请使用Other</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DaMeng.Factory">
            <summary>工厂</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>已重写。获取分页</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">主键列。用于not in分页</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.PageSplitByLimit(System.String,System.Int64,System.Int64)">
            <summary>已重写。获取分页</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.PageSplitByLimit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.CreateParameter(System.String,System.Object,System.Type)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMeng.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">表名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.DaMengSession">
            <summary>DaMeng数据库</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMengSession.QueryCountFast(System.String)">
            <summary>快速查询单表记录数，稍有偏差</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMengSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMengSession.OnCreateCommand(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>重载支持批量操作</summary>
            <param name="sql"></param>
            <param name="type"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.DaMengMeta">
            <summary>DaMeng元数据</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DaMengMeta.Owner">
            <summary>拥有者</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DaMengMeta.UserID">
            <summary>用户名</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMengMeta.OnGetTables(System.String[])">
            <summary>取得所有表构架</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DaMengMeta.GetFields(XCode.DataAccessLayer.IDataTable,System.Data.DataTable,System.Collections.Generic.IDictionary{System.String,System.Data.DataTable})">
            <summary>取得指定表的所有列构架</summary>
            <param name="table"></param>
            <param name="columns">列</param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="F:XCode.DataAccessLayer.DaMengMeta._DataTypes">
            <summary>数据类型映射</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.MySql.Type">
            <summary>返回数据库类型。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.MySql.Factory">
            <summary>工厂</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>已重写。获取分页</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">主键列。用于not in分页</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.PageSplitByLimit(System.String,System.Int64,System.Int64)">
            <summary>已重写。获取分页</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.PageSplitByLimit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">关键字</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.FormatValue(XCode.DataAccessLayer.IDataColumn,System.Object)">
            <summary>格式化数据为SQL数据</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.MySql.LongTextLength">
            <summary>长文本长度</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.CreateParameter(System.String,System.Object,System.Type)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.MySql.SystemDatabaseName">
            <summary>系统数据库名</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.MySql.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.MySql.EnumTables">
            <summary>采用枚举来表示布尔型的数据表。由正向工程赋值</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.MySqlSession">
            <summary>MySql数据库</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.MySqlSession.QueryCountFast(System.String)">
            <summary>快速查询单表记录数，大数据量时，稍有偏差。</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MySqlSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="T:XCode.DataAccessLayer.MySqlMetaData">
            <summary>MySql元数据</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.MySqlMetaData._DataTypes">
            <summary>数据类型映射</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.Oracle.Type">
            <summary>返回数据库类型。外部DAL数据库类请使用Other</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.Oracle.Factory">
            <summary>工厂</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>已重写。获取分页 2012.9.26 HUIYUE修正分页BUG</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">主键列。用于not in分页</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <remarks>
            两个构造分页SQL的方法，区别就在于查询生成器能够构造出来更好的分页语句，尽可能的避免子查询。
            MS体系的分页精髓就在于唯一键，当唯一键带有Asc/Desc/Unkown等排序结尾时，就采用最大最小值分页，否则使用较次的TopNotIn分页。
            TopNotIn分页和MaxMin分页的弊端就在于无法完美的支持GroupBy查询分页，只能查到第一页，往后分页就不行了，因为没有主键。
            </remarks>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.FormatDateTime(System.DateTime)">
            <summary>已重载。格式化时间</summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.CreateParameter(System.String,System.Object,System.Type)">
            <summary>创建参数</summary>
            <param name="name">名称</param>
            <param name="value">值</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.Oracle.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">表名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.OracleSession">
            <summary>Oracle数据库</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.OracleSession.QueryCountFast(System.String)">
            <summary>快速查询单表记录数，稍有偏差</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.OracleSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.OracleSession.OnCreateCommand(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>重载支持批量操作</summary>
            <param name="sql"></param>
            <param name="type"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.OracleMeta">
            <summary>Oracle元数据</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.OracleMeta.Owner">
            <summary>拥有者</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.OracleMeta.UserID">
            <summary>用户名</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.OracleMeta.OnGetTables(System.String[])">
            <summary>取得所有表构架</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.OracleMeta.GetFields(XCode.DataAccessLayer.IDataTable,System.Data.DataTable,System.Collections.Generic.IDictionary{System.String,System.Data.DataTable})">
            <summary>取得指定表的所有列构架</summary>
            <param name="table"></param>
            <param name="columns">列</param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="F:XCode.DataAccessLayer.OracleMeta._DataTypes">
            <summary>数据类型映射</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.OracleMeta.GetDefault(XCode.DataAccessLayer.IDataColumn,System.Boolean)">
            <summary>默认值</summary>
            <param name="field"></param>
            <param name="onlyDefine"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.PostgreSQL.Type">
            <summary>返回数据库类型。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.PostgreSQL.Factory">
            <summary>工厂</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>已重写。获取分页</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">主键列。用于not in分页</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">关键字</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.FormatValue(XCode.DataAccessLayer.IDataColumn,System.Object)">
            <summary>格式化数据为SQL数据</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.PostgreSQL.LongTextLength">
            <summary>长文本长度</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.PostgreSQL.SystemDatabaseName">
            <summary>系统数据库名</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQL.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.PostgreSQLSession">
            <summary>PostgreSQL数据库</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.PostgreSQLSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="T:XCode.DataAccessLayer.PostgreSQLMetaData">
            <summary>PostgreSQL元数据</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.PostgreSQLMetaData._DataTypes">
            <summary>数据类型映射</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SQLite.Type">
            <summary>返回数据库类型。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SQLite.Factory">
            <summary>工厂</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SQLite.IsMemoryDatabase">
            <summary>是否内存数据库</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SQLite.AutoVacuum">
            <summary>自动收缩数据库</summary>
            <remarks>
            当一个事务从数据库中删除了数据并提交后，数据库文件的大小保持不变。
            即使整页的数据都被删除，该页也会变成“空闲页”等待再次被使用，而不会实际地被从数据库文件中删除。
            执行vacuum操作，可以通过重建数据库文件来清除数据库内所有的未用空间，使数据库文件变小。
            但是，如果一个数据库在创建时被指定为auto_vacuum数据库，当删除事务提交时，数据库文件会自动缩小。
            使用auto_vacuum数据库可以节省空间，但却会增加数据库操作的时间。
            </remarks>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLite.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLite.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLite.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>已重写。获取分页</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">主键列。用于not in分页</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLite.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>构造分页SQL</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLite.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">关键字</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLite.StringConcat(System.String,System.String)">
            <summary>字符串相加</summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.SQLiteSession">
            <summary>SQLite数据库</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteSession.Truncate(System.String)">
            <summary>清空数据表，标识归零</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.SQLiteMetaData">
            <summary>SQLite元数据</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.SQLiteMetaData._DataTypes">
            <summary>数据类型映射</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteMetaData.GetTbFields(XCode.DataAccessLayer.IDataTable)">
            <summary>
            获取表字段 zhangy 2018年10月23日 15:30:43
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteMetaData.Backup(System.String,System.String,System.Boolean)">
            <summary>备份文件到目标文件</summary>
            <param name="dbname"></param>
            <param name="bakfile"></param>
            <param name="compressed"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteMetaData.DropIndexSQL(XCode.DataAccessLayer.IDataIndex)">
            <summary>删除索引方法</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteMetaData.AddTableDescriptionSQL(XCode.DataAccessLayer.IDataTable)">
            <summary>添加描述</summary>
            <remarks>返回Empty，告诉反向工程，该数据库类型不支持该功能，请不要输出日志</remarks>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SQLiteMetaData.CheckTable(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.Migration)">
            <summary>已重载。因为内存数据库无法检测到架构，不知道表是否已存在，所以需要自己维护</summary>
            <param name="entitytable"></param>
            <param name="dbtable"></param>
            <param name="mode"></param>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.Type">
            <summary>返回数据库类型。外部DAL数据库类请使用Other</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.Factory">
            <summary>工厂</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.IsSQL2012">
            <summary>是否SQL2012及以上</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.Version">
            <summary>是否SQL2005及以上</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.DataPath">
            <summary>数据目录</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.OnCreateSession">
            <summary>创建数据库会话</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.OnCreateMetaData">
            <summary>创建元数据对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.PageSplit(System.String,System.Int64,System.Int64,System.String)">
            <summary>构造分页SQL</summary>
            <param name="sql">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <param name="keyColumn">唯一键。用于not in分页</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.FormatSqlserver2012SQL(System.String)">
            <summary>
            格式化SQL SERVER 2012分页前半部分SQL语句
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.LongTextLength">
            <summary>长文本长度</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.FormatDateTime(System.DateTime)">
            <summary>格式化时间为SQL字符串</summary>
            <param name="dateTime">时间值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.FormatName(System.String)">
            <summary>格式化名称，如果是关键字，则格式化后返回，否则原样返回</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServer.FormatKeyWord(System.String)">
            <summary>格式化关键字</summary>
            <param name="keyWord">关键字</param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServer.SystemDatabaseName">
            <summary>系统数据库名</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.SqlServerSession">
            <summary>SqlServer数据库</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.QueryCountFast(System.String)">
            <summary>快速查询单表记录数，稍有偏差</summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="T:XCode.DataAccessLayer.SqlServerSession.SqlBatcher">
            <summary>
            批量操作帮助类
            </summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServerSession.SqlBatcher.IsStarted">
            <summary>获得批处理是否正在批处理状态。</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.SqlBatcher.StartBatch(System.Data.Common.DbConnection)">
            <summary>开始批处理</summary>
            <param name="connection">连接。</param>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.SqlBatcher.AddToBatch(System.Data.IDbCommand)">
            <summary>
            添加批命令。
            </summary>
            <param name="command">命令</param>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.SqlBatcher.ExecuteBatch">
            <summary>
            执行批处理。
            </summary>
            <returns>影响的数据行数。</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.SqlBatcher.EndBatch">
            <summary>
            结束批处理。
            </summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerSession.SqlBatcher.ClearBatch">
            <summary>
            清空保存的批命令。
            </summary>
        </member>
        <member name="T:XCode.DataAccessLayer.SqlServerMetaData">
            <summary>SqlServer元数据</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerMetaData.OnGetTables(System.String[])">
            <summary>取得所有表构架</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.SqlServerMetaData.SchemaSql">
            <summary>构架SQL</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerMetaData.DatabaseExist(System.String)">
            <summary>使用数据架构确定数据库是否存在，因为使用系统视图可能没有权限</summary>
            <param name="dbname"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerMetaData.TableExist(XCode.DataAccessLayer.IDataTable)">
            <summary>使用数据架构确定数据表是否存在，因为使用系统视图可能没有权限</summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="F:XCode.DataAccessLayer.SqlServerMetaData._DataTypes">
            <summary>数据类型映射</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SqlServerMetaData.Trim(System.String,System.String,System.String)">
            <summary>除去字符串两端成对出现的符号</summary>
            <param name="str"></param>
            <param name="prefix"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.DbMetaData">
            <summary>数据库元数据</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbMetaData.Database">
            <summary>数据库</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbMetaData.MetaDataCollections">
            <summary>所有元数据集合</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbMetaData.ReservedWords">
            <summary>保留关键字</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetSchema(System.String,System.String[])">
            <summary>返回数据源的架构信息</summary>
            <param name="collectionName">指定要返回的架构的名称。</param>
            <param name="restrictionValues">为请求的架构指定一组限制值。</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.TryGetDataRowValue``1(System.Data.DataRow,System.String,``0@)">
            <summary>尝试从指定数据行中读取指定名称列的数据</summary>
            <typeparam name="T"></typeparam>
            <param name="dr"></param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetDataRowValue``1(System.Data.DataRow,System.String[])">
            <summary>获取指定数据行指定字段的值，不存在时返回空</summary>
            <typeparam name="T"></typeparam>
            <param name="dr"></param>
            <param name="names">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.WriteLog(System.String)">
            <summary>输出日志</summary>
            <param name="msg"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.SetTables(XCode.DataAccessLayer.Migration,XCode.DataAccessLayer.IDataTable[])">
            <summary>设置表模型，检查数据表是否匹配表模型，反向工程</summary>
            <param name="mode">设置</param>
            <param name="tables"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.CheckColumnsChange(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataTable,System.Boolean,System.Boolean)">
            <summary>检查字段改变。某些数据库（如SQLite）没有添删改字段的DDL语法，可重载该方法，使用重建表方法ReBuildTable</summary>
            <param name="entitytable"></param>
            <param name="dbtable"></param>
            <param name="onlySql"></param>
            <param name="noDelete"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.CheckTableDescriptionAndIndex(XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.IDataTable,XCode.DataAccessLayer.Migration)">
            <summary>检查表说明和索引</summary>
            <param name="entitytable"></param>
            <param name="dbtable"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.FormatDescription(System.String)">
            <summary>格式化注释，去除所有非单词字符</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.IsColumnChanged(XCode.DataAccessLayer.IDataColumn,XCode.DataAccessLayer.IDataColumn,XCode.DataAccessLayer.IDatabase)">
            <summary>检查字段是否有改变，除了默认值和备注以外</summary>
            <param name="entityColumn"></param>
            <param name="dbColumn"></param>
            <param name="entityDb"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.PerformSchema(System.Text.StringBuilder,System.Boolean,XCode.DataAccessLayer.DDLSchema,System.Object[])">
            <summary>
            获取架构语句，该执行的已经执行。
            如果取不到语句，则输出日志信息；
            如果不是纯语句，则执行；
            </summary>
            <param name="sb"></param>
            <param name="onlySql"></param>
            <param name="schema"></param>
            <param name="values"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetSchemaSQL(XCode.DataAccessLayer.DDLSchema,System.Object[])">
            <summary>获取数据定义语句</summary>
            <param name="schema">数据定义模式</param>
            <param name="values">其它信息</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.SetSchema(XCode.DataAccessLayer.DDLSchema,System.Object[])">
            <summary>设置数据定义模式</summary>
            <param name="schema">数据定义模式</param>
            <param name="values">其它信息</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.FieldClause(XCode.DataAccessLayer.IDataColumn,System.Boolean)">
            <summary>字段片段</summary>
            <param name="field">字段</param>
            <param name="onlyDefine">仅仅定义。定义操作才允许设置自增和使用默认值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetFieldConstraints(XCode.DataAccessLayer.IDataColumn,System.Boolean)">
            <summary>取得字段约束</summary>
            <param name="field">字段</param>
            <param name="onlyDefine">仅仅定义</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetDefault(XCode.DataAccessLayer.IDataColumn,System.Boolean)">
            <summary>默认值</summary>
            <param name="field"></param>
            <param name="onlyDefine"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetTables(System.String[])">
            <summary>取得所有表构架</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.OnGetTables(System.String[])">
            <summary>取得所有表构架</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetTables(System.Data.DataRow[],System.String[],System.Collections.Generic.IDictionary{System.String,System.Data.DataTable})">
            <summary>根据数据行取得数据表</summary>
            <param name="rows">数据行</param>
            <param name="names">指定表名</param>
            <param name="data">扩展</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.FixTable(XCode.DataAccessLayer.IDataTable,System.Data.DataRow,System.Collections.Generic.IDictionary{System.String,System.Data.DataTable})">
            <summary>修正表</summary>
            <param name="table"></param>
            <param name="dr"></param>
            <param name="data"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetFields(XCode.DataAccessLayer.IDataTable,System.Data.DataTable,System.Collections.Generic.IDictionary{System.String,System.Data.DataTable})">
            <summary>取得指定表的所有列构架</summary>
            <param name="table"></param>
            <param name="columns">列</param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetFields(XCode.DataAccessLayer.IDataTable,System.Data.DataRow[])">
            <summary>获取指定表的字段</summary>
            <param name="table"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.FixField(XCode.DataAccessLayer.IDataColumn,System.Data.DataRow)">
            <summary>修正指定字段</summary>
            <param name="field">字段</param>
            <param name="dr"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetIndexes(XCode.DataAccessLayer.IDataTable,System.Data.DataTable,System.Data.DataTable)">
            <summary>获取索引</summary>
            <param name="table"></param>
            <param name="indexes">索引</param>
            <param name="indexColumns">索引列</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.FixIndex(XCode.DataAccessLayer.IDataIndex,System.Data.DataRow)">
            <summary>修正索引</summary>
            <param name="index"></param>
            <param name="dr"></param>
        </member>
        <member name="P:XCode.DataAccessLayer.DbMetaData.Types">
            <summary>类型映射</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.DbMetaData.FieldTypeMaps">
            <summary>字段类型映射</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetFieldType(XCode.DataAccessLayer.IDataColumn)">
            <summary>取字段类型</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetDataType(XCode.DataAccessLayer.IDataColumn)">
            <summary>获取数据类型</summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.DbMetaData.GetDataType(System.String)">
            <summary>获取数据类型</summary>
            <param name="rawType"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.DDLSchema">
            <summary>数据定义模式</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.CreateDatabase">
            <summary>建立数据库</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.DatabaseExist">
            <summary>数据库是否存在</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.CreateTable">
            <summary>建立表</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.AddTableDescription">
            <summary>添加表说明</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.DropTableDescription">
            <summary>删除表说明</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.AddColumn">
            <summary>添加字段</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.AlterColumn">
            <summary>修改字段</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.DropColumn">
            <summary>删除字段</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.AddColumnDescription">
            <summary>添加字段说明</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.DropColumnDescription">
            <summary>删除字段说明</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.CreateIndex">
            <summary>建立索引</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.DDLSchema.DropIndex">
            <summary>删除索引</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.IMetaData">
            <summary>数据库元数据接口</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IMetaData.Database">
            <summary>数据库</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IMetaData.MetaDataCollections">
            <summary>所有元数据集合</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IMetaData.ReservedWords">
            <summary>保留关键字</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IMetaData.GetTables(System.String[])">
            <summary>取得表模型，正向工程</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IMetaData.SetTables(XCode.DataAccessLayer.Migration,XCode.DataAccessLayer.IDataTable[])">
            <summary>设置表模型，检查数据表是否匹配表模型，反向工程</summary>
            <param name="setting">设置</param>
            <param name="tables"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.IMetaData.GetSchemaSQL(XCode.DataAccessLayer.DDLSchema,System.Object[])">
            <summary>获取数据定义语句</summary>
            <param name="schema">数据定义模式</param>
            <param name="values">其它信息</param>
            <returns>数据定义语句</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IMetaData.SetSchema(XCode.DataAccessLayer.DDLSchema,System.Object[])">
            <summary>设置数据定义模式</summary>
            <param name="schema">数据定义模式</param>
            <param name="values">其它信息</param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.IDataColumn">
            <summary>数据列</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.ColumnName">
            <summary>列名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.DataType">
            <summary>数据类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.RawType">
            <summary>
            原始数据类型。
            当且仅当目标数据库同为该数据库类型时，采用实体属性信息上的RawType作为反向工程的目标字段类型，以期获得开发和生产的最佳兼容。
            </summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.ItemType">
            <summary>元素类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Identity">
            <summary>标识</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.PrimaryKey">
            <summary>主键</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Master">
            <summary>是否主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Length">
            <summary>长度</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Precision">
            <summary>精度</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Scale">
            <summary>位数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Nullable">
            <summary>允许空</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.DisplayName">
            <summary>显示名。如果有Description则使用Description，否则使用Name</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Description">
            <summary>说明</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Table">
            <summary>说明数据表</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataColumn.Properties">
            <summary>扩展属性</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataColumn.Fix">
            <summary>重新计算修正别名。避免与其它字段名或表名相同，避免关键字</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataColumn.Clone(XCode.DataAccessLayer.IDataTable)">
            <summary>克隆到指定的数据表</summary>
            <param name="table"></param>
        </member>
        <member name="T:XCode.DataAccessLayer.IDataIndex">
            <summary>
            数据索引。
            可根据索引生成查询方法，是否唯一决定该索引返回的是单个实体还是实体集合。
            正向工程将会为所有一对一索引建立关系。
            </summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataIndex.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataIndex.Columns">
            <summary>数据列集合</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataIndex.Unique">
            <summary>是否唯一</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataIndex.PrimaryKey">
            <summary>是否主键</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataIndex.Table">
            <summary>说明数据表</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataIndex.Fix">
            <summary>修正数据</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataIndex.Clone(XCode.DataAccessLayer.IDataTable)">
            <summary>克隆到指定的数据表</summary>
            <param name="table"></param>
        </member>
        <member name="T:XCode.DataAccessLayer.IDataTable">
            <summary>数据表</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.BaseType">
            <summary>基类</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Owner">
            <summary>所有者</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.DbType">
            <summary>
            数据库类型。
            仅用于记录实体类由何种类型数据库生成，当且仅当目标数据库同为该数据库类型时，采用实体属性信息上的RawType作为反向工程的目标字段类型，以期获得开发和生产的最佳兼容。
            </summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.IsView">
            <summary>是否视图</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.DisplayName">
            <summary>显示名。如果有Description则使用Description，否则使用Name</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Description">
            <summary>说明</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.InsertOnly">
            <summary>仅插入的日志型数据</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Columns">
            <summary>数据列集合。可以是空集合，但不能为null。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Indexes">
            <summary>数据索引集合。可以是空集合，但不能为null。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.PrimaryKeys">
            <summary>主键集合。可以是空集合，但不能为null。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Master">
            <summary>主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.IDataTable.Properties">
            <summary>扩展属性</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataTable.CreateColumn">
            <summary>创建数据列</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataTable.CreateIndex">
            <summary>创建数据索引</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IDataTable.Fix">
            <summary>修正数据</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.IModelResolver">
            <summary>模型解析器接口。解决名称大小写、去前缀、关键字等多个问题</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.IModelResolver.GetName(System.String)">
            <summary>获取别名。过滤特殊符号，过滤_之类的前缀。</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IModelResolver.GetName(XCode.DataAccessLayer.IDataIndex)">
            <summary>根据字段名等信息计算索引的名称</summary>
            <param name="di"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IModelResolver.GetDisplayName(System.String,System.String)">
            <summary>获取显示名，如果描述不存在，则使用名称，否则使用描述前面部分，句号（中英文皆可）、换行分隔</summary>
            <param name="name">名称</param>
            <param name="description"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.IModelResolver.Fix(XCode.DataAccessLayer.IDataTable)">
            <summary>修正数据</summary>
            <param name="table"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.IModelResolver.Fix(XCode.DataAccessLayer.IDataColumn)">
            <summary>修正数据列</summary>
            <param name="column"></param>
        </member>
        <member name="T:XCode.DataAccessLayer.ModelResolver">
            <summary>模型解析器。解决名称大小写、去前缀、关键字等多个问题</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ModelResolver.TrimUnderline">
            <summary>去掉下划线。默认true，下划线前后单词用驼峰命名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ModelResolver.Camel">
            <summary>使用驼峰命名。默认true</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.GetName(System.String)">
            <summary>获取别名。过滤特殊符号，过滤_之类的前缀。</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.GetName(XCode.DataAccessLayer.IDataIndex)">
            <summary>根据字段名等信息计算索引的名称</summary>
            <param name="di"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.GetDisplayName(System.String,System.String)">
            <summary>获取显示名，如果描述不存在，则使用名称，否则使用描述前面部分，句号（中英文皆可）、换行分隔</summary>
            <param name="name">名称</param>
            <param name="description"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.Fix(XCode.DataAccessLayer.IDataTable)">
            <summary>修正数据</summary>
            <param name="table"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.Fix(XCode.DataAccessLayer.IDataColumn)">
            <summary>修正数据列</summary>
            <param name="column"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.FixPrimaryByIndex(XCode.DataAccessLayer.IDataTable)">
            <summary>从索引中修正主键</summary>
            <param name="table"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.CreateUniqueIndexForIdentity(XCode.DataAccessLayer.IDataTable)">
            <summary>给非主键的自增字段建立唯一索引</summary>
            <param name="table"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelResolver.FixIndex(XCode.DataAccessLayer.IDataTable)">
            <summary>索引应该具有跟字段一样的唯一和主键约束</summary>
            <param name="table"></param>
        </member>
        <member name="P:XCode.DataAccessLayer.ModelResolver.Current">
            <summary>当前名称解析器</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.ModelHelper">
            <summary>数据模型扩展</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.GetColumn(XCode.DataAccessLayer.IDataTable,System.String)">
            <summary>根据字段名获取字段</summary>
            <param name="table"></param>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.GetColumns(XCode.DataAccessLayer.IDataTable,System.String[])">
            <summary>根据字段名数组获取字段数组</summary>
            <param name="table"></param>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.GetAllColumns(XCode.DataAccessLayer.IDataTable,System.Collections.Generic.IEnumerable{XCode.DataAccessLayer.IDataTable},System.Boolean)">
            <summary>获取全部字段，包括继承的父类</summary>
            <param name="table"></param>
            <param name="tables">在该表集合里面找父类</param>
            <param name="baseFirst">是否父类字段在前</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.Is(XCode.DataAccessLayer.IDataTable,System.String)">
            <summary>判断表是否等于指定名字</summary>
            <param name="table"></param>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.Is(XCode.DataAccessLayer.IDataColumn,System.String)">
            <summary>判断字段是否等于指定名字</summary>
            <param name="column"></param>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.GetIndex(XCode.DataAccessLayer.IDataTable,System.String[])">
            <summary>根据字段名找索引</summary>
            <param name="table"></param>
            <param name="columnNames"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.CamelName(XCode.DataAccessLayer.IDataColumn)">
            <summary>驼峰变量名</summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.ToXml(System.Collections.Generic.IEnumerable{XCode.DataAccessLayer.IDataTable},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>导出模型</summary>
            <param name="tables"></param>
            <param name="atts">附加属性</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.FromXml(System.String,System.Func{XCode.DataAccessLayer.IDataTable},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>导入模型</summary>
            <param name="xml"></param>
            <param name="createTable">用于创建<see cref="T:XCode.DataAccessLayer.IDataTable"/>实例的委托</param>
            <param name="atts">附加属性</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.ReadXml(XCode.DataAccessLayer.IDataTable,System.Xml.XmlReader)">
            <summary>读取</summary>
            <param name="table"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.WriteXml(XCode.DataAccessLayer.IDataTable,System.Xml.XmlWriter)">
            <summary>写入</summary>
            <param name="table"></param>
            <param name="writer"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.ReadXml(System.Xml.XmlReader,System.Object)">
            <summary>读取</summary>
            <param name="reader"></param>
            <param name="value">数值</param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.WriteXml(System.Xml.XmlWriter,System.Object,System.Boolean)">
            <summary>写入</summary>
            <param name="writer"></param>
            <param name="value">数值</param>
            <param name="writeDefaultValueMember">是否写数值为默认值的成员。为了节省空间，默认不写。</param>
        </member>
        <member name="M:XCode.DataAccessLayer.ModelHelper.FixDefaultByType(XCode.DataAccessLayer.IDataColumn,XCode.DataAccessLayer.IDataColumn)">
            <summary>根据类型修正字段的一些默认值</summary>
            <param name="dc"></param>
            <param name="oridc"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.SerializableDataMember">
            <summary>可序列化数据成员</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.XField">
            <summary>字段构架</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.ColumnName">
            <summary>列名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.DataType">
            <summary>数据类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.RawType">
            <summary>原始数据类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.ItemType">
            <summary>元素类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Identity">
            <summary>标识</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.PrimaryKey">
            <summary>主键</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Master">
            <summary>是否主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Length">
            <summary>长度</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Precision">
            <summary>精度</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Scale">
            <summary>位数</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Nullable">
            <summary>允许空</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Description">
            <summary>描述</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Table">
            <summary>表</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XField.Properties">
            <summary>扩展属性</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XField.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XField.Fix">
            <summary>重新计算修正别名。避免与其它字段名或表名相同，避免关键字</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XField.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XField.System#ICloneable#Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XField.Clone(XCode.DataAccessLayer.IDataTable)">
            <summary>克隆</summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.XIndex">
            <summary>索引</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XIndex.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XIndex.Columns">
            <summary>数据列集合</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XIndex.Unique">
            <summary>是否唯一</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XIndex.PrimaryKey">
            <summary>是否主键</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XIndex.Table">
            <summary>表</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XIndex.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XIndex.Fix">
            <summary>修正数据</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XIndex.System#ICloneable#Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XIndex.Clone(XCode.DataAccessLayer.IDataTable)">
            <summary>克隆</summary>
            <param name="table"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XIndex.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.XTable">
            <summary>表模型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Description">
            <summary>描述</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.IsView">
            <summary>是否视图</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Owner">
            <summary>所有者</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.DbType">
            <summary>数据库类型</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.BaseType">
            <summary>基类</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.InsertOnly">
            <summary>仅插入的日志型数据</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Columns">
            <summary>字段集合。可以是空集合，但不能为null。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Indexes">
            <summary>索引集合。可以是空集合，但不能为null。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Master">
            <summary>主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.PrimaryKeys">
            <summary>主键集合。可以是空集合，但不能为null。</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.XTable.Properties">
            <summary>扩展属性</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="name">名称</param>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.CreateColumn">
            <summary>创建字段</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.CreateIndex">
            <summary>创建索引</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.Fix">
            <summary>修正数据</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.Export">
            <summary>导出</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.Import(System.String)">
            <summary>导入</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.System#ICloneable#Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>获取架构</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>读取</summary>
            <param name="reader"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.XTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>写入</summary>
            <param name="writer"></param>
        </member>
        <member name="T:XCode.DataAccessLayer.MSPageSplit">
            <summary>MS系列数据库分页算法</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.MSPageSplit.PageSplit(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64,System.Boolean,System.Func{XCode.DataAccessLayer.SelectBuilder,System.Int64})">
            <summary>分页算法</summary>
            <remarks>
            builder里面必须含有排序，否则就要通过key指定主键，否则大部分算法不能使用，会导致逻辑数据排序不正确。
            其实，一般数据都是按照聚集索引排序，而聚集索引刚好也就是主键。
            所以，只要设置的Key顺序跟主键顺序一致，就没有问题。
            如果，Key指定了跟主键不一致的顺序，那么查询语句一定要指定同样的排序。
            </remarks>
            <param name="builder"></param>
            <param name="startRowIndex"></param>
            <param name="maximumRows"></param>
            <param name="isSql2005"></param>
            <param name="queryCountCallback">查询总记录数的委托，近供DoubleTop使用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MSPageSplit.TopNotIn(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>最经典的NotIn分页，通用但是效率最差。只需指定一个排序列。</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MSPageSplit.DoubleTop(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64,System.Func{XCode.DataAccessLayer.SelectBuilder,System.Int64})">
            <summary>双Top分页，因为没有使用not in，性能比NotIn要好。语句必须有排序，不需额外指定排序列</summary>
            <param name="builder"></param>
            <param name="startRowIndex"></param>
            <param name="maximumRows"></param>
            <param name="queryCountCallback">查询总记录数的委托，近供DoubleTop使用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MSPageSplit.MaxMin(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>按唯一数字最大最小分页，性能很好。必须指定一个数字型排序列。</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>分页SQL</returns>
        </member>
        <member name="M:XCode.DataAccessLayer.MSPageSplit.RowNumber(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>RowNumber分页算法</summary>
            <param name="builder">查询生成器</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.TimeRegion">
            <summary>时间区间</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.TimeRegion.Start">
            <summary>开始时间</summary>
        </member>
        <member name="F:XCode.DataAccessLayer.TimeRegion.End">
            <summary>结束时间</summary>
        </member>
        <member name="T:XCode.DataAccessLayer.ReadWriteStrategy">
            <summary>读写分离策略。忽略时间区间和表名</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ReadWriteStrategy.IgnoreTimes">
            <summary>要忽略的时间区间</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ReadWriteStrategy.IgnoreTables">
            <summary>要忽略的表名</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.ReadWriteStrategy.AddIgnoreTimes(System.String)">
            <summary>设置不走读写分离的时间段，如00:30-00:50，多段区间逗号分开</summary>
            <param name="regions"></param>
        </member>
        <member name="M:XCode.DataAccessLayer.ReadWriteStrategy.Validate(XCode.DataAccessLayer.DAL,System.String,System.String)">
            <summary>检查是否支持读写分离</summary>
            <param name="dal"></param>
            <param name="sql"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.SelectBuilder">
            <summary>SQL查询语句生成器</summary>
            <remarks>
            查询语句的复杂性，使得多个地方使用起来极为不方面。
            应该以本类作为查询对象，直接从最上层深入到最下层
            </remarks>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Key">
            <summary>分页主键</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Keys">
            <summary>分页主键组</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.IsDesc">
            <summary>是否降序</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.IsDescs">
            <summary>主键组是否降序</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.IsInt">
            <summary>是否整数自增主键</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.KeyOrder">
            <summary>分页主键排序</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.ReverseKeyOrder">
            <summary>分页主键反排序</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.KeyIsOrderBy">
            <summary>排序字段是否唯一且就是主键</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.#ctor">
            <summary>实例化一个SQL语句</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Column">
            <summary>选择列</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Where">
            <summary>条件</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.GroupBy">
            <summary>分组</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Having">
            <summary>分组条件</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.OrderBy">
            <summary>排序</summary>
            <remarks>给排序赋值时，如果没有指定分页主键，则自动采用排序中的字段</remarks>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Limit">
            <summary>分页用的Limit语句</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.ColumnOrDefault">
            <summary>选择列，为空时为*</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.ColumnNoAggregate">
            <summary>选择列，去除聚合，为空时为*</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Parameters">
            <summary>参数集合</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.Parse(System.String)">
            <summary>分析一条SQL</summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.DataAccessLayer.SelectBuilder.Store">
            <summary>缓存存储</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.Create(System.String)">
            <summary>根据SQL创建，带缓存</summary>
            <remarks>
            对于非常复杂的查询语句，正则平衡的处理器消耗很大
            </remarks>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.ToString">
            <summary>已重写。获取本Builder所分析的SQL语句</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.SelectCount">
            <summary>获取记录数的语句</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.AppendWhereAnd(System.String,System.Object[])">
            <summary>增加Where条件</summary>
            <param name="format"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.AppendColumn(System.String[])">
            <summary>增加多个字段，必须是当前表普通字段，如果内部是*则不加</summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.AsChild(System.String,System.Boolean)">
            <summary>作为子查询</summary>
            <param name="alias">别名，某些数据库可能需要使用as</param>
            <param name="trimOrder">SqlServer需要转移OrderBy到外层，Oracle则不能</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.CloneWithGroupBy(System.String,System.Boolean)">
            <summary>处理可能带GroupBy的克隆，如果带有GroupBy，则必须作为子查询，否则简单克隆即可</summary>
            <param name="alias">别名，某些数据库可能需要使用as</param>
            <param name="trimOrder">SqlServer需要转移OrderBy到外层，Oracle则不能</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.Split(System.String,System.Boolean[]@)">
            <summary>拆分排序字句</summary>
            <param name="orderby"></param>
            <param name="isdescs"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.Join(System.String[],System.Boolean[])">
            <summary>连接排序字句</summary>
            <param name="keys"></param>
            <param name="isdescs"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.SelectBuilder.op_Implicit(XCode.DataAccessLayer.SelectBuilder)~System.String">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.DataAccessLayer.ConnectionStringBuilder">
            <summary>连接字符串构造器</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ConnectionStringBuilder.Item(System.String)">
            <summary>获取 或 设置 设置项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ConnectionStringBuilder.#ctor(System.String)">
            <summary>实例化</summary>
        </member>
        <member name="P:XCode.DataAccessLayer.ConnectionStringBuilder.ConnectionString">
            <summary>连接字符串</summary>
        </member>
        <member name="M:XCode.DataAccessLayer.ConnectionStringBuilder.TryGetValue(System.String,System.String@)">
            <summary>获取连接字符串中的项</summary>
            <param name="key"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ConnectionStringBuilder.TryGetAndRemove(System.String,System.String@)">
            <summary>获取并删除连接字符串中的项</summary>
            <param name="key"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ConnectionStringBuilder.TryAdd(System.String,System.String)">
            <summary>尝试添加项，如果存在则失败</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DataAccessLayer.ConnectionStringBuilder.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.BindColumnAttribute">
            <summary>指定实体类属性所绑定数据字段信息。</summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.Name">
            <summary>字段名</summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.Description">
            <summary>描述</summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.RawType">
            <summary>
            原始数据类型。
            当且仅当目标数据库同为该数据库类型时，采用实体属性信息上的RawType作为反向工程的目标字段类型，以期获得开发和生产的最佳兼容。
            </summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.ItemType">
            <summary>元素类型</summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.Precision">
            <summary>精度</summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.Scale">
            <summary>位数</summary>
        </member>
        <member name="P:XCode.BindColumnAttribute.Master">
            <summary>是否主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="M:XCode.BindColumnAttribute.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="M:XCode.BindColumnAttribute.#ctor(System.String)">
            <summary>构造函数</summary>
            <param name="name">字段名</param>
        </member>
        <member name="M:XCode.BindColumnAttribute.#ctor(System.String,System.String,System.String)">
            <summary>构造函数</summary>
            <param name="name">名称</param>
            <param name="description"></param>
            <param name="rawType"></param>
        </member>
        <member name="M:XCode.BindColumnAttribute.GetCustomAttribute(System.Reflection.MemberInfo)">
            <summary>检索应用于类型成员的自定义属性。</summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.BindIndexAttribute">
            <summary>用于指定数据类所绑定到的索引</summary>
        </member>
        <member name="P:XCode.BindIndexAttribute.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.BindIndexAttribute.Unique">
            <summary>是否唯一</summary>
        </member>
        <member name="P:XCode.BindIndexAttribute.Columns">
            <summary>数据列集合</summary>
        </member>
        <member name="M:XCode.BindIndexAttribute.#ctor(System.String,System.Boolean,System.String)">
            <summary>指定一个索引</summary>
            <param name="name">名称</param>
            <param name="unique"></param>
            <param name="columns"></param>
        </member>
        <member name="M:XCode.BindIndexAttribute.Fill(XCode.DataAccessLayer.IDataIndex)">
            <summary>填充索引</summary>
            <param name="index"></param>
        </member>
        <member name="T:XCode.BindTableAttribute">
            <summary>指定实体类所绑定的数据表信息。</summary>
        </member>
        <member name="P:XCode.BindTableAttribute.Name">
            <summary>
            表名。
            可以在配置文件中通过XCode.ConnMaps把实体映射到别的数据表上
            </summary>
        </member>
        <member name="P:XCode.BindTableAttribute.Description">
            <summary>描述</summary>
        </member>
        <member name="P:XCode.BindTableAttribute.ConnName">
            <summary>
            连接名。
            实体类的所有数据库操作，将发生在该连接名指定的数据库连接上。
            此外，可动态修改实体类在当前线程上的连接名（改Meta.ConnName）；
            也可以在配置文件中通过XCode.ConnMaps把连接名映射到别的连接上。
            </summary>
        </member>
        <member name="P:XCode.BindTableAttribute.DbType">
            <summary>
            数据库类型。
            仅用于记录实体类由何种类型数据库生成，当且仅当目标数据库同为该数据库类型时，采用实体属性信息上的RawType作为反向工程的目标字段类型，以期获得开发和生产的最佳兼容。
            </summary>
        </member>
        <member name="P:XCode.BindTableAttribute.IsView">
            <summary>是否视图</summary>
        </member>
        <member name="M:XCode.BindTableAttribute.#ctor(System.String)">
            <summary>构造函数</summary>
            <param name="name">表名</param>
        </member>
        <member name="M:XCode.BindTableAttribute.#ctor(System.String,System.String)">
            <summary>构造函数</summary>
            <param name="name">表名</param>
            <param name="description">描述</param>
        </member>
        <member name="M:XCode.BindTableAttribute.#ctor(System.String,System.String,System.String,XCode.DataAccessLayer.DatabaseType,System.Boolean)">
            <summary>构造函数</summary>
            <param name="name">表名</param>
            <param name="description">描述</param>
            <param name="connName"></param>
            <param name="dbType"></param>
            <param name="isView"></param>
        </member>
        <member name="T:XCode.MapAttribute">
            <summary>用于指定数据属性映射关系</summary>
        </member>
        <member name="P:XCode.MapAttribute.Name">
            <summary>数据列</summary>
        </member>
        <member name="P:XCode.MapAttribute.Provider">
            <summary>目标提供者</summary>
        </member>
        <member name="M:XCode.MapAttribute.#ctor(System.String)">
            <summary>指定一个表内关联关系</summary>
            <param name="column"></param>
        </member>
        <member name="M:XCode.MapAttribute.#ctor(System.String,System.Type,System.String)">
            <summary>指定一个关系</summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="key"></param>
        </member>
        <member name="T:XCode.MapProvider">
            <summary>映射提供者</summary>
        </member>
        <member name="P:XCode.MapProvider.EntityType">
            <summary>实体类型</summary>
        </member>
        <member name="P:XCode.MapProvider.Key">
            <summary>关联键</summary>
        </member>
        <member name="M:XCode.MapProvider.GetDataSource">
            <summary>获取数据源</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.ModelCheckModes">
            <summary>模型检查模式</summary>
        </member>
        <member name="F:XCode.ModelCheckModes.CheckAllTablesWhenInit">
            <summary>初始化时检查所有表。默认值。具有最好性能。</summary>
        </member>
        <member name="F:XCode.ModelCheckModes.CheckTableWhenFirstUse">
            <summary>第一次使用时检查表。常用于通用实体类等存在大量实体类但不会同时使用所有实体类的场合，避免反向工程生成没有使用到的实体类的数据表。</summary>
        </member>
        <member name="T:XCode.ModelCheckModeAttribute">
            <summary>模型检查模式</summary>
        </member>
        <member name="P:XCode.ModelCheckModeAttribute.Mode">
            <summary>模式</summary>
        </member>
        <member name="M:XCode.ModelCheckModeAttribute.#ctor(XCode.ModelCheckModes)">
            <summary>指定实体类的模型检查模式</summary>
            <param name="mode"></param>
        </member>
        <member name="T:XCode.ModelSortModes">
            <summary>模型字段排序模式</summary>
        </member>
        <member name="F:XCode.ModelSortModes.BaseFirst">
            <summary>基类优先。默认值。一般用于扩展某个实体类增加若干数据字段。</summary>
        </member>
        <member name="F:XCode.ModelSortModes.DerivedFirst">
            <summary>派生类优先。一般用于具有某些公共数据字段的基类。</summary>
        </member>
        <member name="T:XCode.ModelSortModeAttribute">
            <summary>模型字段排序模式。其实不是很重要，仅仅影响数据字段在数据表中的先后顺序而已</summary>
        </member>
        <member name="P:XCode.ModelSortModeAttribute.Mode">
            <summary>模式</summary>
        </member>
        <member name="M:XCode.ModelSortModeAttribute.#ctor(XCode.ModelSortModes)">
            <summary>指定实体类的模型字段排序模式</summary>
            <param name="mode"></param>
        </member>
        <member name="T:XCode.Cache.CacheBase`1">
            <summary>缓存基类</summary>
        </member>
        <member name="P:XCode.Cache.CacheBase`1.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.Cache.CacheBase`1.TableName">
            <summary>表名</summary>
        </member>
        <member name="M:XCode.Cache.CacheBase`1.Invoke``2(System.Func{``0,``1},``0)">
            <summary>调用委托方法前设置连接名和表名，调用后还原</summary>
        </member>
        <member name="T:XCode.Cache.CacheBase">
            <summary>缓存基类</summary>
        </member>
        <member name="P:XCode.Cache.CacheBase.Debug">
            <summary>是否调试缓存模块</summary>
        </member>
        <member name="P:XCode.Cache.CacheBase.Period">
            <summary>显示统计信息的周期。默认60*60s，DAL.Debug=true时10*60s，Debug=true时60s</summary>
        </member>
        <member name="P:XCode.Cache.CacheBase.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:XCode.Cache.CacheBase.CheckShowStatics(System.Int32@,System.Action)">
            <summary>检查并显示统计信息</summary>
            <param name="total"></param>
            <param name="show"></param>
        </member>
        <member name="T:XCode.Cache.DataCache">
            <summary>运行数据缓存</summary>
        </member>
        <member name="P:XCode.Cache.DataCache.Current">
            <summary>当前实例</summary>
        </member>
        <member name="P:XCode.Cache.DataCache.Name">
            <summary>名称</summary>
        </member>
        <member name="M:XCode.Cache.DataCache.Load(System.String,System.Boolean)">
            <summary>加载</summary>
            <param name="file"></param>
            <param name="create"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.DataCache.Save(System.String,XCode.Cache.DataCache)">
            <summary>保存</summary>
            <param name="file"></param>
            <param name="data"></param>
        </member>
        <member name="M:XCode.Cache.DataCache.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="P:XCode.Cache.DataCache.Counts">
            <summary>每个表总记录数</summary>
        </member>
        <member name="P:XCode.Cache.DataCache.FieldCache">
            <summary>字段缓存，每个缓存项的值</summary>
        </member>
        <member name="T:XCode.Cache.EntityCache`1">
            <summary>实体缓存</summary>
            <remarks>
            缓存更新逻辑：
            1，初始化。首次访问阻塞等待，确保得到有效数据。
            2，定时过期。过期后异步更新缓存返回旧数据，保障性能。但若过期两倍时间，则同步更新缓存阻塞等待返回新数据。
            3，主动清除。外部主动清除缓存，强制清除后下次访问时同步更新缓存，非强制清除后下次访问时异步更新缓存。
            4，添删改过期。添删改期间，仅修改缓存，不改变过期更新，避免事务中频繁更新缓存，提交回滚事务后强制清除缓存。
            </remarks>
            <typeparam name="TEntity">实体类型</typeparam>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.ExpiredTime">
            <summary>缓存过期时间</summary>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.Times">
            <summary>缓存更新次数</summary>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.Expire">
            <summary>过期时间。单位是秒，默认10秒</summary>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.FillListMethod">
            <summary>填充数据的方法</summary>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.WaitFirst">
            <summary>是否等待第一次查询。如果不等待，第一次返回空集合。默认true</summary>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.Using">
            <summary>是否在使用缓存，在不触发缓存动作的情况下检查是否有使用缓存</summary>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.#ctor">
            <summary>实例化实体缓存</summary>
        </member>
        <member name="P:XCode.Cache.EntityCache`1.Entities">
            <summary>实体集合。无数据返回空集合而不是null</summary>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.Find(System.Predicate{`0})">
            <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.FindAll(System.Predicate{`0})">
            <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.Clear(System.String,System.Boolean)">
            <summary>清除缓存</summary>
            <param name="reason">清除原因</param>
            <param name="force">强制清除，下次访问阻塞等待。默认false仅置为过期，下次访问异步更新</param>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.Add(`0)">
            <summary>添加对象到缓存</summary>
            <param name="entity"></param>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.Remove(`0)">
            <summary>从缓存中删除对象</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="F:XCode.Cache.EntityCache`1.Total">
            <summary>总次数</summary>
        </member>
        <member name="F:XCode.Cache.EntityCache`1.Success">
            <summary>命中</summary>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.ShowStatics">
            <summary>显示统计信息</summary>
        </member>
        <member name="M:XCode.Cache.EntityCache`1.ToString">
            <summary>输出名称</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Cache.FieldCache`1">
            <summary>统计字段缓存</summary>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="P:XCode.Cache.FieldCache`1.MaxRows">
            <summary>最大行数。默认50</summary>
        </member>
        <member name="P:XCode.Cache.FieldCache`1.Where">
            <summary>数据源条件</summary>
        </member>
        <member name="P:XCode.Cache.FieldCache`1.GetDisplay">
            <summary>获取显示名的委托</summary>
        </member>
        <member name="P:XCode.Cache.FieldCache`1.DisplayFormat">
            <summary>显示名格式化字符串，两个参数是名称和个数</summary>
        </member>
        <member name="M:XCode.Cache.FieldCache`1.#ctor(XCode.Configuration.FieldItem)">
            <summary>对指定字段使用实体缓存</summary>
            <param name="field"></param>
        </member>
        <member name="M:XCode.Cache.FieldCache`1.#ctor(System.String)">
            <summary>对指定字段使用实体缓存</summary>
            <param name="fieldName"></param>
        </member>
        <member name="M:XCode.Cache.FieldCache`1.FindAllName">
            <summary>获取所有类别名称</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.FieldCache`1.ToString">
            <summary>输出名称</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Cache.IEntityCacheBase">
            <summary>缓存基接口</summary>
        </member>
        <member name="P:XCode.Cache.IEntityCacheBase.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.Cache.IEntityCacheBase.TableName">
            <summary>表名</summary>
        </member>
        <member name="T:XCode.Cache.IEntityCache">
            <summary>实体缓存接口</summary>
        </member>
        <member name="P:XCode.Cache.IEntityCache.Entities">
            <summary>实体集合。因为涉及一个转换，数据量大时很耗性能，建议不要使用。</summary>
        </member>
        <member name="M:XCode.Cache.IEntityCache.Clear(System.String,System.Boolean)">
            <summary>清除缓存</summary>
            <param name="reason">清除原因</param>
            <param name="force">强制清除，下次访问阻塞等待。默认false仅置为过期，下次访问异步更新</param>
        </member>
        <member name="T:XCode.Cache.ISingleEntityCache">
            <summary>单对象缓存接口</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache.Expire">
            <summary>过期时间。单位是秒，默认60秒</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache.MaxEntity">
            <summary>最大实体数。默认10000</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache.Using">
            <summary>是否在使用缓存</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache.Item(System.Object)">
            <summary>获取数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.ISingleEntityCache.GetItemWithSlaveKey(System.String)">
            <summary>根据从键获取实体数据</summary>
            <param name="slaveKey"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.ISingleEntityCache.ContainsKey(System.Object)">
            <summary>是否包含指定主键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.ISingleEntityCache.ContainsSlaveKey(System.String)">
            <summary>是否包含指定从键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.ISingleEntityCache.Add(XCode.IEntity)">
            <summary>向单对象缓存添加项</summary>
            <param name="value">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.ISingleEntityCache.Remove(XCode.IEntity)">
            <summary>移除指定项</summary>
            <param name="entity"></param>
        </member>
        <member name="M:XCode.Cache.ISingleEntityCache.Clear(System.String)">
            <summary>清除所有数据</summary>
            <param name="reason">清除缓存原因</param>
        </member>
        <member name="T:XCode.Cache.ISingleEntityCache`2">
            <summary></summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache`2.Item(`0)">
            <summary>获取数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache`2.GetKeyMethod">
            <summary>获取缓存主键的方法，默认方法为获取实体主键值</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache`2.FindKeyMethod">
            <summary>查找数据的方法</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache`2.SlaveKeyIgnoreCase">
            <summary>从键是否区分大小写</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache`2.FindSlaveKeyMethod">
            <summary>根据从键查找数据的方法</summary>
        </member>
        <member name="P:XCode.Cache.ISingleEntityCache`2.GetSlaveKeyMethod">
            <summary>获取缓存从键的方法，默认为空</summary>
        </member>
        <member name="T:XCode.Cache.SingleEntityCache`2">
            <summary>单对象缓存</summary>
            <remarks>
            用一个值为实体的字典作为缓存（键一般就是主键），适用于单表大量互相没有关系的数据。
            </remarks>
            <typeparam name="TKey">键值类型</typeparam>
            <typeparam name="TEntity">实体类型</typeparam>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.Expire">
            <summary>过期时间。单位是秒，默认10秒</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.ClearPeriod">
            <summary>清理周期。默认60秒检查一次，清理10倍（600秒）未访问的缓存项</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.MaxEntity">
            <summary>最大实体数。默认10000</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.Using">
            <summary>是否在使用缓存</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.GetKeyMethod">
            <summary>获取缓存主键的方法，默认方法为获取实体主键值</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.FindKeyMethod">
            <summary>查找数据的方法</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.SlaveKeyIgnoreCase">
            <summary>从键是否区分大小写</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.FindSlaveKeyMethod">
            <summary>根据从键查找数据的方法</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.GetSlaveKeyMethod">
            <summary>获取缓存从键的方法，默认为空</summary>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.#ctor">
            <summary>实例化一个实体缓存</summary>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="T:XCode.Cache.SingleEntityCache`2.CacheItem">
            <summary>缓存对象</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.CacheItem.Key">
            <summary>键</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.CacheItem.SlaveKey">
            <summary>从键</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.CacheItem.Entity">
            <summary>实体</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.CacheItem.VisitTime">
            <summary>访问时间</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.CacheItem.ExpireTime">
            <summary>缓存过期时间</summary>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.CacheItem.GetExpired">
            <summary>获取已过期时间</summary>
            <returns></returns>
        </member>
        <member name="F:XCode.Cache.SingleEntityCache`2._Count">
            <summary>缓存个数</summary>
        </member>
        <member name="F:XCode.Cache.SingleEntityCache`2.Entities">
            <summary>单对象缓存</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.SlaveEntities">
            <summary>单对象缓存，从键查询使用</summary>
        </member>
        <member name="F:XCode.Cache.SingleEntityCache`2.Total">
            <summary>总次数</summary>
        </member>
        <member name="F:XCode.Cache.SingleEntityCache`2.Success">
            <summary>命中</summary>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.ShowStatics">
            <summary>显示统计信息</summary>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.Item(`0)">
            <summary>根据主键获取实体数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.AddItem(`0,`1)">
            <summary>向两个字典加入数据</summary>
            <param name="key"></param>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.GetItemWithSlaveKey(System.String)">
            <summary>根据从键获取实体数据</summary>
            <param name="slaveKey"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.ContainsKey(`0)">
            <summary>是否包含指定键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.ContainsSlaveKey(System.String)">
            <summary>是否包含指定从键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.Add(`0,`1)">
            <summary>向单对象缓存添加项</summary>
            <param name="key"></param>
            <param name="entity">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.RemoveKey(`0)">
            <summary>移除指定项</summary>
            <param name="key">键值</param>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.Remove(`1)">
            <summary>根据主键移除指定项</summary>
            <param name="entity"></param>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.Clear(System.String)">
            <summary>清除所有数据</summary>
            <param name="reason">清除缓存原因</param>
        </member>
        <member name="P:XCode.Cache.SingleEntityCache`2.XCode#Cache#ISingleEntityCache#Item(System.Object)">
            <summary>获取数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.XCode#Cache#ISingleEntityCache#GetItemWithSlaveKey(System.String)">
            <summary>根据从键获取实体数据</summary>
            <param name="slaveKey"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.XCode#Cache#ISingleEntityCache#ContainsKey(System.Object)">
            <summary>是否包含指定主键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.XCode#Cache#ISingleEntityCache#Remove(XCode.IEntity)">
            <summary>移除指定项</summary>
            <param name="entity"></param>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.XCode#Cache#ISingleEntityCache#Add(XCode.IEntity)">
            <summary>向单对象缓存添加项</summary>
            <param name="value">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Cache.SingleEntityCache`2.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Code.BuilderOption">
            <summary>生成器选项</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.ClassNameTemplate">
            <summary>类名模板。其中{name}替换为Table.Name，如{name}Model/I{name}Dto等</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.DisplayNameTemplate">
            <summary>显示名模板。其中{displayName}替换为Table.DisplayName</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.BaseClass">
            <summary>基类。可能包含基类和接口，其中{name}替换为Table.Name</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Namespace">
            <summary>命名空间</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Usings">
            <summary>引用命名空间。区分大小写</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Pure">
            <summary>纯净类。去除属性上的Description等特性</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Interface">
            <summary>纯净接口。不带其它特性</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Partial">
            <summary>是否分部类</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Extend">
            <summary>可扩展。实现IExtend接口</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.ModelNameForCopy">
            <summary>用于生成拷贝函数的模型类。例如{name}或I{name}</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Excludes">
            <summary>排除项。要排除的表或者字段，不区分大小写</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.Output">
            <summary>输出目录</summary>
        </member>
        <member name="P:XCode.Code.BuilderOption.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="M:XCode.Code.BuilderOption.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.Code.BuilderOption.Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Code.ClassBuilder">
            <summary>类代码生成器</summary>
        </member>
        <member name="P:XCode.Code.ClassBuilder.Writer">
            <summary>写入器</summary>
        </member>
        <member name="P:XCode.Code.ClassBuilder.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:XCode.Code.ClassBuilder.ClassName">
            <summary>类名。默认Table.Name</summary>
        </member>
        <member name="P:XCode.Code.ClassBuilder.Option">
            <summary>生成器选项</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.LoadModels(System.String,XCode.Code.BuilderOption,System.Collections.Generic.IDictionary{System.String,System.String}@)">
            <summary>加载模型文件</summary>
            <param name="xmlFile">Xml模型文件</param>
            <param name="option">生成可选项</param>
            <param name="atts">扩展属性字典</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildModels(System.Collections.Generic.IList{XCode.DataAccessLayer.IDataTable},XCode.Code.BuilderOption)">
            <summary>生成简易版模型</summary>
            <param name="tables">表集合</param>
            <param name="option">可选项</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildInterfaces(System.Collections.Generic.IList{XCode.DataAccessLayer.IDataTable},XCode.Code.BuilderOption)">
            <summary>生成简易版实体接口</summary>
            <param name="tables">表集合</param>
            <param name="option">可选项</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.ClassBuilder.Execute">
            <summary>执行生成</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.OnExecuting">
            <summary>生成头部</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildClassHeader">
            <summary>实体类头部</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.GetBaseClass">
            <summary>获取基类</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildAttribute">
            <summary>实体类头部</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.OnExecuted">
            <summary>生成尾部</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildItems">
            <summary>生成主体</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildItem(XCode.DataAccessLayer.IDataColumn)">
            <summary>生成每一项</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.BuildCopy(System.String)">
            <summary>生成拷贝函数</summary>
            <param name="model">模型类</param>
        </member>
        <member name="M:XCode.Code.ClassBuilder.SetIndent(System.Boolean)">
            <summary>设置缩进</summary>
            <param name="add"></param>
        </member>
        <member name="M:XCode.Code.ClassBuilder.WriteLine(System.String)">
            <summary>写入</summary>
            <param name="value"></param>
        </member>
        <member name="M:XCode.Code.ClassBuilder.WriteLine(System.String,System.Object[])">
            <summary>写入</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:XCode.Code.ClassBuilder.Clear">
            <summary>清空，重新生成</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.ToString">
            <summary>输出结果</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.ClassBuilder.Save(System.String,System.Boolean,System.Boolean)">
            <summary>保存文件，返回文件路径</summary>
        </member>
        <member name="P:XCode.Code.ClassBuilder.CSharp">
            <summary>C#版本</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.NameOf(System.String)">
            <summary>nameof</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.ClassBuilder.GetCamelCase(System.String)">
            <summary>驼峰命名，首字母小写</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Code.ClassBuilder.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:XCode.Code.ClassBuilder.Log">
            <summary>日志</summary>
        </member>
        <member name="M:XCode.Code.ClassBuilder.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:XCode.Code.EntityBuilder">
            <summary>实体类生成器</summary>
        </member>
        <member name="P:XCode.Code.EntityBuilder.Business">
            <summary>业务类。</summary>
        </member>
        <member name="P:XCode.Code.EntityBuilder.AllTables">
            <summary>所有表类型名。用于扩展属性</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.Build(System.String,System.String,System.String,System.String,System.Nullable{System.Boolean})">
            <summary>为Xml模型文件生成实体类</summary>
            <param name="xmlFile">模型文件</param>
            <param name="output">输出目录</param>
            <param name="nameSpace">命名空间</param>
            <param name="connName">连接名</param>
            <param name="chineseFileName">中文文件名</param>
        </member>
        <member name="M:XCode.Code.EntityBuilder.FixModelFile(System.String,XCode.Code.BuilderOption,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IList{XCode.DataAccessLayer.IDataTable})">
            <summary>修正模型文件</summary>
            <param name="xmlFile"></param>
            <param name="option"></param>
            <param name="atts"></param>
            <param name="tables"></param>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildTables(System.Collections.Generic.IList{XCode.DataAccessLayer.IDataTable},XCode.Code.BuilderOption,System.Boolean)">
            <summary>为Xml模型文件生成实体类</summary>
            <param name="tables">模型文件</param>
            <param name="option">生成可选项</param>
            <param name="chineseFileName">是否中文名称</param>
        </member>
        <member name="M:XCode.Code.EntityBuilder.Load(XCode.DataAccessLayer.IDataTable)">
            <summary>加载数据表</summary>
            <param name="table"></param>
        </member>
        <member name="M:XCode.Code.EntityBuilder.OnExecuting">
            <summary>执行生成</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.AddNameSpace">
            <summary>增加常用命名空间</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.GetBaseClass">
            <summary>获取基类</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Code.EntityBuilder.Save(System.String,System.Boolean,System.Boolean)">
            <summary>保存</summary>
            <param name="ext"></param>
            <param name="overwrite"></param>
            <param name="chineseFileName"></param>
        </member>
        <member name="M:XCode.Code.EntityBuilder.OnExecuted">
            <summary>生成尾部</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildAttribute">
            <summary>实体类头部</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildItem(XCode.DataAccessLayer.IDataColumn)">
            <summary>生成每一项</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildItems">
            <summary>生成主体</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildBiz">
            <summary>生成实体类业务部分</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildAction">
            <summary>对象操作</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildCctor">
            <summary>生成静态构造函数</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildValid">
            <summary>数据验证</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildInitData">
            <summary>初始化数据</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildOverride">
            <summary>重写添删改</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildExtendProperty">
            <summary>扩展属性</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildExtendSearch">
            <summary>扩展查询</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildSearch">
            <summary>高级查询</summary>
        </member>
        <member name="M:XCode.Code.EntityBuilder.BuildBusiness">
            <summary>业务操作</summary>
        </member>
        <member name="T:XCode.Common.DataSimulation`1">
            <summary>数据模拟</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XCode.Common.DataSimulation`1.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:XCode.Common.DataSimulation">
            <summary>数据模拟</summary>
        </member>
        <member name="P:XCode.Common.DataSimulation.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="P:XCode.Common.DataSimulation.BatchSize">
            <summary>事务提交的批大小</summary>
        </member>
        <member name="P:XCode.Common.DataSimulation.Threads">
            <summary>并发线程数</summary>
        </member>
        <member name="P:XCode.Common.DataSimulation.UseSql">
            <summary>直接执行SQL</summary>
        </member>
        <member name="P:XCode.Common.DataSimulation.Score">
            <summary>分数</summary>
        </member>
        <member name="M:XCode.Common.DataSimulation.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.Common.DataSimulation.Run(System.Int32)">
            <summary>开始执行</summary>
            <param name="count"></param>
        </member>
        <member name="P:XCode.Common.DataSimulation.Log">
            <summary>日志</summary>
        </member>
        <member name="M:XCode.Common.DataSimulation.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:XCode.Common.Helper">
            <summary>助手类</summary>
        </member>
        <member name="M:XCode.Common.Helper.IsNullKey(System.Object,System.Type)">
            <summary>指定键是否为空。一般业务系统设计不允许主键为空，包括自增的0和字符串的空</summary>
            <param name="key">键值</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Common.Helper.IsEntityNullKey(XCode.IEntity)">
            <summary>是否空主键的实体</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Configuration.DbConfigProvider">
            <summary>数据库参数表文件提供者</summary>
        </member>
        <member name="P:XCode.Configuration.DbConfigProvider.UserId">
            <summary>要加载配置的用户。默认0表示全局</summary>
        </member>
        <member name="M:XCode.Configuration.DbConfigProvider.LoadAll">
            <summary>加载配置</summary>
        </member>
        <member name="M:XCode.Configuration.DbConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="T:XCode.Configuration.FieldItem">
            <summary>数据属性元数据以及特性</summary>
        </member>
        <member name="F:XCode.Configuration.FieldItem._Property">
            <summary>属性元数据</summary>
        </member>
        <member name="F:XCode.Configuration.FieldItem._Column">
            <summary>绑定列特性</summary>
        </member>
        <member name="F:XCode.Configuration.FieldItem._DataObjectField">
            <summary>数据字段特性</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Description">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.DisplayName">
            <summary>说明</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Name">
            <summary>属性名</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Type">
            <summary>属性类型</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.DeclaringType">
            <summary>声明类型</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.IsIdentity">
            <summary>是否标识列</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.PrimaryKey">
            <summary>是否主键</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Master">
            <summary>是否主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.IsNullable">
            <summary>是否允许空</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Length">
            <summary>长度</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.IsDataObjectField">
            <summary>是否数据绑定列</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.IsDynamic">
            <summary>是否动态字段</summary>
        </member>
        <member name="F:XCode.Configuration.FieldItem.COLUMNNAME_FLAG">
            <summary>字段名要过滤掉的标识符，考虑MSSQL、MySql、SQLite、Oracle等</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.ColumnName">
            <summary>用于数据绑定的字段名</summary>
            <remarks>
            默认使用BindColumn特性中指定的字段名，如果没有指定，则使用属性名。
            字段名可能两边带有方括号等标识符
            </remarks>
        </member>
        <member name="P:XCode.Configuration.FieldItem.ReadOnly">
            <summary>是否只读</summary>
            <remarks>set { _ReadOnly = value; } 放出只读属性的设置，比如在编辑页面的时候，有的字段不能修改 如修改用户时  不能修改用户名</remarks>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Table">
            <summary>表</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Field">
            <summary>字段</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Factory">
            <summary>实体操作者</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.FormatedName">
            <summary>已格式化的字段名，可字节用于SQL中。主要用于处理关键字，比如MSSQL里面的[User]</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.OriField">
            <summary>跟当前字段有关系的原始字段</summary>
        </member>
        <member name="P:XCode.Configuration.FieldItem.Map">
            <summary>获取映射特性</summary>
        </member>
        <member name="M:XCode.Configuration.FieldItem.#ctor(XCode.Configuration.TableItem,System.Reflection.PropertyInfo)">
            <summary>构造函数</summary>
            <param name="table"></param>
            <param name="property">属性</param>
        </member>
        <member name="M:XCode.Configuration.FieldItem.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.Fill(XCode.DataAccessLayer.IDataColumn)">
            <summary>填充到XField中去</summary>
            <param name="field">字段</param>
        </member>
        <member name="M:XCode.Configuration.FieldItem.CreateFormat(System.String,System.Object)">
            <summary>建立表达式</summary>
            <param name="format"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.Equal(System.Object)">
            <summary>等于</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotEqual(System.Object)">
            <summary>不等于</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.StartsWith(System.String)">
            <summary>以某个字符串开始,{0}%操作</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.EndsWith(System.String)">
            <summary>以某个字符串结束，%{0}操作</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.Contains(System.String)">
            <summary>包含某个字符串，%{0}%操作</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotContains(System.String)">
            <summary>不包含某个字符串，%{0}%操作</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.In(System.Collections.IEnumerable)">
            <summary>In操作</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接。只有一项时转为等于</remarks>
            <param name="value">枚举数据，会转化为字符串</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotIn(System.Collections.IEnumerable)">
            <summary>NotIn操作</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接。只有一项时修改为不等于</remarks>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.In(System.String)">
            <summary>In操作。直接使用字符串可能有注入风险</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="child">逗号分割的数据。可能有注入风险</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotIn(System.String)">
            <summary>NotIn操作。直接使用字符串可能有注入风险</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="child">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.In(XCode.DataAccessLayer.SelectBuilder)">
            <summary>In操作。直接使用字符串可能有注入风险</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="builder">逗号分割的数据。可能有注入风险</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotIn(XCode.DataAccessLayer.SelectBuilder)">
            <summary>NotIn操作。直接使用字符串可能有注入风险</summary>
            <remarks>空参数不参与表达式操作，不生成该部分SQL拼接</remarks>
            <param name="builder">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.IsNull">
            <summary>IsNull操作，不为空，一般用于字符串，但不匹配0长度字符串</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotIsNull">
            <summary>NotIsNull操作</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.IsNullOrEmpty">
            <summary>IsNullOrEmpty操作，用于空或者0长度字符串</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.NotIsNullOrEmpty">
            <summary>NotIsNullOrEmpty操作</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.IsTrue(System.Nullable{System.Boolean})">
            <summary>是否True或者False/Null，参数决定两组之一</summary>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.IsFalse(System.Nullable{System.Boolean})">
            <summary>是否False或者True/Null，参数决定两组之一</summary>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.op_GreaterThan(XCode.Configuration.FieldItem,System.Object)">
            <summary>大于</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.op_LessThan(XCode.Configuration.FieldItem,System.Object)">
            <summary>小于</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.op_GreaterThanOrEqual(XCode.Configuration.FieldItem,System.Object)">
            <summary>大于等于</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.op_LessThanOrEqual(XCode.Configuration.FieldItem,System.Object)">
            <summary>小于等于</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.FieldItem.op_Implicit(XCode.Configuration.FieldItem)~System.String">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Configuration.Field">
            <summary>继承FieldItem，仅仅为了重载==和!=运算符</summary>
        </member>
        <member name="M:XCode.Configuration.Field.#ctor(XCode.Configuration.TableItem,System.Reflection.PropertyInfo)">
            <summary>构造函数</summary>
            <param name="table"></param>
            <param name="property">属性</param>
        </member>
        <member name="M:XCode.Configuration.Field.op_Equality(XCode.Configuration.Field,System.Object)">
            <summary>等于</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.Field.op_Inequality(XCode.Configuration.Field,System.Object)">
            <summary>不等于</summary>
            <param name="field">字段</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.Field.GetHashCode">
            <summary>重写一下</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.Field.Equals(System.Object)">
            <summary>重写一下</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.Field.op_Implicit(XCode.Configuration.Field)~System.String">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Configuration.FieldOption">
            <summary>字段选项</summary>
        </member>
        <member name="P:XCode.Configuration.FieldOption.AllFields">
            <summary>是否使用所有字段。默认true，除了基础数据字段外，包括使用扩展属性</summary>
        </member>
        <member name="P:XCode.Configuration.FieldOption.DisplayName">
            <summary>是否使用显示名。默认false，使用英文名，否则使用中文显示名</summary>
        </member>
        <member name="T:XCode.Configuration.TableItem">
            <summary>数据表元数据</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.EntityType">
            <summary>实体类型</summary>
        </member>
        <member name="F:XCode.Configuration.TableItem._Table">
            <summary>绑定表特性</summary>
        </member>
        <member name="F:XCode.Configuration.TableItem._Indexes">
            <summary>绑定索引特性</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.Description">
            <summary>说明</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.ConnMaps">
            <summary>连接名映射</summary>
        </member>
        <member name="M:XCode.Configuration.TableItem.FindConnMap(System.String,System.Type)">
            <summary>根据连接名和类名查找连接名映射</summary>
            <param name="connName"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Configuration.TableItem.Fields">
            <summary>数据字段</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.AllFields">
            <summary>所有字段</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.Identity">
            <summary>标识列</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.PrimaryKeys">
            <summary>主键。不会返回null</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.Master">
            <summary>主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.FieldNames">
            <summary>字段名集合，不区分大小写的哈希表存储，外部不要修改元素数据</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.ExtendFieldNames">
            <summary>扩展属性集合，不区分大小写的哈希表存储，外部不要修改元素数据</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.DataTable">
            <summary>数据表架构</summary>
        </member>
        <member name="P:XCode.Configuration.TableItem.ModelCheckMode">
            <summary>模型检查模式</summary>
        </member>
        <member name="M:XCode.Configuration.TableItem.Create(System.Type)">
            <summary>创建</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.TableItem.GetFields(System.Type)">
            <summary>获取属性，保证基类属性在前</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.TableItem.FindByName(System.String)">
            <summary>根据名称查找</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.TableItem.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Configuration.TableItem.Add(System.String,System.Type,System.String,System.Int32)">
            <summary>动态增加字段</summary>
            <param name="name"></param>
            <param name="type"></param>
            <param name="description"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.FieldExtension">
            <summary>字段扩展</summary>
        </member>
        <member name="M:XCode.FieldExtension.Between(XCode.Configuration.FieldItem,System.DateTime,System.DateTime)">
            <summary>时间专用区间函数，左闭合右开放，开始结束都是日期时包含结束日期（也即结束日期加一天）</summary>
            <param name="fi"></param>
            <param name="start">起始时间，大于等于</param>
            <param name="end">结束时间，小于。如果是日期，则加一天</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Between(XCode.Configuration.FieldItem,System.DateTime,System.DateTime,NewLife.Data.Snowflake)">
            <summary>时间专用区间函数，左闭合右开放，开始结束都是日期时包含结束日期（也即结束日期加一天）</summary>
            <param name="fi"></param>
            <param name="start">起始时间，大于等于</param>
            <param name="end">结束时间，小于。如果是日期，则加一天</param>
            <param name="snow"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Today(XCode.Configuration.FieldItem)">
            <summary>当天范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Yesterday(XCode.Configuration.FieldItem)">
            <summary>昨天范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Tomorrow(XCode.Configuration.FieldItem)">
            <summary>明天范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.LastDays(XCode.Configuration.FieldItem,System.Int32)">
            <summary>过去天数范围</summary>
            <param name="field">字段</param>
            <param name="days"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.NextDays(XCode.Configuration.FieldItem,System.Int32)">
            <summary>未来天数范围</summary>
            <param name="field">字段</param>
            <param name="days"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.ThisWeek(XCode.Configuration.FieldItem)">
            <summary>本周范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.LastWeek(XCode.Configuration.FieldItem)">
            <summary>上周范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.NextWeek(XCode.Configuration.FieldItem)">
            <summary>下周范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.ThisMonth(XCode.Configuration.FieldItem)">
            <summary>本月范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.LastMonth(XCode.Configuration.FieldItem)">
            <summary>上月范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.NextMonth(XCode.Configuration.FieldItem)">
            <summary>下月范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.ThisQuarter(XCode.Configuration.FieldItem)">
            <summary>本季度范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.LastQuarter(XCode.Configuration.FieldItem)">
            <summary>上季度范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.NextQuarter(XCode.Configuration.FieldItem)">
            <summary>下季度范围</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.ContainsAll(XCode.Configuration.FieldItem,System.String)">
            <summary>包含所有关键字</summary>
            <param name="field"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.ContainsAny(XCode.Configuration.FieldItem,System.String)">
            <summary>包含任意关键字</summary>
            <param name="field"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Asc(XCode.Configuration.FieldItem)">
            <summary>升序</summary>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Desc(XCode.Configuration.FieldItem)">
            <summary>降序</summary>
            <param name="field">字段</param>
            <remarks>感谢 树懒（303409914）发现这里的错误</remarks>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Sort(XCode.Configuration.FieldItem,System.Boolean)">
            <summary>通过参数置顶升序降序</summary>
            <param name="field">字段</param>
            <param name="isdesc">是否降序</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.GroupBy(XCode.Configuration.FieldItem)">
            <summary>分组。有条件的分组请使用WhereExpression.GroupBy</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.GroupBy(XCode.WhereExpression,XCode.Configuration.FieldItem[])">
            <summary>按照指定若干个字段分组。没有条件时使用分组请用FieldItem的GroupBy</summary>
            <param name="where"></param>
            <param name="fields"></param>
            <returns>将需要分组的字段作为ConcatExpression类型添加到whereExpression尾部</returns>
        </member>
        <member name="M:XCode.FieldExtension.Aggregate(XCode.Configuration.FieldItem,System.String,System.String)">
            <summary>聚合</summary>
            <param name="field">字段</param>
            <param name="action"></param>
            <param name="newName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.As(XCode.Configuration.FieldItem,System.String)">
            <summary>作为新的列</summary>
            <param name="field"></param>
            <param name="newName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Count(XCode.Configuration.FieldItem,System.String)">
            <summary>数量</summary>
            <param name="field">字段</param>
            <param name="newName">聚合后as的新名称，默认空，表示跟前面字段名一致</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Sum(XCode.Configuration.FieldItem,System.String)">
            <summary>求和</summary>
            <param name="field">字段</param>
            <param name="newName">聚合后as的新名称，默认空，表示跟前面字段名一致</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Min(XCode.Configuration.FieldItem,System.String)">
            <summary>最小值</summary>
            <param name="field">字段</param>
            <param name="newName">聚合后as的新名称，默认空，表示跟前面字段名一致</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Max(XCode.Configuration.FieldItem,System.String)">
            <summary>最大值</summary>
            <param name="field">字段</param>
            <param name="newName">聚合后as的新名称，默认空，表示跟前面字段名一致</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.Avg(XCode.Configuration.FieldItem,System.String)">
            <summary>平均值</summary>
            <param name="field">字段</param>
            <param name="newName">聚合后as的新名称，默认空，表示跟前面字段名一致</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.SumCase(XCode.Configuration.FieldItem,System.Object,System.String)">
            <summary>sumCase子句，计算等于某个值的数量</summary>
            <param name="field">字段</param>
            <param name="value">值</param>
            <param name="newName">聚合后as的新名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.FieldExtension.SumLarge(XCode.Configuration.FieldItem,System.Object,System.String)">
            <summary>sumCase子句，计算大于某个值的数量</summary>
            <param name="field">字段</param>
            <param name="value">值</param>
            <param name="newName">聚合后as的新名称</param>
            <returns></returns>
        </member>
        <member name="T:XCode.IDataRowEntityAccessor">
            <summary>在数据行和实体类之间映射数据的接口</summary>
        </member>
        <member name="M:XCode.IDataRowEntityAccessor.LoadData``1(System.Data.DataTable)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="dt">数据表</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.IDataRowEntityAccessor.LoadData``1(NewLife.Data.DbTable)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="ds">数据表</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.IDataRowEntityAccessor.LoadData``1(System.Data.IDataReader)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="dr">数据读取器</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.DataRowEntityAccessor.LoadData``1(System.Data.DataTable)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="dt">数据表</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.DataRowEntityAccessor.LoadData``1(NewLife.Data.DbTable)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="ds">数据表</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.DataRowEntityAccessor.LoadData``1(System.Data.IDataReader)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="dr">数据读取器</param>
            <returns>实体数组</returns>
        </member>
        <member name="T:XCode.DirtyCollection">
            <summary>脏属性集合</summary>
            <remarks>
            脏数据需要并行高性能，要节省内存，允许重复。
            普通集合加锁成本太高，并行集合内存消耗太大，并行字典只有一两项的时候也要占用7.9k内存。
            </remarks>
        </member>
        <member name="P:XCode.DirtyCollection.Item(System.String)">
            <summary>获取或设置与指定的属性是否有脏数据。</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.DirtyCollection.Clear">
            <summary>清空</summary>
        </member>
        <member name="P:XCode.DirtyCollection.Count">
            <summary>个数</summary>
        </member>
        <member name="M:XCode.DirtyCollection.GetEnumerator">
            <summary>枚举迭代</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Entity`1">
            <summary>数据实体类基类。所有数据实体类都必须继承该类。</summary>
        </member>
        <member name="M:XCode.Entity`1.#cctor">
            <summary>静态构造</summary>
        </member>
        <member name="M:XCode.Entity`1.CreateInstance(System.Boolean)">
            <summary>创建实体。</summary>
            <remarks>
            可以重写改方法以实现实体对象的一些初始化工作。
            切记，写为实例方法仅仅是为了方便重载，所要返回的实例绝对不会是当前实例。
            </remarks>
            <param name="forEdit">是否为了编辑而创建，如果是，可以再次做一些相关的初始化工作</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.LoadData(System.Data.DataSet)">
            <summary>加载记录集。无数据时返回空集合而不是null。</summary>
            <param name="ds">记录集</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.LoadData(System.Data.DataTable)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="dt">数据表</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.LoadData(NewLife.Data.DbTable)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="ds">数据表</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.LoadData(System.Data.IDataReader)">
            <summary>加载数据表。无数据时返回空集合而不是null。</summary>
            <param name="dr">数据读取器</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.Insert">
            <summary>插入数据，<see cref="M:XCode.Entity`1.Valid(System.Boolean)"/>后，在事务中调用<see cref="M:XCode.Entity`1.OnInsert"/>。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.OnInsert">
            <summary>把该对象持久化到数据库，添加/更新实体缓存。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Update">
            <summary>更新数据，<see cref="M:XCode.Entity`1.Valid(System.Boolean)"/>后，在事务中调用<see cref="M:XCode.Entity`1.OnUpdate"/>。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.OnUpdate">
            <summary>更新数据库，同时更新实体缓存</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Delete">
            <summary>删除数据，通过在事务中调用OnDelete实现。</summary>
            <remarks>
            删除时，如果有且仅有主键有脏数据，则可能是ObjectDataSource之类的删除操作。
            该情况下，实体类没有完整的信息（仅有主键信息），将会导致无法通过扩展属性删除附属数据。
            如果需要避开该机制，请清空脏数据。
            </remarks>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.OnDelete">
            <summary>从数据库中删除该对象，同时从实体缓存中删除</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Entity`1.IsNew">
            <summary>
            是否为新数据保存
            </summary>
        </member>
        <member name="M:XCode.Entity`1.Save">
            <summary>保存。Insert/Update/Upsert</summary>
            <remarks>
            Save的几个场景：
            1，Find, Update()
            2，new, Insert()
            3，new, Upsert()
            </remarks>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.SaveWithoutValid">
            <summary>不需要验证的保存，不执行Valid，一般用于快速导入数据</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.SaveAsync(System.Int32)">
            <summary>异步保存。实现延迟保存，大事务保存。主要面向日志表和频繁更新的在线记录表</summary>
            <param name="msDelay">延迟保存的时间。默认0ms近实时保存</param>
            <remarks>
            调用平均耗时190.86ns，IPModule占38.89%，TimeModule占16.31%，UserModule占7.20%，Valid占14.36%
            </remarks>
            <returns>是否成功加入异步队列，实体对象已存在于队列中则返回false</returns>
        </member>
        <member name="M:XCode.Entity`1.Valid(System.Boolean)">
            <summary>验证并修补数据，通过抛出异常的方式提示验证失败。</summary>
            <remarks>建议重写者调用基类的实现，因为基类根据数据字段的唯一索引进行数据验证。</remarks>
            <param name="isNew">是否新数据</param>
        </member>
        <member name="M:XCode.Entity`1.Exist(System.String[])">
            <summary>根据指定键检查数据，返回数据是否已存在</summary>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.CheckExist(System.String[])">
            <summary>根据指定键检查数据是否已存在，若已存在，抛出ArgumentOutOfRangeException异常</summary>
            <param name="names"></param>
        </member>
        <member name="M:XCode.Entity`1.CheckExist(System.Boolean,System.String[])">
            <summary>根据指定键检查数据是否已存在，若已存在，抛出ArgumentOutOfRangeException异常</summary>
            <param name="isNew">是否新数据</param>
            <param name="names"></param>
        </member>
        <member name="M:XCode.Entity`1.Exist(System.Boolean,System.String[])">
            <summary>根据指定键检查数据，返回数据是否已存在</summary>
            <param name="isNew">是否新数据</param>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Find(System.String,System.Object)">
            <summary>根据属性以及对应的值，查找单个实体</summary>
            <param name="name">属性名称</param>
            <param name="value">属性值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Find(System.String[],System.Object[])">
            <summary>根据属性列表以及对应的值列表，查找单个实体</summary>
            <param name="names">属性名称集合</param>
            <param name="values">属性值集合</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindUnique(XCode.Expression)">
            <summary>根据条件查找唯一的单个实体</summary>
            根据条件查找唯一的单个实体，因为是唯一的，所以不需要分页和排序。
            如果不确定是否唯一，一定不要调用该方法，否则会返回大量的数据。
            <remarks>
            </remarks>
            <param name="where">查询条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Find(System.String)">
            <summary>根据条件查找单个实体</summary>
            <param name="whereClause">查询条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.CheckState(System.Boolean)">
            <summary>
            获取可用
            </summary>
            <param name="isall"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Find(XCode.Expression)">
            <summary>根据条件查找单个实体</summary>
            <param name="where">查询条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindByKey(System.Object)">
            <summary>根据主键查找单个实体</summary>
            <param name="key">唯一主键的值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindByKeyForEdit(System.Object)">
            <summary>根据主键查询一个实体对象用于表单编辑</summary>
            <param name="key">唯一主键的值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindMin(System.String,XCode.Expression)">
            <summary>查询指定字段的最小值</summary>
            <param name="field">指定字段</param>
            <param name="where">条件字句</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindMax(System.String,XCode.Expression)">
            <summary>查询指定字段的最大值</summary>
            <param name="field">指定字段</param>
            <param name="where">条件字句</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll">
            <summary>获取所有数据。获取大量数据时会非常慢，慎用。没有数据时返回空集合而不是null</summary>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll(System.String,System.Object)">
            <summary>根据名称获取数据集。没有数据时返回空集合而不是null</summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll(System.String[],System.Object[])">
            <summary>根据属性列表以及对应的值列表，查找单个实体</summary>
            <param name="names">属性名称集合</param>
            <param name="values">属性值集合</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>最标准的查询数据。没有数据时返回空集合而不是null</summary>
            <remarks>
            最经典的批量查询，看这个Select @selects From Table Where @where Order By @order Limit @startRowIndex,@maximumRows，你就明白各参数的意思了。
            </remarks>
            <param name="where">条件字句，不带Where</param>
            <param name="order">排序字句，不带Order By</param>
            <param name="selects">查询列，默认null表示所有字段</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体集</returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll(XCode.Expression,System.String,System.String,System.Int64,System.Int64)">
            <summary>最标准的查询数据。没有数据时返回空集合而不是null</summary>
            <remarks>
            最经典的批量查询，看这个Select @selects From Table Where @where Order By @order Limit @startRowIndex,@maximumRows，你就明白各参数的意思了。
            </remarks>
            <param name="where">条件字句，不带Where</param>
            <param name="order">排序字句，不带Order By</param>
            <param name="selects">查询列，默认null表示所有字段</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体集</returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll(XCode.Expression,NewLife.Data.PageParameter,System.String)">
            <summary>同时查询满足条件的记录集和记录总数。没有数据时返回空集合而不是null</summary>
            <param name="where">条件，不带Where</param>
            <param name="page">分页排序参数，同时返回满足条件的总记录数</param>
            <param name="selects">查询列，默认null表示所有字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindAll(System.String)">
            <summary>执行SQl获取数据集</summary>
            <param name="sql">SQL语句</param>
            <returns>实体集</returns>
        </member>
        <member name="M:XCode.Entity`1.FindData(XCode.Expression,System.String,System.String,System.Int64,System.Int64)">
            <summary>查询数据，返回内存表DbTable而不是实体列表</summary>
            <remarks>
            最经典的批量查询，看这个Select @selects From Table Where @where Order By @order Limit @startRowIndex,@maximumRows，你就明白各参数的意思了。
            </remarks>
            <param name="where">条件字句，不带Where</param>
            <param name="order">排序字句，不带Order By</param>
            <param name="selects">查询列，默认null表示所有字段</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>内存表</returns>
        </member>
        <member name="M:XCode.Entity`1.FindAllWithCache">
            <summary>查找所有缓存。没有数据时返回空集合而不是null</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindCount">
            <summary>返回总记录数</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.FindCount(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>返回总记录数</summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <param name="selects">查询列。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <param name="startRowIndex">开始行，0表示第一行。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <param name="maximumRows">最大返回行数，0表示所有行。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <returns>总行数</returns>
        </member>
        <member name="M:XCode.Entity`1.FindCount(XCode.Expression,System.String,System.String,System.Int64,System.Int64)">
            <summary>返回总记录数</summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <param name="selects">查询列。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <param name="startRowIndex">开始行，0表示第一行。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <param name="maximumRows">最大返回行数，0表示所有行。这里无意义，仅仅为了保持与FindAll相同的方法签名</param>
            <returns>总行数</returns>
        </member>
        <member name="M:XCode.Entity`1.FindSQL(System.String,System.String,System.String,System.Int32,System.Int32)">
            <summary>获取查询SQL。主要用于构造子查询</summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体集</returns>
        </member>
        <member name="M:XCode.Entity`1.FindSQLWithKey(System.String)">
            <summary>获取查询唯一键的SQL。比如Select ID From Table</summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Search(System.String,System.String,System.Int64,System.Int64)">
            <summary>查询满足条件的记录集，分页、排序。没有数据时返回空集合而不是null</summary>
            <param name="key">关键字</param>
            <param name="order">排序，不带Order By</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体集</returns>
        </member>
        <member name="M:XCode.Entity`1.SearchCount(System.String,System.String,System.Int64,System.Int64)">
            <summary>查询满足条件的记录总数，分页和排序无效，带参数是因为ObjectDataSource要求它跟Search统一</summary>
            <param name="key">关键字</param>
            <param name="order">排序，不带Order By</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>记录数</returns>
        </member>
        <member name="M:XCode.Entity`1.Search(System.String,NewLife.Data.PageParameter)">
            <summary>同时查询满足条件的记录集和记录总数。没有数据时返回空集合而不是null</summary>
            <param name="key"></param>
            <param name="page">分页排序参数，同时返回满足条件的总记录数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Search(System.DateTime,System.DateTime,System.String,NewLife.Data.PageParameter)">
            <summary>同时查询满足条件的记录集和记录总数。没有数据时返回空集合而不是null</summary>
            <param name="start">开始时间</param>
            <param name="end">结束时间</param>
            <param name="key">关键字</param>
            <param name="page">分页排序参数，同时返回满足条件的总记录数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.SearchWhere(System.DateTime,System.DateTime,System.String,NewLife.Data.PageParameter)">
            <summary>构造高级查询条件</summary>
            <param name="start">开始时间</param>
            <param name="end">结束时间</param>
            <param name="key">关键字</param>
            <param name="page">分页排序参数，同时返回满足条件的总记录数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.SearchWhereByKeys(System.String,XCode.Configuration.FieldItem[],System.Func{System.String,XCode.Configuration.FieldItem[],XCode.WhereExpression})">
            <summary>根据空格分割的关键字集合构建查询条件</summary>
            <param name="keys">空格分割的关键字集合</param>
            <param name="fields">要查询的字段，默认为空表示查询所有字符串字段</param>
            <param name="func">处理每一个查询关键字的回调函数</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.SearchWhereByKey(System.String,XCode.Configuration.FieldItem[])">
            <summary>构建关键字查询条件</summary>
            <param name="key">关键字</param>
            <param name="fields">要查询的字段，默认为空表示查询所有字符串字段</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Insert(`0)">
            <summary>把一个实体对象持久化到数据库</summary>
            <param name="obj">实体对象</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.Entity`1.Insert(System.String[],System.Object[])">
            <summary>把一个实体对象持久化到数据库</summary>
            <param name="names">更新属性列表</param>
            <param name="values">更新值列表</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.Entity`1.Update(`0)">
            <summary>把一个实体对象更新到数据库</summary>
            <param name="obj">实体对象</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.Entity`1.Update(System.String,System.String)">
            <summary>更新一批实体数据</summary>
            <param name="setClause">要更新的项和数据</param>
            <param name="whereClause">指定要更新的实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Update(System.String[],System.Object[],System.String[],System.Object[])">
            <summary>更新一批实体数据</summary>
            <param name="setNames">更新属性列表</param>
            <param name="setValues">更新值列表</param>
            <param name="whereNames">条件属性列表</param>
            <param name="whereValues">条件值列表</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.Entity`1.Delete(`0)">
            <summary>
            从数据库中删除指定实体对象。
            实体类应该实现该方法的另一个副本，以唯一键或主键作为参数
            </summary>
            <param name="obj">实体对象</param>
            <returns>返回受影响的行数，可用于判断被删除了多少行，从而知道操作是否成功</returns>
        </member>
        <member name="M:XCode.Entity`1.Delete(System.String)">
            <summary>从数据库中删除指定条件的实体对象。</summary>
            <param name="whereClause">限制条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Delete(System.String[],System.Object[])">
            <summary>从数据库中删除指定属性列表和值列表所限定的实体对象。</summary>
            <param name="names">属性列表</param>
            <param name="values">值列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Save(`0)">
            <summary>把一个实体对象更新到数据库</summary>
            <param name="obj">实体对象</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.Entity`1.CreateBuilder(XCode.Expression,System.String,System.String)">
            <summary>构造SQL查询语句</summary>
            <param name="where">条件</param>
            <param name="order">排序</param>
            <param name="selects">选择列</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Entity`1.Item(System.String)">
            <summary>获取/设置 字段值。</summary>
            <remarks>
            一个索引，反射实现。
            派生实体类可重写该索引，以避免发射带来的性能损耗。
            基类已经实现了通用的快速访问，但是这里仍然重写，以增加控制，
            比如字段名是属性名前面加上_，并且要求是实体字段才允许这样访问，否则一律按属性处理。
            </remarks>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.OnRead(System.IO.Stream,System.Object,System.Boolean)">
            <summary>从数据流反序列化</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <param name="extend">是否序列化扩展属性</param>
        </member>
        <member name="M:XCode.Entity`1.OnWrite(System.IO.Stream,System.Object,System.Boolean)">
            <summary>二进制序列化到数据流</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <param name="extend">是否序列化扩展属性</param>
        </member>
        <member name="M:XCode.Entity`1.Clone">
            <summary>创建当前对象的克隆对象，仅拷贝基本字段</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.CloneEntity(System.Boolean)">
            <summary>克隆实体。创建当前对象的克隆对象，仅拷贝基本字段</summary>
            <param name="setDirty">是否设置脏数据。默认不设置</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.CloneEntityInternal(System.Boolean)">
            <summary>克隆实体</summary>
            <param name="setDirty"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.ResetDirty">
            <summary>从数据库查询数据，对比重置脏数据</summary>
            <remarks>
            在MVC中直接用实体对象接收前端数据进行更新操作时，脏数据可能不准确。
            该方法实现脏数据重置，确保可以准确保存到数据库。
            </remarks>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.GetOrAdd``1(``0,System.Func{``0,System.Boolean,`0},System.Func{``0,`0})">
            <summary>获取 或 新增 对象，带缓存查询，常用于统计等高并发更新的情况，一般配合SaveAsync</summary>
            <typeparam name="TKey"></typeparam>
            <param name="key">业务主键，如果是多字段混合索引，则建立一个模型类</param>
            <param name="find">查找函数</param>
            <param name="create">创建对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.GetOrAdd``1(``0,System.Func{``0,`0},System.Func{``0,`0})">
            <summary>获取 或 新增 对象，不带缓存查询，常用于统计等高并发更新的情况，一般配合SaveAsync</summary>
            <typeparam name="TKey"></typeparam>
            <param name="key">业务主键，如果是多字段混合索引，则建立一个模型类</param>
            <param name="find">查找函数</param>
            <param name="create">创建对象</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Entity`1.Meta">
            <summary>实体元数据</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.ThisType">
            <summary>实体类型</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Factory">
            <summary>实体操作者</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Table">
            <summary>表信息</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.ConnName">
            <summary>链接名。线程内允许修改，修改者负责还原。若要还原默认值，设为null即可</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.TableName">
            <summary>表名。线程内允许修改，修改者负责还原</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.AllFields">
            <summary>所有数据属性</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Fields">
            <summary>所有绑定到数据表的属性</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.FieldNames">
            <summary>字段名集合，不区分大小写的哈希表存储，外部不要修改元素数据</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Unique">
            <summary>唯一键，返回第一个标识列或者唯一的主键</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Master">
            <summary>主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Session">
            <summary>实体会话。线程静态</summary>
        </member>
        <member name="M:XCode.Entity`1.Meta.BeginTrans">
            <summary>开始事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.Entity`1.Meta.Commit">
            <summary>提交事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.Entity`1.Meta.Rollback">
            <summary>回滚事务，忽略异常</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.Entity`1.Meta.CreateTrans">
            <summary>创建事务</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Cache">
            <summary>实体缓存</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Entity`1.Meta.SingleCache">
            <summary>单对象实体缓存。</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Count">
            <summary>总记录数，小于1000时是精确的，大于1000时缓存10分钟</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.ShardConnName">
            <summary>自动分库回调，用于添删改操作</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.ShardTableName">
            <summary>自动分表回调，用于添删改操作</summary>
        </member>
        <member name="M:XCode.Entity`1.Meta.ProcessWithSplit``1(System.String,System.String,System.Func{``0})">
            <summary>在分库上执行操作，自动还原</summary>
            <param name="connName"></param>
            <param name="tableName"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Meta.CreateSplit(System.String,System.String)">
            <summary>创建分库会话，using结束时自动还原</summary>
            <param name="connName">连接名</param>
            <param name="tableName">表名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.Meta.AutoSplit(`0)">
            <summary>针对实体对象自动分库分表</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Entity`1.Meta.SplitPackge.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.SplitPackge.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.Entity`1.Meta.Modules">
            <summary>实体模块集合</summary>
        </member>
        <member name="T:XCode.Entity`1.EntityOperate">
            <summary>默认的实体工厂</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.EntityType">
            <summary>实体类型</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Session">
            <summary>实体会话</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Persistence">
            <summary>实体持久化</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Accessor">
            <summary>数据行访问器，把数据行映射到实体类</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Default">
            <summary>默认实体</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Table">
            <summary>数据表元数据</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.AllFields">
            <summary>所有数据属性</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Fields">
            <summary>所有绑定到数据表的属性</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.FieldNames">
            <summary>字段名集合，不区分大小写的哈希表存储，外部不要修改元素数据</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Unique">
            <summary>唯一键，返回第一个标识列或者唯一的主键</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Master">
            <summary>主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Count">
            <summary>总记录数</summary>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.#ctor">
            <summary>构造实体工厂</summary>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.Create(System.Boolean)">
            <summary>创建一个实体对象</summary>
            <param name="forEdit">是否为了编辑而创建，如果是，可以再次做一些相关的初始化工作</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.LoadData(System.Data.DataSet)">
            <summary>加载记录集</summary>
            <param name="ds">记录集</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.Find(System.String,System.Object)">
            <summary>根据属性以及对应的值，查找单个实体</summary>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.Find(XCode.Expression)">
            <summary>根据条件查找单个实体</summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindByKey(System.Object)">
            <summary>根据主键查找单个实体</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindByKeyForEdit(System.Object)">
            <summary>根据主键查询一个实体对象用于表单编辑</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindAll">
            <summary>获取所有实体对象。获取大量数据时会非常慢，慎用</summary>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindAll(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>查询并返回实体对象集合。
            表名以及所有字段名，请使用类名以及字段对应的属性名，方法内转换为表名和列名
            </summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindAll(XCode.Expression,System.String,System.String,System.Int64,System.Int64)">
            <summary>查询并返回实体对象集合。
            表名以及所有字段名，请使用类名以及字段对应的属性名，方法内转换为表名和列名
            </summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindAllWithCache">
            <summary>查找所有缓存</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindCount">
            <summary>返回总记录数</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindCount(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>返回总记录数</summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>总行数</returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.FindCount(XCode.Expression)">
            <summary>返回总记录数</summary>
            <param name="where">条件，不带Where</param>
            <returns>总行数</returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.GetOrAdd``1(``0,System.Func{``0,System.Boolean,XCode.IEntity},System.Func{``0,XCode.IEntity})">
            <summary>获取 或 新增 对象，常用于统计等高并发更新的情况，一般配合SaveAsync</summary>
            <typeparam name="TKey"></typeparam>
            <param name="key">业务主键</param>
            <param name="find">查找函数</param>
            <param name="create">创建对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Entity`1.EntityOperate.CreateTrans">
            <summary>创建事务</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.AutoIdentity">
            <summary>是否自增获取自增返回值。默认启用</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.AllowInsertIdentity">
            <summary>是否允许向自增列插入数据。为免冲突，仅本线程有效</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.AutoSetGuidField">
            <summary>自动设置Guid的字段。对实体类有效，可在实体类类型构造函数里面设置</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.AdditionalFields">
            <summary>默认累加字段</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.MasterTime">
            <summary>主时间字段。代表当前数据行更新时间</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Selects">
            <summary>默认选择的字段</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.SelectStat">
            <summary>默认选择统计语句</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Modules">
            <summary>实体模块集合</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.FullInsert">
            <summary>是否完全插入所有字段。false表示不插入没有脏数据的字段，默认true</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.Snow">
            <summary>雪花Id生成器。Int64主键非自增时，自动填充</summary>
        </member>
        <member name="P:XCode.Entity`1.EntityOperate.FlowId">
            <summary>流式Id</summary>
        </member>
        <member name="T:XCode.EntityBase">
            <summary>数据实体基类的基类</summary>
        </member>
        <member name="M:XCode.EntityBase.InitData">
            <summary>首次连接数据库时初始化数据，仅用于实体类重载，用户不应该调用该方法</summary>
        </member>
        <member name="M:XCode.EntityBase.OnLoad">
            <summary>填充数据完成时调用。默认设定标记<see cref="P:XCode.EntityBase.IsFromDatabase"/></summary>
        </member>
        <member name="P:XCode.EntityBase.IsFromDatabase">
            <summary>是否来自数据库。设置相同属性值时不改变脏数据</summary>
        </member>
        <member name="P:XCode.EntityBase.XCode#IEntity#IsFromDatabase">
            <summary>是否来自数据库。设置相同属性值时不改变脏数据</summary>
        </member>
        <member name="M:XCode.EntityBase.Insert">
            <summary>把该对象持久化到数据库</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.Update">
            <summary>更新数据库</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.Delete">
            <summary>从数据库中删除该对象</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.Save">
            <summary>保存。根据主键检查数据库中是否已存在该对象，再决定调用Insert或Update</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.SaveWithoutValid">
            <summary>不需要验证的保存</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.SaveAsync(System.Int32)">
            <summary>异步保存。实现延迟保存，大事务保存。主要面向日志表和频繁更新的在线记录表</summary>
            <param name="msDelay">延迟保存的时间。默认0ms近实时保存</param>
            <returns>是否成功加入异步队列</returns>
        </member>
        <member name="M:XCode.EntityBase.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <remarks>建议重写者调用基类的实现，因为基类根据数据字段的唯一索引进行数据验证。</remarks>
            <param name="isNew">是否新数据</param>
        </member>
        <member name="P:XCode.EntityBase.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.SetItem(System.String,System.Object)">
            <summary>设置字段值，该方法影响脏数据。</summary>
            <param name="name">字段名</param>
            <param name="value">值</param>
            <returns>返回是否成功设置了数据</returns>
        </member>
        <member name="M:XCode.EntityBase.Clone">
            <summary>创建当前对象的克隆对象，仅拷贝基本字段</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.XCode#IEntity#CloneEntity(System.Boolean)">
            <summary>克隆实体。创建当前对象的克隆对象，仅拷贝基本字段</summary>
            <param name="setDirty">是否设置脏数据</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.CloneEntityInternal(System.Boolean)">
            <summary>克隆实体</summary>
            <param name="setDirty"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.CopyFrom(XCode.IEntity,System.Boolean)">
            <summary>复制来自指定实体的成员，可以是不同类型的实体，只复制共有的基本字段，影响脏数据</summary>
            <param name="entity">来源实体对象</param>
            <param name="setDirty">是否设置脏数据</param>
            <returns>实际复制成员数</returns>
        </member>
        <member name="P:XCode.EntityBase.Dirtys">
            <summary>脏属性。存储哪些属性的数据被修改过了。</summary>
        </member>
        <member name="P:XCode.EntityBase.XCode#IEntity#Dirtys">
            <summary>脏属性。存储哪些属性的数据被修改过了。</summary>
        </member>
        <member name="M:XCode.EntityBase.IsDirty(System.String)">
            <summary>是否有脏数据。被修改为不同值</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.XCode#IEntity#IsDirty(System.String)">
            <summary>是否有脏数据。被修改为不同值</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.EntityBase.HasDirty">
            <summary>是否有脏数据。决定是否可以Update</summary>
        </member>
        <member name="P:XCode.EntityBase.XCode#IEntity#HasDirty">
            <summary>是否有脏数据。决定是否可以Update</summary>
        </member>
        <member name="P:XCode.EntityBase.Extends">
            <summary>扩展属性</summary>
        </member>
        <member name="P:XCode.EntityBase.Items">
            <summary>扩展字段。存放未能映射到实体属性的数据库字段</summary>
        </member>
        <member name="P:XCode.EntityBase.NewLife#Data#IExtend2#Keys">
            <summary>扩展数据键集合</summary>
        </member>
        <member name="P:XCode.EntityBase.XCode#IEntity#Addition">
            <summary>累加</summary>
        </member>
        <member name="P:XCode.EntityBase.XCode#IEntity#IsNullKey">
            <summary>主键是否为空</summary>
        </member>
        <member name="P:XCode.EntityBase.IsNullKey">
            <summary>主键是否为空</summary>
        </member>
        <member name="M:XCode.EntityBase.XCode#IEntity#SetNullKey">
            <summary>设置主键为空。Save将调用Insert</summary>
        </member>
        <member name="M:XCode.EntityBase.XCode#IEntity#EqualTo(XCode.IEntity)">
            <summary>判断两个实体是否相等。有可能是同一条数据的两个实体对象</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="E:XCode.EntityBase.PropertyChanging">
            <summary>属性将要改变时</summary>
        </member>
        <member name="E:XCode.EntityBase.PropertyChanged">
            <summary>属性改变事件</summary>
        </member>
        <member name="M:XCode.EntityBase.OnPropertyChanging(System.String,System.Object)">
            <summary>属性改变。重载时记得调用基类的该方法，以设置脏数据属性，否则数据将无法Update到数据库。</summary>
            <param name="fieldName">字段名</param>
            <param name="newValue">新属性值</param>
            <returns>是否允许改变</returns>
        </member>
        <member name="M:XCode.EntityBase.CheckEqual(System.Object,System.Object)">
            <summary>检查相等，主要特殊处理时间相等</summary>
            <param name="v1"></param>
            <param name="v2"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityBase.OnPropertyChanged(System.String)">
            <summary>属性改变。重载时记得调用基类的该方法，以设置脏数据属性，否则数据将无法Update到数据库。</summary>
            <param name="fieldName">字段名</param>
        </member>
        <member name="T:XCode.EntityExtend">
            <summary>实体扩展</summary>
        </member>
        <member name="P:XCode.EntityExtend.Expire">
            <summary>过期时间。单位是秒</summary>
        </member>
        <member name="M:XCode.EntityExtend.#ctor">
            <summary>实例化一个不区分键大小写的实体扩展</summary>
        </member>
        <member name="M:XCode.EntityExtend.Get``1(System.String,System.Func{System.String,``0})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <returns></returns>
        </member>
        <member name="T:XCode.EntityExtend.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="P:XCode.EntityExtend.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:XCode.EntityExtend.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:XCode.EntityExtend.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
        <member name="T:XCode.EntityExtension">
            <summary>实体扩展方法</summary>
        </member>
        <member name="M:XCode.EntityExtension.ToDictionary``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>实体列表转为字典。主键为Key</summary>
            <param name="list">实体列表</param>
            <param name="valueField">作为Value部分的字段，默认为空表示整个实体对象为值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.CreateParameter``1(``0,XCode.IEntitySession)">
            <summary>从实体对象创建参数</summary>
            <typeparam name="T"></typeparam>
            <param name="entity">实体对象</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.CreateParameters``1(System.Collections.Generic.IEnumerable{``0},XCode.IEntitySession)">
            <summary>从实体列表创建参数</summary>
            <param name="list">实体列表</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Insert``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Boolean},XCode.IEntitySession)">
            <summary>把整个集合插入到数据库</summary>
            <param name="list">实体列表</param>
            <param name="useTransition">是否使用事务保护</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Update``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Boolean},XCode.IEntitySession)">
            <summary>把整个集合更新到数据库</summary>
            <param name="list">实体列表</param>
            <param name="useTransition">是否使用事务保护</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Save``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Boolean},XCode.IEntitySession)">
            <summary>把整个保存更新到数据库</summary>
            <param name="list">实体列表</param>
            <param name="useTransition">是否使用事务保护</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.SaveWithoutValid``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Boolean},XCode.IEntitySession)">
            <summary>把整个保存更新到数据库，保存时不需要验证</summary>
            <param name="list">实体列表</param>
            <param name="useTransition">是否使用事务保护</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Delete``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Boolean},XCode.IEntitySession)">
            <summary>把整个集合从数据库中删除</summary>
            <param name="list">实体列表</param>
            <param name="useTransition">是否使用事务保护</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Valid``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>批量验证对象</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="isNew"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.BatchInsert``1(System.Collections.Generic.IEnumerable{``0},XCode.DataAccessLayer.IDataColumn[],XCode.IEntitySession)">
            <summary>批量插入</summary>
            <typeparam name="T">实体类型</typeparam>
            <param name="list">实体列表</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns>
            Oracle：当批量插入操作中有一条记录无法正常写入，则本次写入的所有数据都不会被写入（可以理解为自带事物）
            MySQL：当批量插入操作中有一条记录无法正常写入，则本次写入的所有数据都不会被写入（可以理解为自带事物）
            </returns>
        </member>
        <member name="M:XCode.EntityExtension.BatchUpdate``1(System.Collections.Generic.IEnumerable{``0},XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},XCode.IEntitySession)">
            <summary>批量更新</summary>
            <remarks>
            注意类似：XCode.Exceptions.XSqlException: ORA-00933: SQL 命令未正确结束
            [SQL:Update tablen_Name Set FieldName=:FieldName W [:FieldName=System.Int32[]]][DB:AAA/Oracle]
            建议是优先检查表是否存在主键，如果由于没有主键导致，即使通过try...cache 依旧无法正常保存。
            </remarks>
            <typeparam name="T">实体类型</typeparam>
            <param name="list">实体列表</param>
            <param name="columns">要更新的字段，默认所有字段</param>
            <param name="updateColumns">要更新的字段，默认脏数据</param>
            <param name="addColumns">要累加更新的字段，默认累加</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Upsert``1(System.Collections.Generic.IEnumerable{``0},XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},XCode.IEntitySession)">
            <summary>批量插入或更新</summary>
            <typeparam name="T">实体类型</typeparam>
            <param name="list">实体列表</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="updateColumns">要更新的字段，默认脏数据</param>
            <param name="addColumns">要累加更新的字段，默认累加</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns>
            MySQL返回值：返回值相当于流程执行次数，及时insert失败也会累计一次执行（所以不建议通过该返回值确定操作记录数）
            do insert success = 1次; 
            do update success =2次(insert 1次+update 1次)，
            简单来说：对于一行记录，如果Insert 成功则返回1，如果需要执行的是update 则返回2
            Oracle返回值：无论是插入还是更新返回的都始终为-1
            </returns>
        </member>
        <member name="M:XCode.EntityExtension.Upsert(XCode.IEntity,XCode.DataAccessLayer.IDataColumn[],System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String},XCode.IEntitySession)">
            <summary>批量插入或更新</summary>
            <param name="entity">实体对象</param>
            <param name="columns">要插入的字段，默认所有字段</param>
            <param name="updateColumns">主键已存在时，要更新的字段</param>
            <param name="addColumns">主键已存在时，要累加更新的字段</param>
            <param name="session">指定会话，分表分库时必用</param>
            <returns>
            MySQL返回值：返回值相当于流程执行次数，及时insert失败也会累计一次执行（所以不建议通过该返回值确定操作记录数）
            do insert success = 1次; 
            do update success =2次(insert 1次+update 1次)，
            简单来说：如果Insert 成功则返回1，如果需要执行的是update 则返回2，
            </returns>
        </member>
        <member name="M:XCode.EntityExtension.GetDirtyColumns(XCode.IEntityFactory,System.Collections.Generic.IEnumerable{XCode.IEntity})">
            <summary>获取脏数据列</summary>
            <param name="fact"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.ToTable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>转为DbTable</summary>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Write``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream)">
            <summary>写入数据流</summary>
            <param name="list">实体列表</param>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.SaveFile``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>写入文件，二进制格式</summary>
            <param name="list">实体列表</param>
            <param name="file">文件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.SaveCsv``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,System.String[],System.String[])">
            <summary>写入数据流，Csv格式</summary>
            <param name="list">实体列表</param>
            <param name="stream">数据量</param>
            <param name="fields">要导出的字段列表</param>
            <param name="displayfields">要导出的中文字段列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.SaveCsv``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[],System.String[])">
            <summary>写入文件，Csv格式</summary>
            <param name="list">实体列表</param>
            <param name="file">文件</param>
            <param name="fields">要导出的字段列表</param>
            <param name="displayfields">中文字段列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.SaveCsv``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Boolean)">
            <summary>写入文件，Csv格式</summary>
            <param name="list">实体列表</param>
            <param name="file">文件</param>
            <param name="displayName">是否使用中文显示名，否则使用英文属性名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.Read``1(System.Collections.Generic.IList{``0},System.IO.Stream)">
            <summary>从数据流读取列表</summary>
            <param name="list">实体列表</param>
            <param name="stream">数据流</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.EntityExtension.ReadEnumerable``1(System.Collections.Generic.IList{``0},System.IO.Stream)">
            <summary>从数据流读取列表</summary>
            <param name="list">实体列表</param>
            <param name="stream">数据流</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.EntityExtension.LoadFile``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>从文件读取列表，二进制格式</summary>
            <param name="list">实体列表</param>
            <param name="file">文件</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.EntityExtension.LoadCsv``1(System.Collections.Generic.IList{``0},System.IO.Stream)">
            <summary>从数据流读取列表，Csv格式</summary>
            <param name="list">实体列表</param>
            <param name="stream">数据流</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.EntityExtension.LoadCsv``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>从文件读取列表，Csv格式</summary>
            <param name="list">实体列表</param>
            <param name="file">文件</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.EntityExtension.ToDataTable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>转为DataTable</summary>
            <param name="list">实体列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityExtension.ToDataSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>转为DataSet</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.EntityFactory">
            <summary>实体工厂</summary>
        </member>
        <member name="M:XCode.EntityFactory.CreateOperate(System.Type)">
            <summary>创建实体操作接口</summary>
            <remarks>
            因为只用来做实体操作，所以只需要一个实例即可。
            调用平均耗时3.95ns，57.39%在EnsureInit
            </remarks>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityFactory.AsFactory(System.Type)">
            <summary>根据类型创建实体工厂</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityFactory.Register(System.Type,XCode.IEntityFactory)">
            <summary>使用指定的实体对象创建实体操作接口，主要用于Entity内部调用，避免反射带来的损耗</summary>
            <param name="type">类型</param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityFactory.LoadEntities(System.String)">
            <summary>获取指定连接名下的所有实体类</summary>
            <param name="connName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityFactory.GetTables(System.String,System.Boolean)">
            <summary>获取指定连接名下的初始化时检查的所有实体数据表，用于反向工程检查表架构</summary>
            <param name="connName"></param>
            <param name="checkMode"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.EntityQueue">
            <summary>实体队列</summary>
        </member>
        <member name="P:XCode.EntityQueue.Entities">
            <summary>需要近实时保存的实体队列</summary>
        </member>
        <member name="P:XCode.EntityQueue.DelayEntities">
            <summary>需要延迟保存的实体队列</summary>
        </member>
        <member name="P:XCode.EntityQueue.Debug">
            <summary>调试开关，默认false</summary>
        </member>
        <member name="P:XCode.EntityQueue.Session">
            <summary>数据会话，分表分库时使用</summary>
        </member>
        <member name="P:XCode.EntityQueue.Period">
            <summary>周期。默认1000毫秒，根据繁忙程度动态调节，尽量靠近每次持久化1000个对象</summary>
        </member>
        <member name="P:XCode.EntityQueue.MaxEntity">
            <summary>最大个数，超过该个数时，进入队列将产生堵塞。默认10000</summary>
        </member>
        <member name="P:XCode.EntityQueue.Speed">
            <summary>保存速度，每秒保存多少个实体</summary>
        </member>
        <member name="M:XCode.EntityQueue.#ctor(XCode.IEntitySession)">
            <summary>实例化实体队列</summary>
        </member>
        <member name="M:XCode.EntityQueue.Add(XCode.IEntity,System.Int32)">
            <summary>添加实体对象进入队列</summary>
            <param name="entity">实体对象</param>
            <param name="msDelay">延迟保存的时间</param>
            <returns>返回是否添加成功，实体对象已存在于队列中则返回false</returns>
        </member>
        <member name="F:XCode.EntityQueue._count">
            <summary>当前缓存个数</summary>
        </member>
        <member name="M:XCode.EntityQueue.OnProcess(System.Collections.Generic.IList{XCode.IEntity})">
            <summary>处理一批数据。插入或更新</summary>
            <param name="batch"></param>
        </member>
        <member name="M:XCode.EntityQueue.OnError(System.Collections.Generic.IList{XCode.IEntity},System.Exception)">
            <summary>发生错误</summary>
            <param name="list"></param>
            <param name="ex"></param>
        </member>
        <member name="T:XCode.EntitySession`1">
            <summary>实体会话。每个实体类、连接名和表名形成一个实体会话</summary>
        </member>
        <member name="P:XCode.EntitySession`1.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.EntitySession`1.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Key">
            <summary>用于标识会话的键值</summary>
        </member>
        <member name="M:XCode.EntitySession`1.Create(System.String,System.String)">
            <summary>创建指定表名连接名的会话</summary>
            <param name="connName"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.EntitySession`1.TableItem">
            <summary>表信息</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Dal">
            <summary>数据操作层</summary>
        </member>
        <member name="P:XCode.EntitySession`1.FormatedTableName">
            <summary>已格式化的表名，带有中括号等</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Default">
            <summary>该实体类的默认会话。</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Items">
            <summary>用户数据</summary>
        </member>
        <member name="F:XCode.EntitySession`1.hasCheckInitData">
            <summary>记录已进行数据初始化</summary>
        </member>
        <member name="M:XCode.EntitySession`1.WaitForInitData(System.Int32)">
            <summary>检查并初始化数据。参数等待时间为0表示不等待</summary>
            <param name="ms">等待时间，-1表示不限，0表示不等待</param>
            <returns>如果等待，返回是否收到信号</returns>
        </member>
        <member name="M:XCode.EntitySession`1.CheckModel">
            <summary>检查模型。依据反向工程设置、是否首次使用检查、是否已常规检查等</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Cache">
            <summary>实体缓存</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.EntitySession`1.SingleCache">
            <summary>单对象实体缓存。</summary>
        </member>
        <member name="P:XCode.EntitySession`1.Count">
            <summary>总记录数，小于1000时是精确的，大于1000时缓存10秒</summary>
        </member>
        <member name="F:XCode.EntitySession`1._Count">
            <summary>总记录数较小时，使用静态字段，较大时增加使用Cache</summary>
        </member>
        <member name="P:XCode.EntitySession`1.LongCount">
            <summary>总记录数，小于100w时精确查询，否则取索引行数，缓存60秒</summary>
        </member>
        <member name="M:XCode.EntitySession`1.GetCount(System.Int64)">
            <summary>获取总行数，基于参考值采取不同策略</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.ClearCache(System.String)">
            <summary>清除缓存</summary>
            <param name="reason">清除原因</param>
        </member>
        <member name="M:XCode.EntitySession`1.ClearCache(System.String,System.Boolean)">
            <summary>清除缓存</summary>
            <param name="reason">清除原因</param>
            <param name="force">强制清除，下次访问阻塞等待。默认false仅置为过期，下次访问异步更新</param>
        </member>
        <member name="M:XCode.EntitySession`1.GetDAL(System.Boolean)">
            <summary>获取数据操作对象，根据是否查询以及事务来进行读写分离</summary>
            <param name="read"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.InitData">
            <summary>初始化数据</summary>
        </member>
        <member name="M:XCode.EntitySession`1.Query(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="builder">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.Query(System.String)">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="sql">SQL语句</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.QueryCount(XCode.DataAccessLayer.SelectBuilder)">
            <summary>查询记录数</summary>
            <param name="builder">查询生成器</param>
            <returns>记录数</returns>
        </member>
        <member name="M:XCode.EntitySession`1.QueryCount(System.String)">
            <summary>查询记录数</summary>
            <param name="sql">SQL语句</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.Execute(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>影响的结果</returns>
        </member>
        <member name="M:XCode.EntitySession`1.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="E:XCode.EntitySession`1.OnDataChange">
            <summary>数据改变后触发。参数指定触发该事件的实体类</summary>
        </member>
        <member name="M:XCode.EntitySession`1.Truncate">
            <summary>清空数据表，标识归零</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.BeginTrans">
            <summary>开始事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.EntitySession`1.Commit">
            <summary>提交事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.EntitySession`1.Rollback">
            <summary>回滚事务，忽略异常</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.EntitySession`1.CreateTrans">
            <summary>创建事务</summary>
        </member>
        <member name="M:XCode.EntitySession`1.Insert(XCode.IEntity)">
            <summary>把该对象持久化到数据库，添加/更新实体缓存和单对象缓存，增加总计数</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.Update(XCode.IEntity)">
            <summary>更新数据库，同时更新实体缓存</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntitySession`1.Delete(XCode.IEntity)">
            <summary>从数据库中删除该对象，同时从实体缓存和单对象缓存中删除，扣减总数量</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="P:XCode.EntitySession`1.Queue">
            <summary>实体队列</summary>
        </member>
        <member name="T:XCode.EntitySplit">
            <summary>实体分表分库</summary>
        </member>
        <member name="M:XCode.EntitySplit.Split``1(XCode.IEntityFactory,System.String,System.String,System.Func{``0})">
            <summary>在分库上执行操作，自动还原</summary>
            <param name="factory"></param>
            <param name="connName"></param>
            <param name="tableName"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.EntitySplit.SplitPackge.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="P:XCode.EntitySplit.SplitPackge.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.EntitySplit.SplitPackge.TableName">
            <summary>表名</summary>
        </member>
        <member name="T:XCode.EntityTransaction`1">
            <summary>实体事务区域。配合using使用，进入区域事务即开始，直到<see cref="M:XCode.EntityTransaction.Commit"/>提交，否则离开区域时回滚。</summary>
            <typeparam name="TEntity"></typeparam>
            <example>
            <code>
            using (var et = new EntityTransaction&lt;Administrator&gt;())
            {
                var admin = Administrator.FindByName("admin");
                admin.Logins++;
                admin.Update();
            
                et.Commit();
            }
            </code>
            </example>
        </member>
        <member name="M:XCode.EntityTransaction`1.#ctor">
            <summary>为实体类实例化一个事务区域</summary>
        </member>
        <member name="M:XCode.EntityTransaction`1.Commit">
            <summary>提交事务</summary>
        </member>
        <member name="M:XCode.EntityTransaction`1.Rollback">
            <summary>回滚事务</summary>
        </member>
        <member name="T:XCode.EntityTransaction">
            <summary>实体事务区域。配合using使用，进入区域事务即开始，直到<see cref="M:XCode.EntityTransaction.Commit"/>提交，否则离开区域时回滚。</summary>
            <example>
            <code>
            using (var et = new EntityTransaction(DAL.Create("Common")))
            {
                var admin = Administrator.FindByName("admin");
                admin.Logins++;
                admin.Update();
            
                et.Commit();
            }
            </code>
            </example>
        </member>
        <member name="F:XCode.EntityTransaction.hasStart">
            <summary>是否已经开始事务</summary>
        </member>
        <member name="F:XCode.EntityTransaction.hasFinish">
            <summary>是否已完成事务</summary>
        </member>
        <member name="P:XCode.EntityTransaction.Session">
            <summary>会话</summary>
        </member>
        <member name="M:XCode.EntityTransaction.#ctor(XCode.DataAccessLayer.IDbSession,System.Data.IsolationLevel)">
            <summary>用数据库会话来实例化一个事务区域</summary>
            <param name="session"></param>
            <param name="level">事务隔离等级</param>
        </member>
        <member name="M:XCode.EntityTransaction.#ctor(XCode.DataAccessLayer.DAL)">
            <summary>用数据访问对象来实例化一个事务区域</summary>
            <param name="dal"></param>
        </member>
        <member name="M:XCode.EntityTransaction.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:XCode.EntityTransaction.Commit">
            <summary>提交事务</summary>
        </member>
        <member name="M:XCode.EntityTransaction.Rollback">
            <summary>回滚事务</summary>
        </member>
        <member name="T:XCode.IEntity">
            <summary>数据实体接口</summary>
        </member>
        <member name="P:XCode.IEntity.Dirtys">
            <summary>脏属性。存储哪些属性的数据被修改过了。</summary>
        </member>
        <member name="P:XCode.IEntity.HasDirty">
            <summary>是否有脏数据</summary>
        </member>
        <member name="P:XCode.IEntity.Extends">
            <summary>扩展属性</summary>
        </member>
        <member name="P:XCode.IEntity.IsFromDatabase">
            <summary>是否来自数据库。设置相同属性值时不改变脏数据</summary>
        </member>
        <member name="P:XCode.IEntity.Addition">
            <summary>累加</summary>
        </member>
        <member name="P:XCode.IEntity.IsNullKey">
            <summary>主键是否为空</summary>
        </member>
        <member name="M:XCode.IEntity.SetNullKey">
            <summary>设置主键为空。Save将调用Insert</summary>
        </member>
        <member name="M:XCode.IEntity.IsDirty(System.String)">
            <summary>指定字段是否有脏数据。被修改为不同值</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.Insert">
            <summary>添加</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.Update">
            <summary>更新</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.Delete">
            <summary>删除</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.Save">
            <summary>保存。根据主键检查数据库中是否已存在该对象，再决定调用Insert或Update</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.SaveWithoutValid">
            <summary>不需要验证的保存，不执行Valid，一般用于快速导入数据</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.SaveAsync(System.Int32)">
            <summary>异步保存。实现延迟保存，大事务保存。主要面向日志表和频繁更新的在线记录表</summary>
            <param name="msDelay">延迟保存的时间。默认0ms近实时保存</param>
            <returns>是否成功加入异步队列</returns>
        </member>
        <member name="M:XCode.IEntity.SetItem(System.String,System.Object)">
            <summary>设置字段值</summary>
            <param name="name">字段名</param>
            <param name="value">值</param>
            <returns>返回是否成功设置了数据</returns>
        </member>
        <member name="M:XCode.IEntity.CloneEntity(System.Boolean)">
            <summary>克隆实体。创建当前对象的克隆对象，仅拷贝基本字段</summary>
            <param name="setDirty">是否设置脏数据</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntity.CopyFrom(XCode.IEntity,System.Boolean)">
            <summary>复制来自指定实体的成员，可以是不同类型的实体，只复制共有的基本字段，影响脏数据</summary>
            <param name="entity">来源实体对象</param>
            <param name="setDirty">是否设置脏数据</param>
            <returns>实际复制成员数</returns>
        </member>
        <member name="M:XCode.IEntity.EqualTo(XCode.IEntity)">
            <summary>判断两个实体是否相等。有可能是同一条数据的两个实体对象</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.IEntityAddition">
            <summary>实体累加接口。实现Count=Count+123的效果</summary>
        </member>
        <member name="P:XCode.IEntityAddition.Entity">
            <summary>实体对象</summary>
        </member>
        <member name="M:XCode.IEntityAddition.Set(System.Collections.Generic.IEnumerable{System.String})">
            <summary>设置累加字段</summary>
            <param name="names">字段集合</param>
        </member>
        <member name="M:XCode.IEntityAddition.Get">
            <summary>获取快照</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityAddition.Reset(System.Collections.Generic.IDictionary{System.String,System.Object[]})">
            <summary>使用快照重置</summary>
            <param name="value"></param>
        </member>
        <member name="T:XCode.EntityAddition">
            <summary>实体累加接口。实现Count+=1的效果</summary>
        </member>
        <member name="P:XCode.EntityAddition.Entity">
            <summary>实体对象</summary>
        </member>
        <member name="M:XCode.EntityAddition.Set(System.Collections.Generic.IEnumerable{System.String})">
            <summary>设置累加字段</summary>
            <param name="names">字段集合</param>
        </member>
        <member name="M:XCode.EntityAddition.Get">
            <summary>获取累加备份</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityAddition.Reset(System.Collections.Generic.IDictionary{System.String,System.Object[]})">
            <summary>重置累加备份</summary>
            <param name="dfs"></param>
        </member>
        <member name="M:XCode.EntityAddition.SetField(System.Collections.Generic.IEnumerable{XCode.IEntity})">
            <summary>设置累加备份</summary>
            <param name="list"></param>
        </member>
        <member name="M:XCode.EntityAddition.SetField(XCode.IEntity)">
            <summary>设置累加备份</summary>
            <param name="entity"></param>
        </member>
        <member name="T:XCode.IEntityModule">
            <summary>实体处理模块</summary>
        </member>
        <member name="M:XCode.IEntityModule.Init(System.Type)">
            <summary>为指定实体类初始化模块，返回是否支持</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityModule.Create(XCode.IEntity,System.Boolean)">
            <summary>创建实体对象</summary>
            <param name="entity"></param>
            <param name="forEdit"></param>
        </member>
        <member name="M:XCode.IEntityModule.Valid(XCode.IEntity,System.Boolean)">
            <summary>验证实体对象</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityModule.Delete(XCode.IEntity)">
            <summary>删除实体对象</summary>
            <param name="entity"></param>
        </member>
        <member name="T:XCode.EntityModules">
            <summary>实体模块集合</summary>
        </member>
        <member name="P:XCode.EntityModules.Global">
            <summary></summary>
        </member>
        <member name="P:XCode.EntityModules.EntityType">
            <summary>实体类型</summary>
        </member>
        <member name="P:XCode.EntityModules.Modules">
            <summary>模块集合</summary>
        </member>
        <member name="M:XCode.EntityModules.#ctor(System.Type)">
            <summary>实例化实体模块集合</summary>
            <param name="entityType"></param>
        </member>
        <member name="M:XCode.EntityModules.Add(XCode.IEntityModule)">
            <summary>添加实体模块</summary>
            <param name="module"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModules.Add``1">
            <summary>添加实体模块</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModules.Create(XCode.IEntity,System.Boolean)">
            <summary>创建实体时执行模块</summary>
            <param name="entity"></param>
            <param name="forEdit"></param>
        </member>
        <member name="M:XCode.EntityModules.Valid(XCode.IEntity,System.Boolean)">
            <summary>添加更新实体时验证</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModules.Delete(XCode.IEntity)">
            <summary>删除实体对象</summary>
            <param name="entity"></param>
        </member>
        <member name="T:XCode.EntityModule">
            <summary>实体模块基类</summary>
        </member>
        <member name="M:XCode.EntityModule.Init(System.Type)">
            <summary>为指定实体类初始化模块，返回是否支持</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModule.OnInit(System.Type)">
            <summary>为指定实体类初始化模块，返回是否支持</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModule.Create(XCode.IEntity,System.Boolean)">
            <summary>创建实体对象</summary>
            <param name="entity"></param>
            <param name="forEdit"></param>
        </member>
        <member name="M:XCode.EntityModule.OnCreate(XCode.IEntity,System.Boolean)">
            <summary>创建实体对象</summary>
            <param name="entity"></param>
            <param name="forEdit"></param>
        </member>
        <member name="M:XCode.EntityModule.Valid(XCode.IEntity,System.Boolean)">
            <summary>验证实体对象</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModule.OnValid(XCode.IEntity,System.Boolean)">
            <summary>验证实体对象</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModule.Delete(XCode.IEntity)">
            <summary>删除实体对象</summary>
            <param name="entity"></param>
        </member>
        <member name="M:XCode.EntityModule.OnDelete(XCode.IEntity)">
            <summary>删除实体对象</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityModule.SetNoDirtyItem(System.Collections.Generic.ICollection{XCode.Configuration.FieldItem},XCode.IEntity,System.String,System.Object)">
            <summary>设置脏数据项。如果某个键存在并且数据没有脏，则设置</summary>
            <param name="fields"></param>
            <param name="entity"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns>返回是否成功设置了数据</returns>
        </member>
        <member name="M:XCode.EntityModule.SetItem(System.Collections.Generic.ICollection{XCode.Configuration.FieldItem},XCode.IEntity,System.String,System.Object)">
            <summary>如果是默认值则覆盖，无视脏数据，此时很可能是新增</summary>
            <param name="fields"></param>
            <param name="entity"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns>返回是否成功设置了数据</returns>
        </member>
        <member name="M:XCode.EntityModule.GetFields(System.Type)">
            <summary>获取实体类的字段名。带缓存</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.IEntityOperate">
            <summary>数据实体操作接口</summary>
        </member>
        <member name="T:XCode.IEntityFactory">
            <summary>数据实体操作接口</summary>
        </member>
        <member name="P:XCode.IEntityFactory.EntityType">
            <summary>实体类型</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Session">
            <summary>实体会话</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Persistence">
            <summary>实体持久化</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Accessor">
            <summary>数据行访问器，把数据行映射到实体类</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Default">
            <summary>默认实体</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Table">
            <summary>数据表元数据</summary>
        </member>
        <member name="P:XCode.IEntityFactory.AllFields">
            <summary>所有数据属性</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Fields">
            <summary>所有绑定到数据表的属性</summary>
        </member>
        <member name="P:XCode.IEntityFactory.FieldNames">
            <summary>字段名集合，不区分大小写的哈希表存储，外部不要修改元素数据</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Unique">
            <summary>唯一键，返回第一个标识列或者唯一的主键</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Master">
            <summary>主字段。主字段作为业务主要字段，代表当前数据行意义</summary>
        </member>
        <member name="P:XCode.IEntityFactory.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.IEntityFactory.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Count">
            <summary>总记录数</summary>
        </member>
        <member name="M:XCode.IEntityFactory.Create(System.Boolean)">
            <summary>创建一个实体对象</summary>
            <param name="forEdit">是否为了编辑而创建，如果是，可以再次做一些相关的初始化工作</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.LoadData(System.Data.DataSet)">
            <summary>加载记录集</summary>
            <param name="ds">记录集</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.IEntityFactory.Find(System.String,System.Object)">
            <summary>根据属性以及对应的值，查找单个实体</summary>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.Find(XCode.Expression)">
            <summary>根据条件查找单个实体</summary>
            <param name="where"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindByKey(System.Object)">
            <summary>根据主键查找单个实体</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindByKeyForEdit(System.Object)">
            <summary>根据主键查询一个实体对象用于表单编辑</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindAll">
            <summary>获取所有实体对象。获取大量数据时会非常慢，慎用</summary>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindAll(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>
            查询并返回实体对象集合。
            表名以及所有字段名，请使用类名以及字段对应的属性名，方法内转换为表名和列名
            </summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindAll(XCode.Expression,System.String,System.String,System.Int64,System.Int64)">
            <summary>
            查询并返回实体对象集合。
            表名以及所有字段名，请使用类名以及字段对应的属性名，方法内转换为表名和列名
            </summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>实体数组</returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindAllWithCache">
            <summary>查找所有缓存</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindCount">
            <summary>返回总记录数</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindCount(System.String,System.String,System.String,System.Int64,System.Int64)">
            <summary>返回总记录数</summary>
            <param name="where">条件，不带Where</param>
            <param name="order">排序，不带Order By</param>
            <param name="selects">查询列</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns>总行数</returns>
        </member>
        <member name="M:XCode.IEntityFactory.FindCount(XCode.Expression)">
            <summary>返回总记录数</summary>
            <param name="where">条件，不带Where</param>
            <returns>总行数</returns>
        </member>
        <member name="M:XCode.IEntityFactory.GetOrAdd``1(``0,System.Func{``0,System.Boolean,XCode.IEntity},System.Func{``0,XCode.IEntity})">
            <summary>获取 或 新增 对象，常用于统计等高并发更新的情况，一般配合SaveAsync</summary>
            <typeparam name="TKey"></typeparam>
            <param name="key">业务主键</param>
            <param name="find">查找函数</param>
            <param name="create">创建对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityFactory.CreateTrans">
            <summary>创建事务</summary>
        </member>
        <member name="P:XCode.IEntityFactory.AutoIdentity">
            <summary>是否自增获取自增返回值。默认启用</summary>
        </member>
        <member name="P:XCode.IEntityFactory.AllowInsertIdentity">
            <summary>是否允许向自增列插入数据。为免冲突，仅本线程有效</summary>
        </member>
        <member name="P:XCode.IEntityFactory.AutoSetGuidField">
            <summary>自动设置Guid的字段。对实体类有效，可在实体类类型构造函数里面设置</summary>
        </member>
        <member name="P:XCode.IEntityFactory.AdditionalFields">
            <summary>默认累加字段</summary>
        </member>
        <member name="P:XCode.IEntityFactory.MasterTime">
            <summary>主时间字段。代表当前数据行更新时间</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Selects">
            <summary>默认选择的字段</summary>
        </member>
        <member name="P:XCode.IEntityFactory.SelectStat">
            <summary>默认选择统计语句</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Modules">
            <summary>实体模块集合</summary>
        </member>
        <member name="P:XCode.IEntityFactory.FullInsert">
            <summary>是否完全插入所有字段。false表示不插入没有脏数据的字段，默认true</summary>
        </member>
        <member name="P:XCode.IEntityFactory.Snow">
            <summary>雪花Id生成器。Int64主键非自增时，自动填充</summary>
        </member>
        <member name="P:XCode.IEntityFactory.FlowId">
            <summary>流式Id</summary>
        </member>
        <member name="T:XCode.IEntityPersistence">
            <summary>实体持久化接口。可通过实现该接口来自定义实体类持久化行为。</summary>
        </member>
        <member name="P:XCode.IEntityPersistence.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="M:XCode.IEntityPersistence.Insert(XCode.IEntitySession,XCode.IEntity)">
            <summary>插入</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Update(XCode.IEntitySession,XCode.IEntity)">
            <summary>更新</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Delete(XCode.IEntitySession,XCode.IEntity)">
            <summary>删除</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Insert(XCode.IEntitySession,System.String[],System.Object[])">
            <summary>把一个实体对象持久化到数据库</summary>
            <param name="session">实体会话</param>
            <param name="names">更新属性列表</param>
            <param name="values">更新值列表</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Update(XCode.IEntitySession,System.String,System.String)">
            <summary>更新一批实体数据</summary>
            <param name="session">实体会话</param>
            <param name="setClause">要更新的项和数据</param>
            <param name="whereClause">指定要更新的实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Update(XCode.IEntitySession,System.String[],System.Object[],System.String[],System.Object[])">
            <summary>更新一批实体数据</summary>
            <param name="session">实体会话</param>
            <param name="setNames">更新属性列表</param>
            <param name="setValues">更新值列表</param>
            <param name="whereNames">条件属性列表</param>
            <param name="whereValues">条件值列表</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Delete(XCode.IEntitySession,System.String)">
            <summary>从数据库中删除指定条件的实体对象。</summary>
            <param name="session">实体会话</param>
            <param name="whereClause">限制条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.Delete(XCode.IEntitySession,System.String[],System.Object[])">
            <summary>从数据库中删除指定属性列表和值列表所限定的实体对象。</summary>
            <param name="session">实体会话</param>
            <param name="names">属性列表</param>
            <param name="values">值列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.GetPrimaryCondition(XCode.IEntity)">
            <summary>获取主键条件</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntityPersistence.GetSql(XCode.IEntitySession,XCode.IEntity,System.ComponentModel.DataObjectMethodType)">
            <summary>把SQL模版格式化为SQL语句</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体对象</param>
            <param name="methodType"></param>
            <returns>SQL字符串</returns>
        </member>
        <member name="M:XCode.IEntityPersistence.InsertSQL(XCode.IEntitySession)">
            <summary>插入语句</summary>
            <param name="session">实体会话</param>
            <returns></returns>
        </member>
        <member name="T:XCode.EntityPersistence">
            <summary>默认实体持久化</summary>
        </member>
        <member name="P:XCode.EntityPersistence.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="M:XCode.EntityPersistence.Insert(XCode.IEntitySession,XCode.IEntity)">
            <summary>插入</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.Update(XCode.IEntitySession,XCode.IEntity)">
            <summary>更新</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.Delete(XCode.IEntitySession,XCode.IEntity)">
            <summary>删除</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.Insert(XCode.IEntitySession,System.String[],System.Object[])">
            <summary>把一个实体对象持久化到数据库</summary>
            <param name="session">实体会话</param>
            <param name="names">更新属性列表</param>
            <param name="values">更新值列表</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.EntityPersistence.Update(XCode.IEntitySession,System.String,System.String)">
            <summary>更新一批实体数据</summary>
            <param name="session">实体会话</param>
            <param name="setClause">要更新的项和数据</param>
            <param name="whereClause">指定要更新的实体</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.Update(XCode.IEntitySession,System.String[],System.Object[],System.String[],System.Object[])">
            <summary>更新一批实体数据</summary>
            <param name="session">实体会话</param>
            <param name="setNames">更新属性列表</param>
            <param name="setValues">更新值列表</param>
            <param name="whereNames">条件属性列表</param>
            <param name="whereValues">条件值列表</param>
            <returns>返回受影响的行数</returns>
        </member>
        <member name="M:XCode.EntityPersistence.Delete(XCode.IEntitySession,System.String)">
            <summary>从数据库中删除指定条件的实体对象。</summary>
            <param name="session">实体会话</param>
            <param name="whereClause">限制条件</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.Delete(XCode.IEntitySession,System.String[],System.Object[])">
            <summary>从数据库中删除指定属性列表和值列表所限定的实体对象。</summary>
            <param name="session">实体会话</param>
            <param name="names">属性列表</param>
            <param name="values">值列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.GetSql(XCode.IEntitySession,XCode.IEntity,System.ComponentModel.DataObjectMethodType)">
            <summary>把SQL模版格式化为SQL语句</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体对象</param>
            <param name="methodType"></param>
            <returns>SQL字符串</returns>
        </member>
        <member name="M:XCode.EntityPersistence.SQL(XCode.IEntitySession,XCode.IEntity,System.ComponentModel.DataObjectMethodType,System.Data.IDataParameter[]@)">
            <summary>把SQL模版格式化为SQL语句</summary>
            <param name="session">实体会话</param>
            <param name="entity">实体对象</param>
            <param name="methodType"></param>
            <param name="parameters">参数数组</param>
            <returns>SQL字符串</returns>
        </member>
        <member name="M:XCode.EntityPersistence.GetPrimaryCondition(XCode.IEntity)">
            <summary>获取主键条件</summary>
            <remarks>
            若有标识列，则使用一个标识列作为条件；
            如有主键，则使用全部主键作为条件。
            </remarks>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityPersistence.InsertSQL(XCode.IEntitySession)">
            <summary>插入语句</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.IEntitySession">
            <summary>实体会话接口</summary>
        </member>
        <member name="P:XCode.IEntitySession.ConnName">
            <summary>连接名</summary>
        </member>
        <member name="P:XCode.IEntitySession.TableName">
            <summary>表名</summary>
        </member>
        <member name="P:XCode.IEntitySession.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:XCode.IEntitySession.Key">
            <summary>用于标识会话的键值</summary>
        </member>
        <member name="P:XCode.IEntitySession.FormatedTableName">
            <summary>已格式化的表名，带有中括号等</summary>
        </member>
        <member name="P:XCode.IEntitySession.Dal">
            <summary>数据操作层</summary>
        </member>
        <member name="P:XCode.IEntitySession.Items">
            <summary>用户数据</summary>
        </member>
        <member name="M:XCode.IEntitySession.WaitForInitData(System.Int32)">
            <summary>检查并初始化数据。参数等待时间为0表示不等待</summary>
            <param name="ms">等待时间，-1表示不限，0表示不等待</param>
            <returns>如果等待，返回是否收到信号</returns>
        </member>
        <member name="P:XCode.IEntitySession.Cache">
            <summary>实体缓存</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.IEntitySession.SingleCache">
            <summary>单对象实体缓存。
            建议自定义查询数据方法，并从二级缓存中获取实体数据，以抵消因初次填充而带来的消耗。
            </summary>
        </member>
        <member name="P:XCode.IEntitySession.Count">
            <summary>总记录数，小于1000时是精确的，大于1000时缓存10分钟</summary>
        </member>
        <member name="P:XCode.IEntitySession.LongCount">
            <summary>总记录数，小于1000时是精确的，大于1000时缓存10分钟</summary>
            <remarks>
            1，检查静态字段，如果有数据且小于1000，直接返回，否则=>3
            2，如果有数据但大于1000，则返回缓存里面的有效数据
            3，来到这里，有可能是第一次访问，静态字段没有缓存，也有可能是大于1000的缓存过期
            4，检查模型
            5，根据需要查询数据
            6，如果大于1000，缓存数据
            7，检查数据初始化
            </remarks>
        </member>
        <member name="M:XCode.IEntitySession.ClearCache(System.String)">
            <summary>清除缓存</summary>
            <param name="reason">清除原因</param>
        </member>
        <member name="M:XCode.IEntitySession.ClearCache(System.String,System.Boolean)">
            <summary>清除缓存</summary>
            <param name="reason">清除原因</param>
            <param name="force">强制清除，下次访问阻塞等待。默认false仅置为过期，下次访问异步更新</param>
        </member>
        <member name="M:XCode.IEntitySession.InitData">
            <summary>初始化数据</summary>
        </member>
        <member name="M:XCode.IEntitySession.Query(XCode.DataAccessLayer.SelectBuilder,System.Int64,System.Int64)">
            <summary>执行SQL查询，返回记录集</summary>
            <param name="builder">SQL语句</param>
            <param name="startRowIndex">开始行，0表示第一行</param>
            <param name="maximumRows">最大返回行数，0表示所有行</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntitySession.QueryCount(XCode.DataAccessLayer.SelectBuilder)">
            <summary>查询记录数</summary>
            <param name="builder">查询生成器</param>
            <returns>记录数</returns>
        </member>
        <member name="M:XCode.IEntitySession.Execute(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>影响的结果</returns>
        </member>
        <member name="M:XCode.IEntitySession.InsertAndGetIdentity(System.String,System.Data.CommandType,System.Data.IDataParameter[])">
            <summary>执行插入语句并返回新增行的自动编号</summary>
            <param name="sql">SQL语句</param>
            <param name="type">命令类型，默认SQL文本</param>
            <param name="ps">命令参数</param>
            <returns>新增行的自动编号</returns>
        </member>
        <member name="M:XCode.IEntitySession.Truncate">
            <summary>执行Truncate语句</summary>
            <returns>影响的结果</returns>
        </member>
        <member name="E:XCode.IEntitySession.OnDataChange">
            <summary>数据改变后触发。参数指定触发该事件的实体类</summary>
        </member>
        <member name="M:XCode.IEntitySession.BeginTrans">
            <summary>开始事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.IEntitySession.Commit">
            <summary>提交事务</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.IEntitySession.Rollback">
            <summary>回滚事务，忽略异常</summary>
            <returns>剩下的事务计数</returns>
        </member>
        <member name="M:XCode.IEntitySession.CreateTrans">
            <summary>创建事务</summary>
        </member>
        <member name="M:XCode.IEntitySession.Insert(XCode.IEntity)">
            <summary>把该对象持久化到数据库，添加/更新实体缓存。</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntitySession.Update(XCode.IEntity)">
            <summary>更新数据库，同时更新实体缓存</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.IEntitySession.Delete(XCode.IEntity)">
            <summary>从数据库中删除该对象，同时从实体缓存中删除</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="T:XCode.EntityException">
            <summary>实体异常</summary>
        </member>
        <member name="M:XCode.EntityException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:XCode.EntityException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:XCode.EntityException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:XCode.EntityException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.EntityException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:XCode.XCodeException">
            <summary>XCode异常</summary>
        </member>
        <member name="M:XCode.XCodeException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:XCode.XCodeException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:XCode.XCodeException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:XCode.XCodeException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.XCodeException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:XCode.Exceptions.XDbException">
            <summary>数据访问层异常</summary>
        </member>
        <member name="P:XCode.Exceptions.XDbException.Database">
            <summary>数据库</summary>
        </member>
        <member name="M:XCode.Exceptions.XDbException.#ctor(XCode.DataAccessLayer.IDatabase)">
            <summary>初始化</summary>
            <param name="db"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbException.#ctor(XCode.DataAccessLayer.IDatabase,System.String)">
            <summary>初始化</summary>
            <param name="db"></param>
            <param name="message"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbException.#ctor(XCode.DataAccessLayer.IDatabase,System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="db"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbException.#ctor(XCode.DataAccessLayer.IDatabase,System.Exception)">
            <summary>初始化</summary>
            <param name="db"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:XCode.Exceptions.XDbMetaDataException">
            <summary>数据库元数据异常</summary>
        </member>
        <member name="P:XCode.Exceptions.XDbMetaDataException.MetaData">
            <summary>数据库元数据</summary>
        </member>
        <member name="M:XCode.Exceptions.XDbMetaDataException.#ctor(XCode.DataAccessLayer.IMetaData)">
            <summary>初始化</summary>
            <param name="metadata"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbMetaDataException.#ctor(XCode.DataAccessLayer.IMetaData,System.String)">
            <summary>初始化</summary>
            <param name="metadata"></param>
            <param name="message"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbMetaDataException.#ctor(XCode.DataAccessLayer.IMetaData,System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="metadata"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbMetaDataException.#ctor(XCode.DataAccessLayer.IMetaData,System.Exception)">
            <summary>初始化</summary>
            <param name="metadata"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:XCode.Exceptions.XDbSessionException">
            <summary>数据访问层异常</summary>
        </member>
        <member name="P:XCode.Exceptions.XDbSessionException.Session">
            <summary>数据库会话</summary>
        </member>
        <member name="M:XCode.Exceptions.XDbSessionException.#ctor(XCode.DataAccessLayer.IDbSession)">
            <summary>初始化</summary>
            <param name="session"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbSessionException.#ctor(XCode.DataAccessLayer.IDbSession,System.String)">
            <summary>初始化</summary>
            <param name="session"></param>
            <param name="message"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbSessionException.#ctor(XCode.DataAccessLayer.IDbSession,System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="session"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.Exceptions.XDbSessionException.#ctor(XCode.DataAccessLayer.IDbSession,System.Exception)">
            <summary>初始化</summary>
            <param name="session"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:XCode.Exceptions.XSqlException">
            <summary>数据访问层SQL异常</summary>
        </member>
        <member name="P:XCode.Exceptions.XSqlException.Sql">
            <summary>SQL语句</summary>
        </member>
        <member name="M:XCode.Exceptions.XSqlException.#ctor(System.String,XCode.DataAccessLayer.IDbSession)">
            <summary>初始化</summary>
            <param name="sql"></param>
            <param name="session"></param>
        </member>
        <member name="M:XCode.Exceptions.XSqlException.#ctor(System.String,XCode.DataAccessLayer.IDbSession,System.String)">
            <summary>初始化</summary>
            <param name="sql"></param>
            <param name="session"></param>
            <param name="message"></param>
        </member>
        <member name="M:XCode.Exceptions.XSqlException.#ctor(System.String,XCode.DataAccessLayer.IDbSession,System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="sql"></param>
            <param name="session"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.Exceptions.XSqlException.#ctor(System.String,XCode.DataAccessLayer.IDbSession,System.Exception)">
            <summary>初始化</summary>
            <param name="sql"></param>
            <param name="session"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:XCode.Exceptions.XSqlException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>从序列化信息中读取Sql</summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:XCode.Extension.MyDbCache">
            <summary>数据缓存</summary>
            <summary>数据缓存</summary>
        </member>
        <member name="M:XCode.Extension.MyDbCache.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew">是否插入</param>
        </member>
        <member name="M:XCode.Extension.MyDbCache.FindByName(System.String)">
            <summary>根据名称查找</summary>
            <param name="name">名称</param>
            <returns>实体对象</returns>
        </member>
        <member name="P:XCode.Extension.MyDbCache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Extension.MyDbCache.Value">
            <summary>键值</summary>
        </member>
        <member name="P:XCode.Extension.MyDbCache.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Extension.MyDbCache.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:XCode.Extension.MyDbCache.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Extension.MyDbCache._">
            <summary>取得数据缓存字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache._.Value">
            <summary>键值</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache._.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="T:XCode.Extension.MyDbCache.__">
            <summary>取得数据缓存字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache.__.Value">
            <summary>键值</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Extension.MyDbCache.__.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="T:XCode.Extension.IMyDbCache">
            <summary>数据缓存接口</summary>
        </member>
        <member name="P:XCode.Extension.IMyDbCache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Extension.IMyDbCache.Value">
            <summary>键值</summary>
        </member>
        <member name="P:XCode.Extension.IMyDbCache.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Extension.IMyDbCache.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:XCode.Extension.IMyDbCache.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.IManageProvider">
            <summary>管理提供者接口</summary>
            <remarks>
            管理提供者接口主要提供（或统一规范）用户提供者定位、用户查找登录等功能。
            只需要一个实现IManageUser接口的用户类即可实现IManageProvider接口。
            IManageProvider足够精简，使得大多数用户可以自定义实现；
            也因为其简单稳定，大多数需要涉及用户与权限功能的操作，均可以直接使用该接口。
            </remarks>
        </member>
        <member name="P:XCode.Membership.IManageProvider.Current">
            <summary>当前登录用户，设为空则注销登录</summary>
        </member>
        <member name="M:XCode.Membership.IManageProvider.GetCurrent(System.IServiceProvider)">
            <summary>获取当前用户</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IManageProvider.SetCurrent(NewLife.Model.IManageUser,System.IServiceProvider)">
            <summary>设置当前用户</summary>
            <param name="user"></param>
            <param name="context"></param>
        </member>
        <member name="M:XCode.Membership.IManageProvider.FindByID(System.Object)">
            <summary>根据用户编号查找</summary>
            <param name="userid"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IManageProvider.FindByName(System.String)">
            <summary>根据用户帐号查找</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IManageProvider.Login(System.String,System.String,System.Boolean)">
            <summary>登录</summary>
            <param name="name"></param>
            <param name="password"></param>
            <param name="rememberme">是否记住密码</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IManageProvider.Logout">
            <summary>注销</summary>
        </member>
        <member name="M:XCode.Membership.IManageProvider.Register(System.String,System.String,System.Int32,System.Boolean)">
            <summary>注册用户</summary>
            <param name="name">用户名</param>
            <param name="password">密码</param>
            <param name="roleid">角色</param>
            <param name="enable">是否启用</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IManageProvider.GetService``1">
            <summary>获取服务</summary>
            <remarks>
            其实IServiceProvider有该扩展方法，但是在FX2里面不方面使用，所以这里保留
            </remarks>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.ManageProvider">
            <summary>管理提供者</summary>
        </member>
        <member name="P:XCode.Membership.ManageProvider.Provider">
            <summary>当前管理提供者</summary>
        </member>
        <member name="P:XCode.Membership.ManageProvider.User">
            <summary>当前登录用户</summary>
        </member>
        <member name="P:XCode.Membership.ManageProvider.Menu">
            <summary>菜单工厂</summary>
        </member>
        <member name="P:XCode.Membership.ManageProvider.UserHost">
            <summary>用户主机</summary>
        </member>
        <member name="P:XCode.Membership.ManageProvider.Current">
            <summary>当前用户</summary>
        </member>
        <member name="M:XCode.Membership.ManageProvider.GetCurrent(System.IServiceProvider)">
            <summary>获取当前用户</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.SetCurrent(NewLife.Model.IManageUser,System.IServiceProvider)">
            <summary>设置当前用户</summary>
            <param name="user"></param>
            <param name="context"></param>
        </member>
        <member name="M:XCode.Membership.ManageProvider.FindByID(System.Object)">
            <summary>根据用户编号查找</summary>
            <param name="userid"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.FindByName(System.String)">
            <summary>根据用户帐号查找</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.Login(System.String,System.String,System.Boolean)">
            <summary>登录</summary>
            <param name="name"></param>
            <param name="password"></param>
            <param name="rememberme">是否记住密码</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.Logout">
            <summary>注销</summary>
        </member>
        <member name="M:XCode.Membership.ManageProvider.Register(System.String,System.String,System.Int32,System.Boolean)">
            <summary>注册用户</summary>
            <param name="name">用户名</param>
            <param name="password">密码</param>
            <param name="roleid">角色</param>
            <param name="enable">是否启用。某些系统可能需要验证审核</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.GetService``1">
            <summary>获取服务</summary>
            <typeparam name="TService"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.GetService(System.Type)">
            <summary>获取服务</summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ManageProvider.GetFactory``1">
            <summary>根据实体类接口获取实体工厂</summary>
            <typeparam name="TIEntity"></typeparam>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.LogEntity`1">
            <summary>日志实体类基类</summary>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="M:XCode.Membership.LogEntity`1.Insert">
            <summary>添加时写日志</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.LogEntity`1.Update">
            <summary>修改时写日志</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.LogEntity`1.Delete">
            <summary>删除时写日志</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.LogEntity`1.WriteLog(System.String,System.Boolean,System.String)">
            <summary>写日志</summary>
            <param name="action">操作</param>
            <param name="success">成功</param>
            <param name="remark">备注</param>
        </member>
        <member name="T:XCode.Membership.LogProvider">
            <summary>日志提供者。提供业务日志输出到数据库的功能</summary>
        </member>
        <member name="M:XCode.Membership.LogProvider.WriteLog(System.String,System.String,System.String,System.Int32,System.String,System.String)">
            <summary>写日志</summary>
            <param name="category">类型</param>
            <param name="action">操作</param>
            <param name="remark">备注</param>
            <param name="userid">用户</param>
            <param name="name">名称</param>
            <param name="ip">地址</param>
        </member>
        <member name="M:XCode.Membership.LogProvider.WriteLog(System.Type,System.String,System.String,System.Int32,System.String,System.String)">
            <summary>写日志</summary>
            <param name="type">类型</param>
            <param name="action">操作</param>
            <param name="remark">备注</param>
            <param name="userid">用户</param>
            <param name="name">名称</param>
            <param name="ip">地址</param>
        </member>
        <member name="M:XCode.Membership.LogProvider.CreateLog(System.String,System.String,System.Boolean,System.String,System.Int32,System.String,System.String)">
            <summary>创建日志，未写入</summary>
            <param name="category">类型</param>
            <param name="action">操作</param>
            <param name="success">成功</param>
            <param name="remark">备注</param>
            <param name="userid">用户</param>
            <param name="name">名称</param>
            <param name="ip">地址</param>
        </member>
        <member name="M:XCode.Membership.LogProvider.WriteLog(System.String,System.String,System.Boolean,System.String,System.Int32,System.String,System.String)">
            <summary>写日志</summary>
            <param name="category">类型</param>
            <param name="action">操作</param>
            <param name="success">成功</param>
            <param name="remark">备注</param>
            <param name="userid">用户</param>
            <param name="name">名称</param>
            <param name="ip">地址</param>
        </member>
        <member name="M:XCode.Membership.LogProvider.WriteLog(System.Type,System.String,System.Boolean,System.String,System.Int32,System.String,System.String)">
            <summary>写日志</summary>
            <param name="type">类型</param>
            <param name="action">操作</param>
            <param name="success">成功</param>
            <param name="remark">备注</param>
            <param name="userid">用户</param>
            <param name="name">名称</param>
            <param name="ip">地址</param>
        </member>
        <member name="M:XCode.Membership.LogProvider.WriteLog(System.String,XCode.IEntity,System.String)">
            <summary>输出实体对象日志</summary>
            <param name="action">操作</param>
            <param name="entity">实体</param>
            <param name="error">错误信息</param>
        </member>
        <member name="P:XCode.Membership.LogProvider.Enable">
            <summary>是否使用日志</summary>
        </member>
        <member name="M:XCode.Membership.LogProvider.AsLog(System.String)">
            <summary>转为标准日志接口</summary>
            <param name="category">日志分类</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.LogProvider.Provider">
            <summary>当前成员提供者</summary>
        </member>
        <member name="P:XCode.Membership.LogProvider.Provider2">
            <summary>当前用户提供者</summary>
        </member>
        <member name="T:XCode.Membership.MenuProvider">
            <summary>菜单提供者。提供菜单相关操作的功能</summary>
        </member>
        <member name="M:XCode.Membership.MenuProvider.WriteLog(System.Type,System.String,System.String)">
            <summary>写日志</summary>
            <param name="type">类型</param>
            <param name="action">操作</param>
            <param name="remark">备注</param>
        </member>
        <member name="P:XCode.Membership.MenuProvider.Enable">
            <summary>是否使用日志</summary>
        </member>
        <member name="P:XCode.Membership.MenuProvider.Provider">
            <summary>当前成员提供者</summary>
        </member>
        <member name="T:XCode.Membership.UserModule">
            <summary>用户模型</summary>
        </member>
        <member name="T:XCode.Membership.UserModule.__">
            <summary>字段名</summary>
        </member>
        <member name="F:XCode.Membership.UserModule.__.CreateUserID">
            <summary>创建人</summary>
        </member>
        <member name="F:XCode.Membership.UserModule.__.CreateUser">
            <summary>创建人</summary>
        </member>
        <member name="F:XCode.Membership.UserModule.__.UpdateUserID">
            <summary>更新人</summary>
        </member>
        <member name="F:XCode.Membership.UserModule.__.UpdateUser">
            <summary>更新人</summary>
        </member>
        <member name="P:XCode.Membership.UserModule.Provider">
            <summary>当前用户提供者</summary>
        </member>
        <member name="M:XCode.Membership.UserModule.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.Membership.UserModule.#ctor(XCode.Membership.IManageProvider)">
            <summary>实例化</summary>
            <param name="provider"></param>
        </member>
        <member name="M:XCode.Membership.UserModule.OnInit(System.Type)">
            <summary>初始化。检查是否匹配</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.UserModule.OnValid(XCode.IEntity,System.Boolean)">
            <summary>验证数据，自动加上创建和更新的信息</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
        </member>
        <member name="T:XCode.Membership.TimeModule">
            <summary>时间模型</summary>
        </member>
        <member name="T:XCode.Membership.TimeModule.__">
            <summary>字段名</summary>
        </member>
        <member name="F:XCode.Membership.TimeModule.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.TimeModule.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="M:XCode.Membership.TimeModule.OnInit(System.Type)">
            <summary>初始化。检查是否匹配</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.TimeModule.OnValid(XCode.IEntity,System.Boolean)">
            <summary>验证数据，自动加上创建和更新的信息</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
        </member>
        <member name="T:XCode.Membership.IPModule">
            <summary>IP地址模型</summary>
        </member>
        <member name="T:XCode.Membership.IPModule.__">
            <summary>字段名</summary>
        </member>
        <member name="F:XCode.Membership.IPModule.__.CreateIP">
            <summary>创建人</summary>
        </member>
        <member name="F:XCode.Membership.IPModule.__.UpdateIP">
            <summary>更新人</summary>
        </member>
        <member name="M:XCode.Membership.IPModule.OnInit(System.Type)">
            <summary>初始化。检查是否匹配</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IPModule.OnValid(XCode.IEntity,System.Boolean)">
            <summary>验证数据，自动加上创建和更新的信息</summary>
            <param name="entity"></param>
            <param name="isNew"></param>
        </member>
        <member name="M:XCode.Membership.IPModule.GetIPFieldNames(System.Type)">
            <summary>获取实体类的字段名。带缓存</summary>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Area">
            <summary>地区。行政区划数据</summary>
            <remarks>
            民政局 http://www.mca.gov.cn/article/sj/xzqh/2020/2020/2020092500801.html
            统计局 http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2019/index.html
            
            民政局 http://www.mca.gov.cn/article/sj/xzqh/2019/2019/201912251506.html
            统计局 http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2018/index.html
            </remarks>
            <summary>地区。行政区划数据，最高支持四级地址，9位数字</summary>
        </member>
        <member name="M:XCode.Membership.Area.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew">是否插入</param>
        </member>
        <member name="M:XCode.Membership.Area.InitData">
            <summary>初始化数据</summary>
        </member>
        <member name="P:XCode.Membership.Area.Root">
            <summary>顶级根。它的Childs就是各个省份</summary>
        </member>
        <member name="P:XCode.Membership.Area.Parent">
            <summary>父级</summary>
        </member>
        <member name="P:XCode.Membership.Area.AllParents">
            <summary>所有父级</summary>
        </member>
        <member name="P:XCode.Membership.Area.ParentPath">
            <summary>父级路径</summary>
        </member>
        <member name="P:XCode.Membership.Area.Path">
            <summary>路径</summary>
        </member>
        <member name="P:XCode.Membership.Area.Childs">
            <summary>下级地区</summary>
        </member>
        <member name="P:XCode.Membership.Area.AllChilds">
            <summary>子孙级区域。支持省市区，不支持乡镇街道</summary>
        </member>
        <member name="M:XCode.Membership.Area.FindByID(System.Int32)">
            <summary>根据编号查找</summary>
            <param name="id">编号</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:XCode.Membership.Area.FindByIDs(System.Int32[])">
            <summary>根据ID列表数组查询，一般先后查街道、区县、城市、省份</summary>
            <param name="ids"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.FindByName(System.Int32,System.String)">
            <summary>在指定地区下根据名称查找</summary>
            <param name="parentId">父级</param>
            <param name="name">名称</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.Membership.Area.FindAllByName(System.String)">
            <summary>根据名称查询三级地区，可能有多个地区同名</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.FindByNames(System.String[])">
            <summary>根据名称列表数组查询，依次查省份、城市、区县、街道</summary>
            <param name="names">名称列表</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.FindByFullName(System.String)">
            <summary>根据名称从高向低分级查找，广度搜索</summary>
            <param name="name">名称</param>
            <returns>实体列表</returns>
        </member>
        <member name="F:XCode.Membership.Area._pcache">
            <summary>根据父级查子级，专属缓存</summary>
        </member>
        <member name="M:XCode.Membership.Area.FindAllByParentID(System.Int32)">
            <summary>根据父级查找。三级地区使用实体缓存，四级地区使用专属缓存</summary>
            <param name="parentid">父级</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.Membership.Area.Search(System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Boolean},System.String,System.DateTime,System.DateTime,NewLife.Data.PageParameter)">
            <summary>高级查询</summary>
            <param name="parentid">父级</param>
            <param name="level"></param>
            <param name="idstart"></param>
            <param name="idend"></param>
            <param name="enable"></param>
            <param name="key"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.Search(System.Int32,System.String,System.Nullable{System.Boolean},System.Int32)">
            <summary>根据条件模糊搜索</summary>
            <param name="parentid">在指定级别下搜索，-1表示所有，非负数时支持字符串相似搜索</param>
            <param name="key"></param>
            <param name="enable"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.SearchAddress(System.String,System.Int32)">
            <summary>搜索地址所属地区</summary>
            <param name="address"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.Create(System.Int32,System.String,System.Int32,System.String)">
            <summary>查找或创建地区</summary>
            <param name="id"></param>
            <param name="name"></param>
            <param name="parentid"></param>
            <param name="remark"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.Preload">
            <summary>扫描预热数据</summary>
        </member>
        <member name="M:XCode.Membership.Area.ScanFixLevel">
            <summary>扫描并修正级别为0的数据</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.Parse(System.String)">
            <summary>从内容中分析得到地区。以民政部颁布的行政区划代码为准</summary>
            <param name="html"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.ParseLevel4(System.String)">
            <summary>分析得到四级地区</summary>
            <param name="html"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.ParseAndSave(System.String)">
            <summary>从内容中分析得到地区并保存。以民政部颁布的行政区划代码为准</summary>
            <param name="html"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.FetchAndSave(System.String)">
            <summary>抓取并保存数据</summary>
            <param name="url">民政局。http://www.mca.gov.cn/article/sj/xzqh/2020/2020/2020092500801.html</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.MergeLevel3(System.Collections.Generic.IList{XCode.Membership.Area},System.Boolean)">
            <summary>合并三级地区的数据</summary>
            <param name="list">外部数据源</param>
            <param name="addLose">是否添加缺失数据</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.MergeLevel4(System.Collections.Generic.IList{XCode.Membership.Area},System.Boolean)">
            <summary>合并四级地区的数据</summary>
            <param name="list">外部数据源</param>
            <param name="addLose">是否添加缺失数据</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.Import(System.String,System.Boolean,System.Int32)">
            <summary>从Csv文件导入并合并数据</summary>
            <param name="csvFile">Csv文件</param>
            <param name="addLose">是否添加缺失数据</param>
            <param name="level">需要导入的最高等级</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.Export(System.String,System.Int32)">
            <summary>导出数据到Csv文件</summary>
            <param name="csvFile"></param>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.GetBig">
            <summary>所属大区</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Area.FixLevel">
            <summary>修正等级</summary>
        </member>
        <member name="M:XCode.Membership.Area.FixName">
            <summary>修正名称</summary>
        </member>
        <member name="P:XCode.Membership.Area.ID">
            <summary>编码。行政区划编码</summary>
        </member>
        <member name="P:XCode.Membership.Area.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.Area.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:XCode.Membership.Area.ParentID">
            <summary>父级</summary>
        </member>
        <member name="P:XCode.Membership.Area.Level">
            <summary>层级</summary>
        </member>
        <member name="P:XCode.Membership.Area.Kind">
            <summary>类型。省市县，自治州等</summary>
        </member>
        <member name="P:XCode.Membership.Area.English">
            <summary>英文名</summary>
        </member>
        <member name="P:XCode.Membership.Area.PinYin">
            <summary>拼音</summary>
        </member>
        <member name="P:XCode.Membership.Area.JianPin">
            <summary>简拼</summary>
        </member>
        <member name="P:XCode.Membership.Area.TelCode">
            <summary>区号。电话区号</summary>
        </member>
        <member name="P:XCode.Membership.Area.ZipCode">
            <summary>邮编。邮政编码</summary>
        </member>
        <member name="P:XCode.Membership.Area.Longitude">
            <summary>经度</summary>
        </member>
        <member name="P:XCode.Membership.Area.Latitude">
            <summary>纬度</summary>
        </member>
        <member name="P:XCode.Membership.Area.GeoHash">
            <summary>地址编码。字符串前缀相同越多，地理距离越近，8位精度19米，6位610米</summary>
        </member>
        <member name="P:XCode.Membership.Area.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.Area.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.Area.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.Area.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.Area.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Area._">
            <summary>取得地区字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Area._.ID">
            <summary>编码。行政区划编码</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Area._.FullName">
            <summary>全名</summary>
        </member>
        <member name="F:XCode.Membership.Area._.ParentID">
            <summary>父级</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Level">
            <summary>层级</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Kind">
            <summary>类型。省市县，自治州等</summary>
        </member>
        <member name="F:XCode.Membership.Area._.English">
            <summary>英文名</summary>
        </member>
        <member name="F:XCode.Membership.Area._.PinYin">
            <summary>拼音</summary>
        </member>
        <member name="F:XCode.Membership.Area._.JianPin">
            <summary>简拼</summary>
        </member>
        <member name="F:XCode.Membership.Area._.TelCode">
            <summary>区号。电话区号</summary>
        </member>
        <member name="F:XCode.Membership.Area._.ZipCode">
            <summary>邮编。邮政编码</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Longitude">
            <summary>经度</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Latitude">
            <summary>纬度</summary>
        </member>
        <member name="F:XCode.Membership.Area._.GeoHash">
            <summary>地址编码。字符串前缀相同越多，地理距离越近，8位精度19米，6位610米</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Area._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Area._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Area._.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.Area.__">
            <summary>取得地区字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.ID">
            <summary>编码。行政区划编码</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.FullName">
            <summary>全名</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.ParentID">
            <summary>父级</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Level">
            <summary>层级</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Kind">
            <summary>类型。省市县，自治州等</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.English">
            <summary>英文名</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.PinYin">
            <summary>拼音</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.JianPin">
            <summary>简拼</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.TelCode">
            <summary>区号。电话区号</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.ZipCode">
            <summary>邮编。邮政编码</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Longitude">
            <summary>经度</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Latitude">
            <summary>纬度</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.GeoHash">
            <summary>地址编码。字符串前缀相同越多，地理距离越近，8位精度19米，6位610米</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Area.__.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.ParameterKinds">
            <summary>参数数据类型</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.Normal">
            <summary>普通</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.Boolean">
            <summary>布尔型</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.Int">
            <summary>整数</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.Double">
            <summary>浮点数</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.DateTime">
            <summary>时间日期</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.String">
            <summary>字符串</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.List">
            <summary>列表</summary>
        </member>
        <member name="F:XCode.Membership.ParameterKinds.Hash">
            <summary>哈希</summary>
        </member>
        <member name="T:XCode.Membership.Parameter">
            <summary>字典参数</summary>
            <summary>字典参数</summary>
        </member>
        <member name="M:XCode.Membership.Parameter.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew">是否插入</param>
        </member>
        <member name="M:XCode.Membership.Parameter.FindByID(System.Int32)">
            <summary>根据编号查找</summary>
            <param name="id">编号</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:XCode.Membership.Parameter.FindAllByUserID(System.Int32)">
            <summary>根据用户查找</summary>
            <param name="userId">用户</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.Membership.Parameter.FindAllByUserID(System.Int32,System.String)">
            <summary>根据用户查找</summary>
            <param name="userId">用户</param>
            <param name="category">分类</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.Membership.Parameter.Search(System.Int32,System.String,System.Nullable{System.Boolean},System.String,NewLife.Data.PageParameter)">
            <summary>高级搜索</summary>
            <param name="userId"></param>
            <param name="category"></param>
            <param name="enable"></param>
            <param name="key"></param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Parameter.GetOrAdd(System.Int32,System.String,System.String,System.String)">
            <summary>获取 或 添加 参数，支持指定默认值</summary>
            <param name="userId"></param>
            <param name="category"></param>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Parameter.GetValue">
            <summary>根据种类返回数据</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Parameter.SetValue(System.Object)">
            <summary>设置数据，自动识别种类</summary>
            <param name="value"></param>
        </member>
        <member name="M:XCode.Membership.Parameter.GetList``1">
            <summary>获取列表</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Parameter.GetHash``2">
            <summary>获取名值对</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Parameter.SetList(System.Collections.IList)">
            <summary>设置列表</summary>
            <param name="list"></param>
        </member>
        <member name="M:XCode.Membership.Parameter.SetHash(System.Collections.IDictionary)">
            <summary>设置名值对</summary>
            <param name="dic"></param>
        </member>
        <member name="P:XCode.Membership.Parameter.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.UserID">
            <summary>用户。按用户区分参数，用户0表示系统级</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Category">
            <summary>类别</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.LongValue">
            <summary>长数值</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Kind">
            <summary>种类。0普通，21列表，22名值</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.Parameter.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Parameter._">
            <summary>取得字典参数字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.UserID">
            <summary>用户。按用户区分参数，用户0表示系统级</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Category">
            <summary>类别</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Value">
            <summary>数值</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.LongValue">
            <summary>长数值</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Kind">
            <summary>种类。0普通，21列表，22名值</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Parameter._.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.Parameter.__">
            <summary>取得字典参数字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.UserID">
            <summary>用户。按用户区分参数，用户0表示系统级</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Category">
            <summary>类别</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Value">
            <summary>数值</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.LongValue">
            <summary>长数值</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Kind">
            <summary>种类。0普通，21列表，22名值</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Parameter.__.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.Log">
            <summary>日志</summary>
            <summary>日志</summary>
        </member>
        <member name="M:XCode.Membership.Log.Valid(System.Boolean)">
            <summary>已重载。记录当前管理员</summary>
            <param name="isNew"></param>
        </member>
        <member name="M:XCode.Membership.Log.OnUpdate">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.OnDelete">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.Search(System.String,System.Int32,System.String,System.DateTime,System.DateTime,NewLife.Data.PageParameter)">
            <summary>查询</summary>
            <param name="key"></param>
            <param name="userid"></param>
            <param name="category"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.Search(System.String,System.String,System.Nullable{System.Boolean},System.Int32,System.DateTime,System.DateTime,System.String,NewLife.Data.PageParameter)">
            <summary>查询</summary>
            <param name="category"></param>
            <param name="action"></param>
            <param name="success"></param>
            <param name="userid"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="key"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.Search(System.String,System.String,System.Int32,System.Nullable{System.Boolean},System.Int32,System.DateTime,System.DateTime,System.String,NewLife.Data.PageParameter)">
            <summary>查询</summary>
            <param name="category"></param>
            <param name="action"></param>
            <param name="linkId"></param>
            <param name="success"></param>
            <param name="userid"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="key"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.FindAllCategoryName">
            <summary>获取所有类别名称，最近30天</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.FindAllActionName">
            <summary>获取所有操作名称，最近30天</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Log.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Log.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.Log.Category">
            <summary>类别</summary>
        </member>
        <member name="P:XCode.Membership.Log.Action">
            <summary>操作</summary>
        </member>
        <member name="P:XCode.Membership.Log.LinkID">
            <summary>链接</summary>
        </member>
        <member name="P:XCode.Membership.Log.Success">
            <summary>成功</summary>
        </member>
        <member name="P:XCode.Membership.Log.UserName">
            <summary>用户名</summary>
        </member>
        <member name="P:XCode.Membership.Log.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.Log.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.Log.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.Log.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.Log.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.Log.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.Log.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.Log.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.Log.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.Log.CreateTime">
            <summary>时间</summary>
        </member>
        <member name="P:XCode.Membership.Log.Remark">
            <summary>详细信息</summary>
        </member>
        <member name="P:XCode.Membership.Log.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Log._">
            <summary>取得日志字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Log._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Category">
            <summary>类别</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Action">
            <summary>操作</summary>
        </member>
        <member name="F:XCode.Membership.Log._.LinkID">
            <summary>链接</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Success">
            <summary>成功</summary>
        </member>
        <member name="F:XCode.Membership.Log._.UserName">
            <summary>用户名</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Log._.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Log._.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Log._.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Log._.CreateTime">
            <summary>时间</summary>
        </member>
        <member name="F:XCode.Membership.Log._.Remark">
            <summary>详细信息</summary>
        </member>
        <member name="T:XCode.Membership.Log.__">
            <summary>取得日志字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Category">
            <summary>类别</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Action">
            <summary>操作</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.LinkID">
            <summary>链接</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Success">
            <summary>成功</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.UserName">
            <summary>用户名</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.CreateTime">
            <summary>时间</summary>
        </member>
        <member name="F:XCode.Membership.Log.__.Remark">
            <summary>详细信息</summary>
        </member>
        <member name="T:XCode.Membership.ILog">
            <summary>日志接口</summary>
        </member>
        <member name="M:XCode.Membership.ILog.Save">
            <summary>保存</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.ILog.SaveAsync(System.Int32)">
            <summary>异步保存</summary>
            <param name="msDelay">延迟保存的时间。默认0ms近实时保存</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.SexKinds">
            <summary>性别</summary>
        </member>
        <member name="F:XCode.Membership.SexKinds.未知">
            <summary>未知</summary>
        </member>
        <member name="F:XCode.Membership.SexKinds.男">
            <summary>男</summary>
        </member>
        <member name="F:XCode.Membership.SexKinds.女">
            <summary>女</summary>
        </member>
        <member name="T:XCode.Membership.UserX">
            <summary>管理员</summary>
        </member>
        <member name="T:XCode.Membership.User">
            <summary>管理员</summary>
            <remarks>
            基础实体类应该是只有一个泛型参数的，需要用到别的类型时，可以继承一个，也可以通过虚拟重载等手段让基类实现
            </remarks>
            <summary>用户。用户帐号信息</summary>
        </member>
        <member name="M:XCode.Membership.User.InitData">
            <summary>首次连接数据库时初始化数据，仅用于实体类重载，用户不应该调用该方法</summary>
        </member>
        <member name="M:XCode.Membership.User.Valid(System.Boolean)">
            <summary>验证</summary>
            <param name="isNew"></param>
        </member>
        <member name="M:XCode.Membership.User.OnDelete">
            <summary>删除用户</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.User.LastLoginAddress">
            <summary>物理地址</summary>
        </member>
        <member name="P:XCode.Membership.User.Department">
            <summary>部门</summary>
        </member>
        <member name="P:XCode.Membership.User.DepartmentName">
            <summary>部门</summary>
        </member>
        <member name="P:XCode.Membership.User.RoleIDs">
            <summary>兼容旧版角色组</summary>
        </member>
        <member name="M:XCode.Membership.User.FindByID(System.Int32)">
            <summary>根据编号查找</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.FindByName(System.String)">
            <summary>根据名称查找</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.FindByMail(System.String)">
            <summary>根据邮箱地址查找</summary>
            <param name="mail"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.FindByMobile(System.String)">
            <summary>根据手机号码查找</summary>
            <param name="mobile"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.FindByCode(System.String)">
            <summary>根据唯一代码查找</summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.Search(System.String,System.Int32,System.Nullable{System.Boolean},NewLife.Data.PageParameter)">
            <summary>高级查询</summary>
            <param name="key"></param>
            <param name="roleId"></param>
            <param name="isEnable"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.Search(System.String,System.Int32,System.Nullable{System.Boolean},System.DateTime,System.DateTime,NewLife.Data.PageParameter)">
            <summary>高级查询</summary>
            <param name="key"></param>
            <param name="roleId"></param>
            <param name="isEnable"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.Search(System.Int32,System.Int32,System.Nullable{System.Boolean},System.DateTime,System.DateTime,System.String,NewLife.Data.PageParameter)">
            <summary>高级搜索</summary>
            <param name="roleId">角色</param>
            <param name="departmentId">部门</param>
            <param name="enable">启用</param>
            <param name="start">登录时间开始</param>
            <param name="end">登录时间结束</param>
            <param name="key">关键字，搜索代码、名称、昵称、手机、邮箱</param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.Add(System.String,System.String,System.Int32,System.String)">
            <summary>添加用户，如果存在则直接返回</summary>
            <param name="name"></param>
            <param name="pass"></param>
            <param name="roleid"></param>
            <param name="display"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.ToString">
            <summary>已重载。显示友好名字</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.Login(System.String,System.String,System.Boolean)">
            <summary>登录</summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="rememberme">是否记住密码</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.SaveLoginInfo">
            <summary>保存登录信息</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.User.Logout">
            <summary>注销</summary>
        </member>
        <member name="M:XCode.Membership.User.Register">
            <summary>注册用户。第一注册用户自动抢管理员</summary>
        </member>
        <member name="M:XCode.Membership.User.DisableAdmin">
            <summary>禁用默认管理员</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.User.Role">
            <summary>角色</summary>
            <remarks>扩展属性不缓存空对象，一般来说，每个管理员都有对应的角色，如果没有，可能是在初始化</remarks>
        </member>
        <member name="P:XCode.Membership.User.Roles">
            <summary>角色集合</summary>
        </member>
        <member name="M:XCode.Membership.User.GetRoleIDs">
            <summary>获取角色列表。主角色在前，其它角色升序在后</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.User.RoleName">
            <summary>角色名</summary>
        </member>
        <member name="M:XCode.Membership.User.Has(XCode.Membership.IMenu,XCode.Membership.PermissionFlags[])">
            <summary>用户是否拥有当前菜单的指定权限</summary>
            <param name="menu">指定菜单</param>
            <param name="flags">是否拥有多个权限中的任意一个，或的关系。如果需要表示与的关系，可以传入一个多权限位合并</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.User.NewLife#Model#IManageUser#NickName">
            <summary>昵称</summary>
        </member>
        <member name="P:XCode.Membership.User.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.User.Name">
            <summary>名称。登录用户名</summary>
        </member>
        <member name="P:XCode.Membership.User.Password">
            <summary>密码</summary>
        </member>
        <member name="P:XCode.Membership.User.DisplayName">
            <summary>昵称</summary>
        </member>
        <member name="P:XCode.Membership.User.Sex">
            <summary>性别。未知、男、女</summary>
        </member>
        <member name="P:XCode.Membership.User.Mail">
            <summary>邮件</summary>
        </member>
        <member name="P:XCode.Membership.User.Mobile">
            <summary>手机</summary>
        </member>
        <member name="P:XCode.Membership.User.Code">
            <summary>代码。身份证、员工编号等</summary>
        </member>
        <member name="P:XCode.Membership.User.Avatar">
            <summary>头像</summary>
        </member>
        <member name="P:XCode.Membership.User.RoleID">
            <summary>角色。主要角色</summary>
        </member>
        <member name="P:XCode.Membership.User.RoleIds">
            <summary>角色组。次要角色集合</summary>
        </member>
        <member name="P:XCode.Membership.User.DepartmentID">
            <summary>部门。组织机构</summary>
        </member>
        <member name="P:XCode.Membership.User.Online">
            <summary>在线</summary>
        </member>
        <member name="P:XCode.Membership.User.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.User.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="P:XCode.Membership.User.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="P:XCode.Membership.User.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="P:XCode.Membership.User.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="P:XCode.Membership.User.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="P:XCode.Membership.User.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.User.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.User.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.User.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.User.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.User.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.User.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.User.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.User.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.User.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.User.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.User.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.User._">
            <summary>取得用户字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.User._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.User._.Name">
            <summary>名称。登录用户名</summary>
        </member>
        <member name="F:XCode.Membership.User._.Password">
            <summary>密码</summary>
        </member>
        <member name="F:XCode.Membership.User._.DisplayName">
            <summary>昵称</summary>
        </member>
        <member name="F:XCode.Membership.User._.Sex">
            <summary>性别。未知、男、女</summary>
        </member>
        <member name="F:XCode.Membership.User._.Mail">
            <summary>邮件</summary>
        </member>
        <member name="F:XCode.Membership.User._.Mobile">
            <summary>手机</summary>
        </member>
        <member name="F:XCode.Membership.User._.Code">
            <summary>代码。身份证、员工编号等</summary>
        </member>
        <member name="F:XCode.Membership.User._.Avatar">
            <summary>头像</summary>
        </member>
        <member name="F:XCode.Membership.User._.RoleID">
            <summary>角色。主要角色</summary>
        </member>
        <member name="F:XCode.Membership.User._.RoleIds">
            <summary>角色组。次要角色集合</summary>
        </member>
        <member name="F:XCode.Membership.User._.DepartmentID">
            <summary>部门。组织机构</summary>
        </member>
        <member name="F:XCode.Membership.User._.Online">
            <summary>在线</summary>
        </member>
        <member name="F:XCode.Membership.User._.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.User._.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="F:XCode.Membership.User._.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="F:XCode.Membership.User._.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="F:XCode.Membership.User._.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="F:XCode.Membership.User._.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="F:XCode.Membership.User._.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.User._.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.User._.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.User._.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.User._.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.User._.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.User._.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.User._.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.User._.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.User._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.User._.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.User.__">
            <summary>取得用户字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.User.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Name">
            <summary>名称。登录用户名</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Password">
            <summary>密码</summary>
        </member>
        <member name="F:XCode.Membership.User.__.DisplayName">
            <summary>昵称</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Sex">
            <summary>性别。未知、男、女</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Mail">
            <summary>邮件</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Mobile">
            <summary>手机</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Code">
            <summary>代码。身份证、员工编号等</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Avatar">
            <summary>头像</summary>
        </member>
        <member name="F:XCode.Membership.User.__.RoleID">
            <summary>角色。主要角色</summary>
        </member>
        <member name="F:XCode.Membership.User.__.RoleIds">
            <summary>角色组。次要角色集合</summary>
        </member>
        <member name="F:XCode.Membership.User.__.DepartmentID">
            <summary>部门。组织机构</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Online">
            <summary>在线</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="F:XCode.Membership.User.__.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="F:XCode.Membership.User.__.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="F:XCode.Membership.User.__.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="F:XCode.Membership.User.__.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.User.__.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.User.__.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.User.__.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.User.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.User.__.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.IUser">
            <summary>用户</summary>
        </member>
        <member name="P:XCode.Membership.IUser.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Name">
            <summary>名称。登录用户名</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Password">
            <summary>密码</summary>
        </member>
        <member name="P:XCode.Membership.IUser.DisplayName">
            <summary>昵称</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Sex">
            <summary>性别。未知、男、女</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Mail">
            <summary>邮件</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Mobile">
            <summary>手机</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Code">
            <summary>代码。身份证、员工编号等</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Avatar">
            <summary>头像</summary>
        </member>
        <member name="P:XCode.Membership.IUser.RoleID">
            <summary>角色。主要角色</summary>
        </member>
        <member name="P:XCode.Membership.IUser.RoleIds">
            <summary>角色组。次要角色集合</summary>
        </member>
        <member name="P:XCode.Membership.IUser.DepartmentID">
            <summary>部门。组织机构</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Online">
            <summary>在线</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="P:XCode.Membership.IUser.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="P:XCode.Membership.IUser.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="P:XCode.Membership.IUser.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="P:XCode.Membership.IUser.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.IUser.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.IUser.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.IUser.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.IUser.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Role">
            <summary>角色</summary>
        </member>
        <member name="P:XCode.Membership.IUser.Roles">
            <summary>角色集合</summary>
        </member>
        <member name="P:XCode.Membership.IUser.RoleName">
            <summary>角色名</summary>
        </member>
        <member name="M:XCode.Membership.IUser.Has(XCode.Membership.IMenu,XCode.Membership.PermissionFlags[])">
            <summary>用户是否拥有当前菜单的指定权限</summary>
            <param name="menu">指定菜单</param>
            <param name="flags">是否拥有多个权限中的任意一个，或的关系。如果需要表示与的关系，可以传入一个多权限位合并</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IUser.Logout">
            <summary>注销</summary>
        </member>
        <member name="M:XCode.Membership.IUser.Save">
            <summary>保存</summary>
        </member>
        <member name="T:XCode.Membership.UserOnline">
            <summary>用户在线</summary>
            <summary>用户在线</summary>
        </member>
        <member name="M:XCode.Membership.UserOnline.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew"></param>
        </member>
        <member name="P:XCode.Membership.UserOnline.CreateAddress">
            <summary>物理地址</summary>
        </member>
        <member name="M:XCode.Membership.UserOnline.FindByID(System.Int32)">
            <summary>根据会话编号查找</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.UserOnline.FindBySessionID(System.String)">
            <summary>根据会话编号查找</summary>
            <param name="sessionid"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.UserOnline.FindAllByUserID(System.Int32)">
            <summary>根据用户编号查找</summary>
            <param name="userid"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.UserOnline.Search(System.Int32,System.DateTime,System.DateTime,System.String,NewLife.Data.PageParameter)">
            <summary>查询满足条件的记录集，分页、排序</summary>
            <param name="userid">用户编号</param>
            <param name="start">开始时间</param>
            <param name="end">结束时间</param>
            <param name="key">关键字</param>
            <param name="param">分页排序参数，同时返回满足条件的总记录数</param>
            <returns>实体集</returns>
        </member>
        <member name="M:XCode.Membership.UserOnline.SetStatus(System.String,System.String,System.String,System.Int32,System.String,System.String)">
            <summary>设置会话状态</summary>
            <param name="sessionid"></param>
            <param name="page"></param>
            <param name="status"></param>
            <param name="userid"></param>
            <param name="name"></param>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.UserOnline.SetWebStatus(System.String,System.String,System.String,NewLife.Model.IManageUser,System.String)">
            <summary>设置网页会话状态</summary>
            <param name="sessionid"></param>
            <param name="page"></param>
            <param name="status"></param>
            <param name="user"></param>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.UserOnline.ClearExpire(System.Int32)">
            <summary>删除过期，指定过期时间</summary>
            <param name="secTimeout">超时时间，20 * 60秒</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.UserOnline.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.UserID">
            <summary>用户</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.SessionID">
            <summary>会话。Web的SessionID或Server的会话编号</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.Times">
            <summary>次数</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.Page">
            <summary>页面</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.Status">
            <summary>状态</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.OnlineTime">
            <summary>在线时间。本次在线总时间，秒</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.UpdateTime">
            <summary>修改时间</summary>
        </member>
        <member name="P:XCode.Membership.UserOnline.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.UserOnline._">
            <summary>取得用户在线字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.UserID">
            <summary>用户</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.SessionID">
            <summary>会话。Web的SessionID或Server的会话编号</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.Times">
            <summary>次数</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.Page">
            <summary>页面</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.Status">
            <summary>状态</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.OnlineTime">
            <summary>在线时间。本次在线总时间，秒</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline._.UpdateTime">
            <summary>修改时间</summary>
        </member>
        <member name="T:XCode.Membership.UserOnline.__">
            <summary>取得用户在线字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.UserID">
            <summary>用户</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.SessionID">
            <summary>会话。Web的SessionID或Server的会话编号</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.Times">
            <summary>次数</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.Page">
            <summary>页面</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.Status">
            <summary>状态</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.OnlineTime">
            <summary>在线时间。本次在线总时间，秒</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.UserOnline.__.UpdateTime">
            <summary>修改时间</summary>
        </member>
        <member name="T:XCode.Membership.Menu">
            <summary>菜单</summary>
            <summary>菜单</summary>
        </member>
        <member name="M:XCode.Membership.Menu.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew">是否新数据</param>
        </member>
        <member name="M:XCode.Membership.Menu.Save">
            <summary>已重载。调用Save时写日志，而调用Insert和Update时不写日志</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.OnDelete">
            <summary>删除。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.OnLoad">
            <summary>加载权限字典</summary>
        </member>
        <member name="M:XCode.Membership.Menu.OnPropertyChanged(System.String)">
            <summary>如果Permission被修改，则重新加载</summary>
            <param name="fieldName"></param>
        </member>
        <member name="P:XCode.Membership.Menu.Url2">
            <summary></summary>
        </member>
        <member name="P:XCode.Membership.Menu.ParentMenuName">
            <summary>父菜单名</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Necessaries">
            <summary>必要的菜单。必须至少有角色拥有这些权限，如果没有则自动授权给系统角色</summary>
        </member>
        <member name="P:XCode.Membership.Menu.FriendName">
            <summary>友好名称。优先显示名</summary>
        </member>
        <member name="M:XCode.Membership.Menu.FindByID(System.Int32)">
            <summary>根据编号查找</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.FindByName(System.String)">
            <summary>根据名字查找</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.FindByFullName(System.String)">
            <summary>根据全名查找</summary>
            <param name="name">全名</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.FindByUrl(System.String)">
            <summary>根据Url查找</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.FindForName(System.String)">
            <summary>根据名字查找，支持路径查找</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.FindAllByParentID(System.Int32)">
            <summary>查找指定菜单的子菜单</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.GetSubMenus(System.Int32[])">
            <summary>取得当前角色的子菜单，有权限、可显示、排序</summary>
            <param name="filters"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.Add(System.String,System.String,System.String,System.String)">
            <summary>添加子菜单</summary>
            <param name="name"></param>
            <param name="displayName"></param>
            <param name="fullName"></param>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Menu.Permissions">
            <summary>可选权限子项</summary>
        </member>
        <member name="M:XCode.Membership.Menu.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.XCode#Membership#IMenu#GetFullPath(System.Boolean,System.String,System.Func{XCode.Membership.IMenu,System.String})">
            <summary>取得全路径的实体，由上向下排序</summary>
            <param name="includeSelf">是否包含自己</param>
            <param name="separator">分隔符</param>
            <param name="func">回调</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Menu.XCode#Membership#IMenu#Parent">
            <summary>父菜单</summary>
        </member>
        <member name="P:XCode.Membership.Menu.XCode#Membership#IMenu#Childs">
            <summary>子菜单</summary>
        </member>
        <member name="P:XCode.Membership.Menu.XCode#Membership#IMenu#AllChilds">
            <summary>子孙菜单</summary>
        </member>
        <member name="M:XCode.Membership.Menu.XCode#Membership#IMenu#FindByPath(System.String)">
            <summary>根据层次路径查找</summary>
            <param name="path">层次路径</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Menu.MenuFactory">
            <summary>菜单工厂</summary>
        </member>
        <member name="M:XCode.Membership.Menu.MenuFactory.XCode#Membership#IMenuFactory#FindByID(System.Int32)">
            <summary>根据编号找到菜单</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.MenuFactory.XCode#Membership#IMenuFactory#FindByUrl(System.String)">
            <summary>根据Url找到菜单</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.MenuFactory.XCode#Membership#IMenuFactory#FindByFullName(System.String)">
            <summary>根据全名找到菜单</summary>
            <param name="fullName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.MenuFactory.XCode#Membership#IMenuFactory#GetMySubMenus(System.Int32,XCode.Membership.IUser)">
            <summary>获取指定菜单下，当前用户有权访问的子菜单。</summary>
            <param name="menuid"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Menu.MenuFactory.ScanController(System.String,System.Reflection.Assembly,System.String)">
            <summary>扫描命名空间下的控制器并添加为菜单</summary>
            <param name="rootName">根菜单名称，所有菜单附属在其下</param>
            <param name="asm">要扫描的程序集</param>
            <param name="nameSpace">要扫描的命名空间</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Menu.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.Menu.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:XCode.Membership.Menu.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:XCode.Membership.Menu.ParentID">
            <summary>父编号</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Url">
            <summary>链接</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Sort">
            <summary>排序</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Icon">
            <summary>图标</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Visible">
            <summary>可见</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Necessary">
            <summary>必要。必要的菜单，必须至少有角色拥有这些权限，如果没有则自动授权给系统角色</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Permission">
            <summary>权限子项。逗号分隔，每个权限子项名值竖线分隔</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.Menu.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.Menu.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.Menu.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.Menu.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.Menu.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.Menu.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.Menu.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.Menu.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.Menu.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Menu._">
            <summary>取得菜单字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.FullName">
            <summary>全名</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.ParentID">
            <summary>父编号</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Url">
            <summary>链接</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Sort">
            <summary>排序</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Icon">
            <summary>图标</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Visible">
            <summary>可见</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Necessary">
            <summary>必要。必要的菜单，必须至少有角色拥有这些权限，如果没有则自动授权给系统角色</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Permission">
            <summary>权限子项。逗号分隔，每个权限子项名值竖线分隔</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Menu._.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.Menu.__">
            <summary>取得菜单字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.FullName">
            <summary>全名</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.ParentID">
            <summary>父编号</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Url">
            <summary>链接</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Sort">
            <summary>排序</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Icon">
            <summary>图标</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Visible">
            <summary>可见</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Necessary">
            <summary>必要。必要的菜单，必须至少有角色拥有这些权限，如果没有则自动授权给系统角色</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Permission">
            <summary>权限子项。逗号分隔，每个权限子项名值竖线分隔</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Menu.__.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.IMenuFactory">
            <summary>菜单工厂接口</summary>
        </member>
        <member name="P:XCode.Membership.IMenuFactory.Root">
            <summary>根菜单</summary>
        </member>
        <member name="M:XCode.Membership.IMenuFactory.FindByID(System.Int32)">
            <summary>根据编号找到菜单</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IMenuFactory.FindByFullName(System.String)">
            <summary>根据全名找到菜单</summary>
            <param name="fullName"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IMenuFactory.FindByUrl(System.String)">
            <summary>根据Url找到菜单</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IMenuFactory.GetMySubMenus(System.Int32,XCode.Membership.IUser)">
            <summary>获取指定菜单下，当前用户有权访问的子菜单。</summary>
            <param name="menuid"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IMenuFactory.ScanController(System.String,System.Reflection.Assembly,System.String)">
            <summary>扫描命名空间下的控制器并添加为菜单</summary>
            <param name="rootName"></param>
            <param name="asm"></param>
            <param name="nameSpace"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.IMenu">
            <summary>菜单接口</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.ParentID">
            <summary>父编号</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Url">
            <summary>链接</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Sort">
            <summary>排序</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Icon">
            <summary>图标</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Visible">
            <summary>可见</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Necessary">
            <summary>必要。必要的菜单，必须至少有角色拥有这些权限，如果没有则自动授权给系统角色</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Permission">
            <summary>权限子项。逗号分隔，每个权限子项名值竖线分隔</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Remark">
            <summary>备注</summary>
        </member>
        <member name="M:XCode.Membership.IMenu.GetFullPath(System.Boolean,System.String,System.Func{XCode.Membership.IMenu,System.String})">
            <summary>取得全路径的实体，由上向下排序</summary>
            <param name="includeSelf">是否包含自己</param>
            <param name="separator">分隔符</param>
            <param name="func">回调</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IMenu.Add(System.String,System.String,System.String,System.String)">
            <summary>添加子菜单</summary>
            <param name="name"></param>
            <param name="displayName"></param>
            <param name="fullName"></param>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.IMenu.Parent">
            <summary>父菜单</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.Childs">
            <summary>子菜单</summary>
        </member>
        <member name="P:XCode.Membership.IMenu.AllChilds">
            <summary>子孙菜单</summary>
        </member>
        <member name="M:XCode.Membership.IMenu.FindByPath(System.String)">
            <summary>根据层次路径查找。因为需要指定在某个菜单子级查找路径，所以是成员方法而不是静态方法</summary>
            <param name="path">层次路径</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IMenu.Up">
            <summary>排序上升</summary>
        </member>
        <member name="M:XCode.Membership.IMenu.Down">
            <summary>排序下降</summary>
        </member>
        <member name="M:XCode.Membership.IMenu.GetSubMenus(System.Int32[])">
            <summary></summary>
            <param name="filters"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.IMenu.Permissions">
            <summary>可选权限子项</summary>
        </member>
        <member name="T:XCode.Membership.PermissionFlags">
            <summary>操作权限</summary>
        </member>
        <member name="F:XCode.Membership.PermissionFlags.None">
            <summary>无权限</summary>
        </member>
        <member name="F:XCode.Membership.PermissionFlags.Detail">
            <summary>查看权限</summary>
        </member>
        <member name="F:XCode.Membership.PermissionFlags.Insert">
            <summary>添加权限</summary>
        </member>
        <member name="F:XCode.Membership.PermissionFlags.Update">
            <summary>修改权限</summary>
        </member>
        <member name="F:XCode.Membership.PermissionFlags.Delete">
            <summary>删除权限</summary>
        </member>
        <member name="F:XCode.Membership.PermissionFlags.All">
            <summary>所有权限</summary>
        </member>
        <member name="T:XCode.Membership.Role">
            <summary>角色</summary>
            <summary>角色</summary>
        </member>
        <member name="M:XCode.Membership.Role.InitData">
            <summary>首次连接数据库时初始化数据，仅用于实体类重载，用户不应该调用该方法</summary>
        </member>
        <member name="M:XCode.Membership.Role.CheckRole">
            <summary>初始化时执行必要的权限检查，以防万一管理员无法操作</summary>
        </member>
        <member name="M:XCode.Membership.Role.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew">是否新数据</param>
        </member>
        <member name="M:XCode.Membership.Role.Delete">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.Save">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.Update">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.OnLoad">
            <summary>加载权限字典</summary>
        </member>
        <member name="M:XCode.Membership.Role.OnPropertyChanged(System.String)">
            <summary>如果Permission被修改，则重新加载</summary>
            <param name="fieldName"></param>
        </member>
        <member name="M:XCode.Membership.Role.FindByID(System.Int32)">
            <summary>根据编号查找角色</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.XCode#Membership#IRole#FindByID(System.Int32)">
            <summary>根据编号查找角色</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.FindByName(System.String)">
            <summary>根据名称查找角色</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Role.Permissions">
            <summary>本角色权限集合</summary>
        </member>
        <member name="M:XCode.Membership.Role.Has(System.Int32,XCode.Membership.PermissionFlags)">
            <summary>是否拥有指定资源的指定权限</summary>
            <param name="resid"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.Get(System.Int32)">
            <summary>获取权限</summary>
            <param name="resid"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.Set(System.Int32,XCode.Membership.PermissionFlags)">
            <summary>设置该角色拥有指定资源的指定权限</summary>
            <param name="resid"></param>
            <param name="flag"></param>
        </member>
        <member name="M:XCode.Membership.Role.Reset(System.Int32,XCode.Membership.PermissionFlags)">
            <summary>重置该角色指定的权限</summary>
            <param name="resid"></param>
            <param name="flag"></param>
        </member>
        <member name="M:XCode.Membership.Role.CheckValid(System.Int32[])">
            <summary>检查是否有无效权限项，有则删除</summary>
            <param name="resids"></param>
        </member>
        <member name="P:XCode.Membership.Role.Resources">
            <summary>当前角色拥有的资源</summary>
        </member>
        <member name="M:XCode.Membership.Role.GetOrAdd(System.String)">
            <summary>根据名称查找角色，若不存在则创建</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.XCode#Membership#IRole#GetOrAdd(System.String)">
            <summary>根据名称查找角色，若不存在则创建</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.Role.Add(System.String,System.Boolean,System.String)">
            <summary>添加角色，如果存在，则直接返回，否则创建</summary>
            <param name="name"></param>
            <param name="issys"></param>
            <param name="remark"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Role.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.Role.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.Role.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.Role.IsSystem">
            <summary>系统。用于业务系统开发使用，不受数据权限约束，禁止修改名称或删除</summary>
        </member>
        <member name="P:XCode.Membership.Role.Permission">
            <summary>权限。对不同资源的权限，逗号分隔，每个资源的权限子项竖线分隔</summary>
        </member>
        <member name="P:XCode.Membership.Role.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.Role.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.Role.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.Role.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.Role.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.Role.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.Role.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.Role.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.Role.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.Role.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.Role.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.Role.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.Role.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.Role.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.Role.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.Role.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Role._">
            <summary>取得角色字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Role._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Role._.IsSystem">
            <summary>系统。用于业务系统开发使用，不受数据权限约束，禁止修改名称或删除</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Permission">
            <summary>权限。对不同资源的权限，逗号分隔，每个资源的权限子项竖线分隔</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Role._.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Role._.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Role._.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Role._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Role._.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Role._.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Role._.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Role._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Role._.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.Role.__">
            <summary>取得角色字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.IsSystem">
            <summary>系统。用于业务系统开发使用，不受数据权限约束，禁止修改名称或删除</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Permission">
            <summary>权限。对不同资源的权限，逗号分隔，每个资源的权限子项竖线分隔</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Role.__.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.IRole">
            <summary>角色</summary>
        </member>
        <member name="P:XCode.Membership.IRole.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.IRole.IsSystem">
            <summary>系统。用于业务系统开发使用，不受数据权限约束，禁止修改名称或删除</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Permission">
            <summary>权限。对不同资源的权限，逗号分隔，每个资源的权限子项竖线分隔</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.IRole.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.IRole.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.IRole.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.IRole.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.IRole.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.IRole.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.IRole.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.IRole.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.IRole.Permissions">
            <summary>本角色权限集合</summary>
        </member>
        <member name="M:XCode.Membership.IRole.Has(System.Int32,XCode.Membership.PermissionFlags)">
            <summary>是否拥有指定资源的指定权限</summary>
            <param name="resid"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IRole.Get(System.Int32)">
            <summary>获取权限</summary>
            <param name="resid"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IRole.Set(System.Int32,XCode.Membership.PermissionFlags)">
            <summary>设置该角色拥有指定资源的指定权限</summary>
            <param name="resid"></param>
            <param name="flag"></param>
        </member>
        <member name="M:XCode.Membership.IRole.Reset(System.Int32,XCode.Membership.PermissionFlags)">
            <summary>重置该角色指定的权限</summary>
            <param name="resid"></param>
            <param name="flag"></param>
        </member>
        <member name="P:XCode.Membership.IRole.Resources">
            <summary>当前角色拥有的资源</summary>
        </member>
        <member name="M:XCode.Membership.IRole.FindByID(System.Int32)">
            <summary>根据编号查找角色</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IRole.GetOrAdd(System.String)">
            <summary>根据名称查找角色，若不存在则创建</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.IRole.Save">
            <summary>保存</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.VisitStatModel">
            <summary>访问统计模型</summary>
        </member>
        <member name="P:XCode.Membership.VisitStatModel.Page">
            <summary>页面</summary>
        </member>
        <member name="P:XCode.Membership.VisitStatModel.Title">
            <summary>标题</summary>
        </member>
        <member name="P:XCode.Membership.VisitStatModel.Cost">
            <summary>耗时</summary>
        </member>
        <member name="P:XCode.Membership.VisitStatModel.User">
            <summary>用户</summary>
        </member>
        <member name="P:XCode.Membership.VisitStatModel.IP">
            <summary>IP地址</summary>
        </member>
        <member name="P:XCode.Membership.VisitStatModel.Error">
            <summary>错误</summary>
        </member>
        <member name="M:XCode.Membership.VisitStatModel.Equals(System.Object)">
            <summary>相等</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.VisitStatModel.GetHashCode">
            <summary>获取哈希</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.VisitStat">
            <summary>访问统计</summary>
            <summary>访问统计</summary>
        </member>
        <member name="M:XCode.Membership.VisitStat.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew"></param>
        </member>
        <member name="M:XCode.Membership.VisitStat.FindByID(System.Int32)">
            <summary>根据编号查找</summary>
            <param name="id">编号</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:XCode.Membership.VisitStat.FindByModel(XCode.Membership.VisitStatModel,System.Boolean)">
            <summary>根据模型查找</summary>
            <param name="model"></param>
            <param name="cache"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.VisitStat.Search(XCode.Membership.VisitStatModel,System.DateTime,System.DateTime,NewLife.Data.PageParameter)">
            <summary>高级查询访问统计</summary>
            <param name="model"></param>
            <param name="start"></param>
            <param name="end"></param>
            <param name="param"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.VisitStat.FindAllPage">
            <summary>查找所有</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.VisitStat.FindAllPageName">
            <summary>获取所有名称</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Membership.VisitStat.Process(XCode.Membership.VisitStatModel,XCode.Statistics.StatLevels[])">
            <summary>业务统计</summary>
            <param name="model">模型</param>
            <param name="levels">要统计的层级</param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.VisitStat.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Level">
            <summary>层级</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Time">
            <summary>时间</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Page">
            <summary>页面</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Title">
            <summary>标题</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Times">
            <summary>次数</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Users">
            <summary>用户</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.IPs">
            <summary>IP</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Error">
            <summary>错误</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Cost">
            <summary>耗时。毫秒</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.MaxCost">
            <summary>最大耗时。毫秒</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Remark">
            <summary>详细信息</summary>
        </member>
        <member name="P:XCode.Membership.VisitStat.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.VisitStat._">
            <summary>取得访问统计字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Level">
            <summary>层级</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Time">
            <summary>时间</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Page">
            <summary>页面</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Title">
            <summary>标题</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Times">
            <summary>次数</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Users">
            <summary>用户</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.IPs">
            <summary>IP</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Error">
            <summary>错误</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Cost">
            <summary>耗时。毫秒</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.MaxCost">
            <summary>最大耗时。毫秒</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat._.Remark">
            <summary>详细信息</summary>
        </member>
        <member name="T:XCode.Membership.VisitStat.__">
            <summary>取得访问统计字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Level">
            <summary>层级</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Time">
            <summary>时间</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Page">
            <summary>页面</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Title">
            <summary>标题</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Times">
            <summary>次数</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Users">
            <summary>用户</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.IPs">
            <summary>IP</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Error">
            <summary>错误</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Cost">
            <summary>耗时。毫秒</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.MaxCost">
            <summary>最大耗时。毫秒</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.VisitStat.__.Remark">
            <summary>详细信息</summary>
        </member>
        <member name="T:XCode.Membership.Department">
            <summary>部门。组织机构，多级树状结构</summary>
            <summary>部门。组织机构，多级树状结构</summary>
        </member>
        <member name="M:XCode.Membership.Department.Valid(System.Boolean)">
            <summary>验证数据，通过抛出异常的方式提示验证失败。</summary>
            <param name="isNew">是否插入</param>
        </member>
        <member name="M:XCode.Membership.Department.InitData">
            <summary>首次连接数据库时初始化数据，仅用于实体类重载，用户不应该调用该方法</summary>
        </member>
        <member name="M:XCode.Membership.Department.Add(System.String,System.String,System.Int32)">
            <summary>添加用户，如果存在则直接返回</summary>
            <param name="name"></param>
            <param name="code"></param>
            <param name="parentid"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Department.Manager">
            <summary>管理者</summary>
        </member>
        <member name="P:XCode.Membership.Department.ManagerName">
            <summary>管理者</summary>
        </member>
        <member name="P:XCode.Membership.Department.Parent">
            <summary>父级</summary>
        </member>
        <member name="P:XCode.Membership.Department.ParentName">
            <summary>父级</summary>
        </member>
        <member name="M:XCode.Membership.Department.FindByID(System.Int32)">
            <summary>根据编号查找</summary>
            <param name="id">编号</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:XCode.Membership.Department.FindAllByName(System.String)">
            <summary>根据名称查找</summary>
            <param name="name">名称</param>
            <returns>实体列表</returns>
        </member>
        <member name="M:XCode.Membership.Department.FindByNameAndParentID(System.String,System.Int32)">
            <summary>根据名称、父级查找</summary>
            <param name="name">名称</param>
            <param name="parentid">父级</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:XCode.Membership.Department.FindByCode(System.String)">
            <summary>根据代码查找</summary>
            <param name="code">代码</param>
            <returns>实体对象</returns>
        </member>
        <member name="M:XCode.Membership.Department.Search(System.Int32,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,NewLife.Data.PageParameter)">
            <summary>高级搜索</summary>
            <param name="parentId"></param>
            <param name="enable"></param>
            <param name="visible"></param>
            <param name="key"></param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Membership.Department.ID">
            <summary>编号</summary>
        </member>
        <member name="P:XCode.Membership.Department.Code">
            <summary>代码</summary>
        </member>
        <member name="P:XCode.Membership.Department.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Membership.Department.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:XCode.Membership.Department.ParentID">
            <summary>父级</summary>
        </member>
        <member name="P:XCode.Membership.Department.Level">
            <summary>层级。树状结构的层级</summary>
        </member>
        <member name="P:XCode.Membership.Department.Sort">
            <summary>排序。同级内排序</summary>
        </member>
        <member name="P:XCode.Membership.Department.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:XCode.Membership.Department.Visible">
            <summary>可见</summary>
        </member>
        <member name="P:XCode.Membership.Department.ManagerID">
            <summary>管理者</summary>
        </member>
        <member name="P:XCode.Membership.Department.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="P:XCode.Membership.Department.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="P:XCode.Membership.Department.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="P:XCode.Membership.Department.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="P:XCode.Membership.Department.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="P:XCode.Membership.Department.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="P:XCode.Membership.Department.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="P:XCode.Membership.Department.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="P:XCode.Membership.Department.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:XCode.Membership.Department.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Membership.Department.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="P:XCode.Membership.Department.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="P:XCode.Membership.Department.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="P:XCode.Membership.Department.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="P:XCode.Membership.Department.Remark">
            <summary>备注</summary>
        </member>
        <member name="P:XCode.Membership.Department.Item(System.String)">
            <summary>获取/设置 字段值</summary>
            <param name="name">字段名</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Membership.Department._">
            <summary>取得部门字段信息的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Department._.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Code">
            <summary>代码</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Department._.FullName">
            <summary>全名</summary>
        </member>
        <member name="F:XCode.Membership.Department._.ParentID">
            <summary>父级</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Level">
            <summary>层级。树状结构的层级</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Sort">
            <summary>排序。同级内排序</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Visible">
            <summary>可见</summary>
        </member>
        <member name="F:XCode.Membership.Department._.ManagerID">
            <summary>管理者</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Department._.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Department._.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Department._.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Department._.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Department._.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Department._.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Department._.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Department._.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Department._.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.Membership.Department.__">
            <summary>取得部门字段名称的快捷方式</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.ID">
            <summary>编号</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Code">
            <summary>代码</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Name">
            <summary>名称</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.FullName">
            <summary>全名</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.ParentID">
            <summary>父级</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Level">
            <summary>层级。树状结构的层级</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Sort">
            <summary>排序。同级内排序</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Enable">
            <summary>启用</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Visible">
            <summary>可见</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.ManagerID">
            <summary>管理者</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Ex1">
            <summary>扩展1</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Ex2">
            <summary>扩展2</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Ex3">
            <summary>扩展3</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Ex4">
            <summary>扩展4</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Ex5">
            <summary>扩展5</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Ex6">
            <summary>扩展6</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.CreateUser">
            <summary>创建者</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.CreateUserID">
            <summary>创建用户</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.UpdateUser">
            <summary>更新者</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.UpdateUserID">
            <summary>更新用户</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.UpdateIP">
            <summary>更新地址</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="F:XCode.Membership.Department.__.Remark">
            <summary>备注</summary>
        </member>
        <member name="T:XCode.ConcatExpression">
            <summary>逗号连接表达式</summary>
        </member>
        <member name="P:XCode.ConcatExpression.Expressions">
            <summary>内置表达式集合</summary>
        </member>
        <member name="P:XCode.ConcatExpression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:XCode.ConcatExpression.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.ConcatExpression.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="exp"></param>
        </member>
        <member name="M:XCode.ConcatExpression.And(System.String)">
            <summary>增加</summary>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.ConcatExpression.And(XCode.Expression)">
            <summary>增加</summary>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.ConcatExpression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>已重载。</summary>
            <param name="db">数据库</param>
            <param name="builder">字符串构建器</param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="M:XCode.ConcatExpression.op_BitwiseAnd(XCode.ConcatExpression,System.String)">
            <summary>重载运算符实现And操作，同时通过布尔型支持AndIf</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.ConcatExpression.op_BitwiseAnd(XCode.ConcatExpression,XCode.Expression)">
            <summary>重载运算符实现And操作，同时通过布尔型支持AndIf</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.ConcatExpression.op_BitwiseAnd(XCode.ConcatExpression,XCode.Configuration.FieldItem)">
            <summary>重载运算符实现And操作，同时通过布尔型支持AndIf</summary>
            <param name="exp"></param>
            <param name="field">数值</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Model.EntityActions">
            <summary>实体动作</summary>
        </member>
        <member name="F:XCode.Model.EntityActions.Save">
            <summary>保存</summary>
        </member>
        <member name="F:XCode.Model.EntityActions.Insert">
            <summary>插入</summary>
        </member>
        <member name="F:XCode.Model.EntityActions.Update">
            <summary>更新</summary>
        </member>
        <member name="F:XCode.Model.EntityActions.Upsert">
            <summary>插入或更新</summary>
        </member>
        <member name="F:XCode.Model.EntityActions.Delete">
            <summary>删除</summary>
        </member>
        <member name="T:XCode.Model.EntityDeferredQueue">
            <summary>实体延迟队列。缓冲合并对象，批量处理</summary>
        </member>
        <member name="P:XCode.Model.EntityDeferredQueue.Action">
            <summary>实体动作。默认Save保存</summary>
        </member>
        <member name="P:XCode.Model.EntityDeferredQueue.Session">
            <summary>数据会话，分表分库时使用</summary>
        </member>
        <member name="P:XCode.Model.EntityDeferredQueue.MaxSingle">
            <summary>最大单行保存大小。大于该值时才采用批量保存，默认2</summary>
        </member>
        <member name="M:XCode.Model.EntityDeferredQueue.Process(System.Collections.Generic.IList{System.Object})">
            <summary>处理一批</summary>
            <param name="list"></param>
        </member>
        <member name="T:XCode.Model.WhereBuilder">
            <summary>查询条件构建器。主要用于构建数据权限等扩展性查询</summary>
            <remarks>
            输入文本型变量表达式，分析并计算得到条件表达式。
            例如：
            输入 CreateUserID={$User.ID}， 输出 _.CreateUserID==Data["User"].GetValue("ID")
            输入 StartSiteId in {#SiteIds} or CityId={#CityId}，输出 _.StartSiteId.In(Data2["SiteIds"]) | _.CityId==Data2["CityId"]
            </remarks>
        </member>
        <member name="P:XCode.Model.WhereBuilder.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="P:XCode.Model.WhereBuilder.Expression">
            <summary>表达式语句</summary>
        </member>
        <member name="P:XCode.Model.WhereBuilder.Data">
            <summary>数据源。{$name}访问</summary>
        </member>
        <member name="P:XCode.Model.WhereBuilder.Data2">
            <summary>第二数据源。{#name}访问</summary>
        </member>
        <member name="M:XCode.Model.WhereBuilder.SetData(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>设置数据源</summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:XCode.Model.WhereBuilder.SetData2(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>设置第二数据源</summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:XCode.Model.WhereBuilder.GetExpression">
            <summary>计算获取表达式</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Model.WhereBuilder.ParseExpression(System.String)">
            <summary>递归分解表达式</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Model.WhereBuilder.Eval(XCode.IEntity)">
            <summary>评估指定实体是否满足表达式要求</summary>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Model.WhereBuilder.EvalParse(System.String,XCode.IEntity)">
            <summary>递归分解表达式</summary>
            <param name="value"></param>
            <param name="entity">实体对象</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Expression">
            <summary>表达式基类</summary>
        </member>
        <member name="P:XCode.Expression.Text">
            <summary>文本表达式</summary>
        </member>
        <member name="P:XCode.Expression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="F:XCode.Expression.Empty">
            <summary>空表达式，一般用于表达式连写</summary>
        </member>
        <member name="M:XCode.Expression.#ctor">
            <summary>实例化简单表达式</summary>
        </member>
        <member name="M:XCode.Expression.#ctor(System.String)">
            <summary>用一段文本实例化简单表达式</summary>
            <param name="value"></param>
        </member>
        <member name="F:XCode.Expression._regOr">
            <summary>用于匹配Or关键字的正则表达式</summary>
        </member>
        <member name="M:XCode.Expression.GetString(XCode.DataAccessLayer.IDatabase,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>获取表达式的文本表示</summary>
            <param name="db">数据库</param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>获取字符串</summary>
            <param name="db">数据库</param>
            <param name="builder">字符串构建器</param>
            <param name="ps">参数字典</param>
        </member>
        <member name="M:XCode.Expression.ToString">
            <summary>输出该表达式的字符串形式</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.op_Implicit(XCode.Expression)~System.String">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.op_BitwiseAnd(XCode.Expression,XCode.Expression)">
            <summary>重载运算符实现And操作</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.op_BitwiseAnd(XCode.Expression,System.String)">
            <summary>重载运算符实现And操作</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.op_BitwiseOr(XCode.Expression,XCode.Expression)">
            <summary>重载运算符实现Or操作</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.op_BitwiseOr(XCode.Expression,System.String)">
            <summary>重载运算符实现Or操作</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Expression.op_Addition(XCode.Expression,XCode.Expression)">
            <summary>重载运算符实现+操作</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="T:XCode.FieldExpression">
            <summary>字段表达式</summary>
        </member>
        <member name="P:XCode.FieldExpression.Field">
            <summary>字段</summary>
        </member>
        <member name="P:XCode.FieldExpression.Action">
            <summary>动作</summary>
        </member>
        <member name="P:XCode.FieldExpression.Value">
            <summary>值</summary>
        </member>
        <member name="P:XCode.FieldExpression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:XCode.FieldExpression.#ctor(XCode.Configuration.FieldItem)">
            <summary>构造字段表达式</summary>
            <param name="field"></param>
        </member>
        <member name="M:XCode.FieldExpression.#ctor(XCode.Configuration.FieldItem,System.String,System.Object)">
            <summary>构造字段表达式</summary>
            <param name="field"></param>
            <param name="action"></param>
            <param name="value"></param>
        </member>
        <member name="M:XCode.FieldExpression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>已重载。输出字段表达式的字符串形式</summary>
            <param name="db">数据库</param>
            <param name="builder">字符串构建器</param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="T:XCode.FormatExpression">
            <summary>格式化表达式。通过字段、格式化字符串和右值去构建表达式</summary>
            <remarks>右值可能为空，比如{0} Is Null</remarks>
        </member>
        <member name="P:XCode.FormatExpression.Field">
            <summary>字段</summary>
        </member>
        <member name="P:XCode.FormatExpression.Format">
            <summary>格式化字符串</summary>
        </member>
        <member name="P:XCode.FormatExpression.Value">
            <summary>操作数</summary>
        </member>
        <member name="P:XCode.FormatExpression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:XCode.FormatExpression.#ctor(XCode.Configuration.FieldItem,System.String,System.Object)">
            <summary>构造格式化表达式</summary>
            <param name="field"></param>
            <param name="format"></param>
            <param name="value"></param>
        </member>
        <member name="M:XCode.FormatExpression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>已重载。输出字段表达式的字符串形式</summary>
            <param name="db">数据库</param>
            <param name="builder">字符串构建器</param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="T:XCode.InExpression">
            <summary>格式化表达式。通过字段、格式化字符串和右值去构建表达式</summary>
            <remarks>右值可能为空，比如{0} Is Null</remarks>
        </member>
        <member name="P:XCode.InExpression.Field">
            <summary>字段</summary>
        </member>
        <member name="P:XCode.InExpression.Format">
            <summary>格式化字符串</summary>
        </member>
        <member name="P:XCode.InExpression.Value">
            <summary>操作数</summary>
        </member>
        <member name="P:XCode.InExpression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:XCode.InExpression.#ctor(XCode.Configuration.FieldItem,System.String,System.Object)">
            <summary>构造格式化表达式</summary>
            <param name="field"></param>
            <param name="format"></param>
            <param name="value"></param>
        </member>
        <member name="M:XCode.InExpression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>已重载。输出字段表达式的字符串形式</summary>
            <param name="db">数据库</param>
            <param name="builder">字符串构建器</param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="T:XCode.OrderExpression">
            <summary>排序表达式</summary>
        </member>
        <member name="P:XCode.OrderExpression.Builder">
            <summary>内置字符串</summary>
        </member>
        <member name="P:XCode.OrderExpression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:XCode.OrderExpression.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.OrderExpression.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="exp"></param>
        </member>
        <member name="M:XCode.OrderExpression.And(System.String)">
            <summary>增加</summary>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.OrderExpression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>已重载。</summary>
            <param name="db">数据库</param>
            <param name="builder">字符串构建器</param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="M:XCode.OrderExpression.op_Implicit(XCode.OrderExpression)~System.String">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.OrderExpression.op_BitwiseAnd(XCode.OrderExpression,System.Object)">
            <summary>重载运算符实现And操作</summary>
            <param name="exp"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="T:XCode.Operator">
            <summary>操作符</summary>
        </member>
        <member name="F:XCode.Operator.And">
            <summary>与，交集</summary>
        </member>
        <member name="F:XCode.Operator.Or">
            <summary>或，并集</summary>
        </member>
        <member name="F:XCode.Operator.Space">
            <summary>空格</summary>
        </member>
        <member name="T:XCode.WhereExpression">
            <summary>条件表达式</summary>
        </member>
        <member name="P:XCode.WhereExpression.Left">
            <summary>左节点</summary>
        </member>
        <member name="P:XCode.WhereExpression.Right">
            <summary>右节点</summary>
        </member>
        <member name="P:XCode.WhereExpression.Operator">
            <summary>是否And</summary>
        </member>
        <member name="P:XCode.WhereExpression.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:XCode.WhereExpression.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.WhereExpression.#ctor(XCode.Expression,XCode.Operator,XCode.Expression)">
            <summary>实例化</summary>
            <param name="left"></param>
            <param name="op"></param>
            <param name="right"></param>
        </member>
        <member name="M:XCode.WhereExpression.GetString(XCode.DataAccessLayer.IDatabase,System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>输出条件表达式的字符串表示，遍历表达式集合并拼接起来</summary>
            <param name="db">数据库</param>
            <param name="builder"></param>
            <param name="ps">参数字典</param>
            <returns></returns>
        </member>
        <member name="M:XCode.WhereExpression.Flatten(XCode.Expression)">
            <summary>拉平表达式，避免空子项</summary>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Setting">
            <summary>XCode设置</summary>
        </member>
        <member name="P:XCode.Setting.Debug">
            <summary>是否启用调试。默认启用</summary>
        </member>
        <member name="P:XCode.Setting.ShowSQL">
            <summary>是否输出SQL语句，默认启用</summary>
        </member>
        <member name="P:XCode.Setting.SQLPath">
            <summary>设置SQL输出的单独目录，默认为空，SQL输出到当前日志中。生产环境建议输出到站点外单独的SqlLog目录</summary>
        </member>
        <member name="P:XCode.Setting.TraceSQLTime">
            <summary>跟踪SQL执行时间，大于该阀值将输出日志，默认1000毫秒</summary>
        </member>
        <member name="P:XCode.Setting.SQLMaxLength">
            <summary>SQL最大长度，输出日志时的SQL最大长度，超长截断，默认4096，不截断用0</summary>
        </member>
        <member name="P:XCode.Setting.ConnMaps">
            <summary>连接名映射#，表名映射@，表名映射@，把实体类中的Test2和Test3连接名映射到Test去</summary>
        </member>
        <member name="P:XCode.Setting.UseParameter">
            <summary>参数化添删改查。默认关闭</summary>
        </member>
        <member name="P:XCode.Setting.CommandTimeout">
            <summary>命令超时。查询执行超时时间，默认0秒不限制</summary>
        </member>
        <member name="P:XCode.Setting.RetryOnFailure">
            <summary>失败重试。执行命令超时后的重试次数，默认0不重试</summary>
        </member>
        <member name="P:XCode.Setting.DataCacheExpire">
            <summary>数据层缓存。根据sql做缓存，默认0秒</summary>
        </member>
        <member name="P:XCode.Setting.EntityCacheExpire">
            <summary>实体缓存过期。整表缓存实体列表，默认10秒</summary>
        </member>
        <member name="P:XCode.Setting.SingleCacheExpire">
            <summary>单对象缓存过期。按主键缓存实体，默认10秒</summary>
        </member>
        <member name="P:XCode.Setting.ExtendExpire">
            <summary>扩展属性过期。扩展属性Extends缓存，默认10秒</summary>
        </member>
        <member name="P:XCode.Setting.Migration">
            <summary>反向工程。Off 关闭；ReadOnly 只读不执行；On 打开，仅新建；Full 完全，修改删除</summary>
        </member>
        <member name="P:XCode.Setting.NameFormat">
            <summary></summary>
        </member>
        <member name="T:XCode.Statistics.IStat">
            <summary>统计接口</summary>
        </member>
        <member name="P:XCode.Statistics.IStat.Level">
            <summary>层级</summary>
        </member>
        <member name="P:XCode.Statistics.IStat.Time">
            <summary>时间</summary>
        </member>
        <member name="P:XCode.Statistics.IStat.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:XCode.Statistics.IStat.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="T:XCode.Statistics.StatHelper">
            <summary>统计助手类</summary>
        </member>
        <member name="M:XCode.Statistics.StatHelper.GetOrAdd``2(``1,System.Func{``1,System.Boolean,``0},System.Action{``0})">
            <summary>获取 或 新增 统计对象</summary>
            <typeparam name="TEntity"></typeparam>
            <typeparam name="TModel"></typeparam>
            <param name="model"></param>
            <param name="find"></param>
            <param name="onCreate"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Statistics.StatLevels">
            <summary>统计层级</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.All">
            <summary>全局</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.Year">
            <summary>年</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.Month">
            <summary>月</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.Day">
            <summary>日</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.Hour">
            <summary>小时</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.Minute">
            <summary>分钟</summary>
        </member>
        <member name="F:XCode.Statistics.StatLevels.Quarter">
            <summary>季度</summary>
        </member>
        <member name="T:XCode.Statistics.StatModel`1">
            <summary>统计模型</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:XCode.Statistics.StatModel`1.Copy(`0)">
            <summary>拷贝</summary>
            <param name="model"></param>
        </member>
        <member name="M:XCode.Statistics.StatModel`1.Clone">
            <summary>克隆到目标类型</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Statistics.StatModel`1.Split(XCode.Statistics.StatLevels[])">
            <summary>分割为多个层级</summary>
            <param name="levels"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Statistics.StatModel">
            <summary>统计模型</summary>
        </member>
        <member name="P:XCode.Statistics.StatModel.Time">
            <summary>时间</summary>
        </member>
        <member name="P:XCode.Statistics.StatModel.Level">
            <summary>层级</summary>
        </member>
        <member name="M:XCode.Statistics.StatModel.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.Statistics.StatModel.GetDate(XCode.Statistics.StatLevels)">
            <summary>获取不同层级的时间。选择层级区间的开头</summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Statistics.StatModel.ToString">
            <summary>数据库时间转显示字符串</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Statistics.StatModel.Fill(System.Collections.Generic.IDictionary{System.String,System.String},XCode.Statistics.StatLevels)">
            <summary>使用参数填充</summary>
            <param name="ps">请求参数</param>
            <param name="defLevel">默认级别</param>
        </member>
        <member name="M:XCode.Statistics.StatModel.Equals(System.Object)">
            <summary>相等</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Statistics.StatModel.GetHashCode">
            <summary>获取哈希</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Sync.ISyncMaster">
            <summary>同步架构主方接口</summary>
            <remarks>
            同步框架中的数据供应方，同步是双向的，从方可以从主方拿数据，也可以把更新数据提交给主方。
            可通过<see cref="P:XCode.Sync.ISyncMaster.ReadOnly"/>来指定主方是否只读，只读的主方不接受数据提交。
            </remarks>
        </member>
        <member name="P:XCode.Sync.ISyncMaster.ReadOnly">
            <summary>是否只读。只读的主方不接受数据提交</summary>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.GetAllUpdated(System.DateTime,System.Int32,System.Int32)">
            <summary>获取指定时间后更新过的数据</summary>
            <param name="last"></param>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.GetAllUpdatedCount(System.DateTime)">
            <summary>获取指定时间后更新过的数据数量</summary>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.Insert(XCode.Sync.ISyncMasterEntity[])">
            <summary>提交新增数据</summary>
            <param name="list"></param>
            <returns>返回新增成功后的数据，包括自增字段</returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.Update(XCode.Sync.ISyncMasterEntity)">
            <summary>更新数据</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.Delete(System.Object[])">
            <summary>根据主键数组删除数据</summary>
            <param name="keys"></param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.CheckExists(System.Object[])">
            <summary>根据主键数组检查数据是否仍然存在</summary>
            <param name="keys"></param>
            <returns>是否存在</returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.Create">
            <summary>创建一个空白实体</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncMaster.GetNames">
            <summary>获取要同步的字段名</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Sync.ISyncMasterEntity">
            <summary>同步框架主方实体接口，由主方实体类实现</summary>
        </member>
        <member name="P:XCode.Sync.ISyncMasterEntity.Key">
            <summary>唯一标识数据的键值</summary>
        </member>
        <member name="P:XCode.Sync.ISyncMasterEntity.LastUpdate">
            <summary>最后修改时间。包括修改同步状态为假删除</summary>
        </member>
        <member name="T:XCode.Sync.SyncMaster">
            <summary>同步架构主方</summary>
        </member>
        <member name="P:XCode.Sync.SyncMaster.Facotry">
            <summary>工厂</summary>
        </member>
        <member name="P:XCode.Sync.SyncMaster.KeyName">
            <summary>主键名</summary>
        </member>
        <member name="P:XCode.Sync.SyncMaster.LastUpdateName">
            <summary>最后更新字段名。如果没有指定，将每次都同步全部数据</summary>
        </member>
        <member name="P:XCode.Sync.SyncMaster.ReadOnly">
            <summary>是否只读。只读的主方不接受数据提交</summary>
        </member>
        <member name="M:XCode.Sync.SyncMaster.GetAllUpdated(System.DateTime,System.Int32,System.Int32)">
            <summary>检查在指定时间后更新过的数据</summary>
            <param name="last"></param>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.GetAllUpdatedCount(System.DateTime)">
            <summary>获取指定时间后更新过的数据数量</summary>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.Insert(XCode.Sync.ISyncMasterEntity[])">
            <summary>提交新增数据</summary>
            <param name="list"></param>
            <returns>返回新增成功后的数据，包括自增字段</returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.Update(XCode.Sync.ISyncMasterEntity)">
            <summary>更新数据</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.Delete(System.Object[])">
            <summary>根据主键数组删除数据</summary>
            <param name="keys"></param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.CheckExists(System.Object[])">
            <summary>根据主键数组检查数据是否仍然存在</summary>
            <param name="keys"></param>
            <returns>是否存在</returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.Create">
            <summary>创建一个空白实体</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncMaster.GetNames">
            <summary>获取要同步的字段名</summary>
            <returns></returns>
        </member>
        <member name="P:XCode.Sync.SyncMaster.SyncMasterEntity.Host">
            <summary>宿主</summary>
        </member>
        <member name="P:XCode.Sync.SyncMaster.SyncMasterEntity.Entity">
            <summary>实体</summary>
        </member>
        <member name="T:XCode.Sync.ISyncSlave">
            <summary>同步框架从方接口</summary>
        </member>
        <member name="P:XCode.Sync.ISyncSlave.LastSync">
            <summary>最后同步时间</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlave.GetAllNew(System.Int32,System.Int32)">
            <summary>获取所有新添加的数据</summary>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlave.GetAllDelete(System.Int32,System.Int32)">
            <summary>获取所有删除的数据</summary>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlave.GetAllOld(System.DateTime,System.Int32,System.Int32)">
            <summary>获取所有未同步的旧数据</summary>
            <param name="now"></param>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlave.FindByKey(System.Object)">
            <summary>根据主键查找</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlave.Create">
            <summary>创建一个空白实体</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlave.GetNames">
            <summary>获取要同步的字段名</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Sync.ISyncSlaveEntity">
            <summary>同步框架从方实体接口，由从方实体类实现</summary>
        </member>
        <member name="P:XCode.Sync.ISyncSlaveEntity.Key">
            <summary>唯一标识数据的键值</summary>
        </member>
        <member name="P:XCode.Sync.ISyncSlaveEntity.LastUpdate">
            <summary>最后修改时间。包括修改同步状态为假删除</summary>
        </member>
        <member name="P:XCode.Sync.ISyncSlaveEntity.LastSync">
            <summary>最后同步时间。包括向主方询问数据是否已删除</summary>
        </member>
        <member name="M:XCode.Sync.ISyncSlaveEntity.ChangeKey(System.Object)">
            <summary>改变主键。本地新增加的数据，在提交到提供方后，可能主键会改变（如自增字段），需要更新本地主键为新主键</summary>
            <param name="key"></param>
        </member>
        <member name="M:XCode.Sync.ISyncSlaveEntity.Insert">
            <summary>插入</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlaveEntity.Update">
            <summary>更新</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.ISyncSlaveEntity.Delete">
            <summary>删除本地数据</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Sync.SyncSlave">
            <summary>同步框架从方，实体类默认实现。要求实体类实现<see cref="T:XCode.Sync.ISyncSlaveEntity"/>接口</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.Factory">
            <summary>工厂</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.KeyName">
            <summary>主键名</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.LastUpdateName">
            <summary>最后更新字段名</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.LastSyncName">
            <summary>最后更新字段名</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.LastUpdateField">
            <summary>最后更新字段名。先硬编码，不考虑可变</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.LastSyncField">
            <summary>最后同步字段名</summary>
        </member>
        <member name="P:XCode.Sync.SyncSlave.LastSync">
            <summary>最后同步时间</summary>
        </member>
        <member name="M:XCode.Sync.SyncSlave.GetLastSync">
            <summary>获取最后同步时间</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncSlave.GetAllNew(System.Int32,System.Int32)">
            <summary>获取所有新添加的数据</summary>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncSlave.GetAllDelete(System.Int32,System.Int32)">
            <summary>获取所有删除的数据</summary>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncSlave.GetAllOld(System.DateTime,System.Int32,System.Int32)">
            <summary>获取所有未同步的旧数据</summary>
            <param name="now"></param>
            <param name="start"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncSlave.FindByKey(System.Object)">
            <summary>根据主键查找</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncSlave.Create">
            <summary>创建一个空白实体</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.Sync.SyncSlave.GetNames">
            <summary>获取要同步的字段名</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Sync.SyncManager">
            <summary>同步管理器</summary>
        </member>
        <member name="P:XCode.Sync.SyncManager.Master">
            <summary>同步框架主方，数据提供者。</summary>
        </member>
        <member name="P:XCode.Sync.SyncManager.Slave">
            <summary>同步框架从方，数据消费者</summary>
        </member>
        <member name="P:XCode.Sync.SyncManager.BatchSize">
            <summary>同步批大小</summary>
        </member>
        <member name="P:XCode.Sync.SyncManager.Names">
            <summary>字段集合</summary>
        </member>
        <member name="P:XCode.Sync.SyncManager.UpdateConflictByLastUpdate">
            <summary>是否根据最后修改时间来解决双方同时更新而带来的冲突，否则强制优先本地</summary>
        </member>
        <member name="M:XCode.Sync.SyncManager.Start">
            <summary>开始处理</summary>
        </member>
        <member name="M:XCode.Sync.SyncManager.ProcessNew">
            <summary>处理本地添加的数据</summary>
        </member>
        <member name="M:XCode.Sync.SyncManager.ProcessDelete">
            <summary>处理本地删除的数据</summary>
        </member>
        <member name="M:XCode.Sync.SyncManager.ProcessItems">
            <summary>处理更新的数据</summary>
        </member>
        <member name="M:XCode.Sync.SyncManager.ProcessItem(XCode.Sync.ISyncMasterEntity)">
            <summary>处理更新的数据项</summary>
            <param name="remote"></param>
        </member>
        <member name="M:XCode.Sync.SyncManager.ProcessOthers(System.DateTime)">
            <summary>查找还有哪些没有同步的，可能提供者已经删除</summary>
            <param name="now"></param>
        </member>
        <member name="T:XCode.Transform.DataContext">
            <summary>数据上下文</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.Setting">
            <summary>抽取设置</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.Data">
            <summary>实体列表</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.FetchCost">
            <summary>抽取耗时，毫秒</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.Success">
            <summary>成功处理数</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.ProcessCost">
            <summary>处理耗时</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.Entity">
            <summary>实体对象</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.Error">
            <summary>处理异常</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.StartTime">
            <summary>开始时间</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.Item(System.String)">
            <summary>用户数据</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:XCode.Transform.DataContext.FetchSpeed">
            <summary>抽取速度</summary>
        </member>
        <member name="P:XCode.Transform.DataContext.ProcessSpeed">
            <summary>处理速度</summary>
        </member>
        <member name="T:XCode.Transform.EntityIdExtracter">
            <summary>自增数据抽取器</summary>
            <remarks>
            适用于带有自增字段或雪花Id字段的数据抽取器，速度飞快。
            </remarks>
        </member>
        <member name="P:XCode.Transform.EntityIdExtracter.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="P:XCode.Transform.EntityIdExtracter.IdField">
            <summary>Id字段</summary>
        </member>
        <member name="P:XCode.Transform.EntityIdExtracter.Row">
            <summary>开始行。默认0</summary>
        </member>
        <member name="P:XCode.Transform.EntityIdExtracter.BatchSize">
            <summary>批大小。默认5000</summary>
        </member>
        <member name="M:XCode.Transform.EntityIdExtracter.#ctor">
            <summary>实例化数据抽取器</summary>
        </member>
        <member name="M:XCode.Transform.EntityIdExtracter.#ctor(XCode.IEntityFactory,XCode.Configuration.FieldItem)">
            <summary>实例化数据抽取器</summary>
            <param name="factory"></param>
            <param name="idField"></param>
        </member>
        <member name="M:XCode.Transform.EntityIdExtracter.Fetch">
            <summary>迭代抽取数据</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Transform.IExtractSetting">
            <summary>数据抽取参数</summary>
        </member>
        <member name="P:XCode.Transform.IExtractSetting.Start">
            <summary>开始。大于等于</summary>
        </member>
        <member name="P:XCode.Transform.IExtractSetting.End">
            <summary>结束。小于</summary>
        </member>
        <member name="P:XCode.Transform.IExtractSetting.Offset">
            <summary>时间偏移。距离实时时间的秒数，部分业务不能跑到实时</summary>
        </member>
        <member name="P:XCode.Transform.IExtractSetting.Row">
            <summary>开始行。分页</summary>
        </member>
        <member name="P:XCode.Transform.IExtractSetting.Step">
            <summary>步进。最大区间大小，秒</summary>
        </member>
        <member name="P:XCode.Transform.IExtractSetting.BatchSize">
            <summary>批大小</summary>
        </member>
        <member name="T:XCode.Transform.ExtractSetting">
            <summary>数据抽取参数</summary>
        </member>
        <member name="P:XCode.Transform.ExtractSetting.Start">
            <summary>开始。大于等于</summary>
        </member>
        <member name="P:XCode.Transform.ExtractSetting.End">
            <summary>结束。小于</summary>
        </member>
        <member name="P:XCode.Transform.ExtractSetting.Offset">
            <summary>时间偏移。距离实时时间的秒数，部分业务不能跑到实时</summary>
        </member>
        <member name="P:XCode.Transform.ExtractSetting.Row">
            <summary>开始行。分页</summary>
        </member>
        <member name="P:XCode.Transform.ExtractSetting.Step">
            <summary>步进。最大区间大小，秒</summary>
        </member>
        <member name="P:XCode.Transform.ExtractSetting.BatchSize">
            <summary>批大小</summary>
        </member>
        <member name="M:XCode.Transform.ExtractSetting.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:XCode.Transform.ExtractSetting.#ctor(XCode.Transform.IExtractSetting)">
            <summary>实例化</summary>
            <param name="set"></param>
        </member>
        <member name="T:XCode.Transform.ExtractSettingHelper">
            <summary>抽取参数帮助类</summary>
        </member>
        <member name="M:XCode.Transform.ExtractSettingHelper.Copy(XCode.Transform.IExtractSetting,XCode.Transform.IExtractSetting)">
            <summary>拷贝设置参数</summary>
            <param name="src"></param>
            <param name="set"></param>
        </member>
        <member name="M:XCode.Transform.ExtractSettingHelper.Clone(XCode.Transform.IExtractSetting)">
            <summary>克隆一份设置参数</summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.Transform.IdExtracter">
            <summary>自增数据抽取器</summary>
            <remarks>
            适用于带有自增字段或雪花Id字段的数据抽取器，速度飞快。
            </remarks>
        </member>
        <member name="P:XCode.Transform.IdExtracter.Dal">
            <summary>数据层</summary>
        </member>
        <member name="P:XCode.Transform.IdExtracter.Builder">
            <summary>查询表达式</summary>
        </member>
        <member name="P:XCode.Transform.IdExtracter.IdField">
            <summary>Id字段</summary>
        </member>
        <member name="P:XCode.Transform.IdExtracter.Row">
            <summary>开始行。默认0</summary>
        </member>
        <member name="P:XCode.Transform.IdExtracter.BatchSize">
            <summary>批大小。默认5000</summary>
        </member>
        <member name="P:XCode.Transform.IdExtracter.TotalCount">
            <summary>总行数</summary>
        </member>
        <member name="M:XCode.Transform.IdExtracter.#ctor">
            <summary>实例化数据抽取器</summary>
        </member>
        <member name="M:XCode.Transform.IdExtracter.#ctor(XCode.DataAccessLayer.DAL,System.String,System.String)">
            <summary>实例化数据抽取器</summary>
            <param name="dal"></param>
            <param name="tableName"></param>
            <param name="idField"></param>
        </member>
        <member name="M:XCode.Transform.IdExtracter.Fetch">
            <summary>迭代抽取数据</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Transform.IETLModule">
            <summary>数据抽取模块，用于自定义抽取过程中各个环节</summary>
        </member>
        <member name="M:XCode.Transform.IETLModule.Start">
            <summary>开始调度</summary>
        </member>
        <member name="M:XCode.Transform.IETLModule.Stop">
            <summary>停止调度</summary>
        </member>
        <member name="M:XCode.Transform.IETLModule.Init">
            <summary>首次初始化任务</summary>
        </member>
        <member name="M:XCode.Transform.IETLModule.Processing(XCode.Transform.DataContext)">
            <summary>单批数据处理前</summary>
            <param name="ctx">数据上下文</param>
            <returns></returns>
        </member>
        <member name="M:XCode.Transform.IETLModule.Processed(XCode.Transform.DataContext)">
            <summary>单批数据处理后</summary>
            <param name="ctx">数据上下文</param>
        </member>
        <member name="M:XCode.Transform.IETLModule.Fetched(XCode.Transform.DataContext)">
            <summary>抽取完成</summary>
            <param name="ctx">数据上下文</param>
        </member>
        <member name="M:XCode.Transform.IETLModule.OnFinished(XCode.Transform.DataContext)">
            <summary>实体列表完成后</summary>
            <param name="ctx">数据上下文</param>
        </member>
        <member name="M:XCode.Transform.IETLModule.OnError(XCode.Transform.DataContext)">
            <summary>出错</summary>
            <param name="ctx">数据上下文</param>
        </member>
        <member name="T:XCode.Transform.IETLStat">
            <summary>ETL统计接口</summary>
        </member>
        <member name="P:XCode.Transform.IETLStat.Total">
            <summary>总数</summary>
        </member>
        <member name="P:XCode.Transform.IETLStat.Success">
            <summary>成功</summary>
        </member>
        <member name="P:XCode.Transform.IETLStat.Changes">
            <summary>改变数</summary>
        </member>
        <member name="P:XCode.Transform.IETLStat.Times">
            <summary>次数</summary>
        </member>
        <member name="P:XCode.Transform.IETLStat.Error">
            <summary>错误</summary>
        </member>
        <member name="P:XCode.Transform.IETLStat.Message">
            <summary>错误内容</summary>
        </member>
        <member name="T:XCode.Transform.ETLStat">
            <summary>ETL统计</summary>
        </member>
        <member name="P:XCode.Transform.ETLStat.Total">
            <summary>总数</summary>
        </member>
        <member name="P:XCode.Transform.ETLStat.Success">
            <summary>成功</summary>
        </member>
        <member name="P:XCode.Transform.ETLStat.Changes">
            <summary>改变数</summary>
        </member>
        <member name="P:XCode.Transform.ETLStat.Times">
            <summary>次数</summary>
        </member>
        <member name="P:XCode.Transform.ETLStat.Error">
            <summary>错误</summary>
        </member>
        <member name="P:XCode.Transform.ETLStat.Message">
            <summary>错误内容</summary>
        </member>
        <member name="T:XCode.Transform.IExtracter`1">
            <summary>数据抽取接口</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:XCode.Transform.IExtracter`1.Row">
            <summary>开始行。默认0</summary>
        </member>
        <member name="M:XCode.Transform.IExtracter`1.Fetch">
            <summary>迭代抽取数据</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.Transform.ExtracterBase">
            <summary>抽取器基类</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.Name">
            <summary>名称</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.FieldName">
            <summary>获取 或 设置 时间字段</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.Where">
            <summary>附加条件</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.Field">
            <summary>时间字段</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.OrderBy">
            <summary>排序</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.Selects">
            <summary>选择列</summary>
        </member>
        <member name="M:XCode.Transform.ExtracterBase.#ctor">
            <summary>实例化时基抽取算法</summary>
        </member>
        <member name="M:XCode.Transform.ExtracterBase.Init">
            <summary>初始化</summary>
        </member>
        <member name="P:XCode.Transform.ExtracterBase.Log">
            <summary>日志</summary>
        </member>
        <member name="M:XCode.Transform.ExtracterBase.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:XCode.Transform.PagingExtracter">
            <summary>分页数据抽取器</summary>
            <remarks>
            通用抽取器，既没有Id序列也没有时间戳时使用。
            采用分页技术抽取，通用性很强，但是随着页数增加，速度也会下降。
            </remarks>
        </member>
        <member name="P:XCode.Transform.PagingExtracter.Dal">
            <summary>数据层</summary>
        </member>
        <member name="P:XCode.Transform.PagingExtracter.Builder">
            <summary>查询表达式</summary>
        </member>
        <member name="P:XCode.Transform.PagingExtracter.Row">
            <summary>开始行。默认0</summary>
        </member>
        <member name="P:XCode.Transform.PagingExtracter.BatchSize">
            <summary>批大小。默认5000</summary>
        </member>
        <member name="M:XCode.Transform.PagingExtracter.#ctor">
            <summary>实例化分页抽取器</summary>
        </member>
        <member name="M:XCode.Transform.PagingExtracter.#ctor(XCode.DataAccessLayer.DAL,System.String)">
            <summary>实例化分页抽取器</summary>
            <param name="dal"></param>
            <param name="tableName"></param>
        </member>
        <member name="M:XCode.Transform.PagingExtracter.Fetch">
            <summary>迭代抽取数据</summary>
            <returns></returns>
        </member>
        <member name="T:XCode.EntityTree`1">
            <summary>主键为整型的实体树基类</summary>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="T:XCode.EntityTree`2">
            <summary>实体树基类，具有树形结构的实体继承该类即可得到各种树操作功能</summary>
            <remarks>
            实体树很神奇，子类可以通过KeyName、ParentKeyName、SortingKeyName、NameKeyName等设置型属性，
            指定关联键、关联父键、排序键、名称键，其中前两个是必须的，它们是构造一棵树的根基！
            
            整个表会形成一颗实体树，同时也是一个实体列表，子级紧靠父级，同级排序，<see cref="P:XCode.EntityTree`2.Root"/>就是这棵树的根。
            所以，Root.Childs可以得到顶级节点集合，Root.AllChilds得到整棵树。
            </remarks>
            <typeparam name="TKey">主键类型</typeparam>
            <typeparam name="TEntity">实体类型</typeparam>
        </member>
        <member name="F:XCode.EntityTree`2.Setting">
            <summary>实体树操作者</summary>
        </member>
        <member name="P:XCode.EntityTree`2.Sort">
            <summary>排序值</summary>
        </member>
        <member name="P:XCode.EntityTree`2.Childs">
            <summary>子节点</summary>
        </member>
        <member name="M:XCode.EntityTree`2.FindChilds">
            <summary>子节点</summary>
        </member>
        <member name="P:XCode.EntityTree`2.Parent">
            <summary>父节点</summary>
        </member>
        <member name="M:XCode.EntityTree`2.FindParent">
            <summary>父节点</summary>
        </member>
        <member name="M:XCode.EntityTree`2.FindByKeyWithCache(`0)">
            <summary>在缓存中查找节点</summary>
        </member>
        <member name="P:XCode.EntityTree`2.AllChilds">
            <summary>子孙节点</summary>
        </member>
        <member name="P:XCode.EntityTree`2.MyAllChilds">
            <summary>子孙节点，包含自己</summary>
        </member>
        <member name="P:XCode.EntityTree`2.AllParents">
            <summary>父节点集合</summary>
        </member>
        <member name="P:XCode.EntityTree`2.Deepth">
            <summary>深度</summary>
        </member>
        <member name="P:XCode.EntityTree`2.Root">
            <summary>根</summary>
        </member>
        <member name="P:XCode.EntityTree`2.NodeName">
            <summary>节点名</summary>
        </member>
        <member name="P:XCode.EntityTree`2.ParentNodeName">
            <summary>父级节点名</summary>
        </member>
        <member name="P:XCode.EntityTree`2.TreeNodeName">
            <summary>树形节点名，根据深度带全角空格前缀</summary>
        </member>
        <member name="P:XCode.EntityTree`2.TreeNodeName2">
            <summary>树形节点名，根据深度带全角空格前缀</summary>
        </member>
        <member name="P:XCode.EntityTree`2.TreeNodeText">
            <summary>树形节点名，根据深度带全角空格前缀</summary>
        </member>
        <member name="P:XCode.EntityTree`2.FullPath">
            <summary>斜杠分隔的全路径</summary>
        </member>
        <member name="P:XCode.EntityTree`2.FullParentPath">
            <summary>斜杠分隔的全父路径</summary>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllByParent(`0)">
            <summary>根据父级查找所有子级，带排序功能，先排序字段再主键</summary>
            <remarks>如果是顶级，那么包含所有无头节点，无头节点由错误数据造成</remarks>
            <param name="parentKey"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllNoParent">
            <summary>查找所有无头节点（没有父节点的节点）集合（其实就是父节点已经被删掉了的非法节点）</summary>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllChildsByParent(`0)">
            <summary>查找指定键的所有子节点，以深度层次树结构输出，包括当前节点作为根节点。空父节点返回顶级列表，无效父节点返回空列表</summary>
            <param name="parentKey"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllChildsNoParent(`0)">
            <summary>查找指定键的所有子节点，以深度层次树结构输出。空父节点返回顶级列表，无效父节点返回空列表</summary>
            <param name="parentKey"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllChildsExcept(XCode.IEntityTree)">
            <summary>获取完整树，包含根节点，排除指定分支。多用于树节点父级选择</summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllParentsByKey(`0)">
            <summary>查找指定键的所有父节点，从高到底以深度层次树结构输出</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllChilds(XCode.IEntityTree,System.Boolean,XCode.IEntityTree)">
            <summary>查找指定节点的所有子节点，以深度层次树结构输出</summary>
            <param name="entity">根节点</param>
            <param name="includeSelf">返回列表是否包含根节点，默认false</param>
            <param name="exclude">要排除的节点</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindAllParents(XCode.IEntityTree,System.Boolean)">
            <summary>查找指定节点的所有父节点，从高到底以深度层次树结构输出</summary>
            <param name="entity"></param>
            <param name="includeSelf">返回列表是否包含根节点，默认false</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.FindByPath(System.String,System.String[])">
            <summary>根据层次路径查找</summary>
            <param name="path">层次路径</param>
            <param name="keys">用于在每一层匹配实体的键值，默认是NameKeyName</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.Contains(`0)">
            <summary>是否包含子节点</summary>
            <param name="key">子节点键值</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.GetFullPath(System.Boolean,System.String,System.Func{`1,System.String})">
            <summary>取得全路径的实体，由上向下排序</summary>
            <param name="includeSelf">是否包含自己</param>
            <param name="separator">分隔符</param>
            <param name="func">回调</param>
            <returns></returns>
        </member>
        <member name="M:XCode.EntityTree`2.ClearRelation">
            <summary>删除子级到本级的关系。导出数据前可以先删除关系，以减少导出的大小</summary>
        </member>
        <member name="M:XCode.EntityTree`2.Up">
            <summary>排序上升</summary>
        </member>
        <member name="M:XCode.EntityTree`2.Down">
            <summary>排序下降</summary>
        </member>
        <member name="M:XCode.EntityTree`2.Valid(System.Boolean)">
            <summary>验证树形数据是否有效</summary>
            <param name="isNew">是否新数据</param>
        </member>
        <member name="P:XCode.EntityTree`2.XCode#IEntityTree#Parent">
            <summary>父实体</summary>
        </member>
        <member name="P:XCode.EntityTree`2.XCode#IEntityTree#Childs">
            <summary>子实体集合</summary>
        </member>
        <member name="P:XCode.EntityTree`2.XCode#IEntityTree#AllChilds">
            <summary>子孙实体集合。以深度层次树结构输出</summary>
        </member>
        <member name="P:XCode.EntityTree`2.XCode#IEntityTree#AllParents">
            <summary>父亲实体集合。以深度层次树结构输出</summary>
        </member>
        <member name="M:XCode.EntityTree`2.XCode#IEntityTree#FindAllChildsExcept(XCode.IEntityTree)">
            <summary>获取完整树，包含根节点，排除指定分支。多用于树节点父级选择</summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.IEntityTree">
            <summary>实体树接口</summary>
        </member>
        <member name="P:XCode.IEntityTree.Parent">
            <summary>父实体</summary>
        </member>
        <member name="P:XCode.IEntityTree.Childs">
            <summary>子实体集合</summary>
        </member>
        <member name="P:XCode.IEntityTree.AllChilds">
            <summary>子孙实体集合。以深度层次树结构输出</summary>
        </member>
        <member name="P:XCode.IEntityTree.AllParents">
            <summary>父亲实体集合。以深度层次树结构输出</summary>
        </member>
        <member name="P:XCode.IEntityTree.Deepth">
            <summary>深度</summary>
        </member>
        <member name="P:XCode.IEntityTree.TreeNodeText">
            <summary>树形节点名，根据深度带全角空格前缀</summary>
        </member>
        <member name="M:XCode.IEntityTree.FindAllChildsExcept(XCode.IEntityTree)">
            <summary>获取完整树，包含根节点，排除指定分支。多用于树节点父级选择</summary>
            <param name="exclude"></param>
            <returns></returns>
        </member>
        <member name="T:XCode.IEntityTreeSetting">
            <summary>实体树设置</summary>
        </member>
        <member name="P:XCode.IEntityTreeSetting.Key">
            <summary>关联键名称，一般是主键，如ID</summary>
        </member>
        <member name="P:XCode.IEntityTreeSetting.Parent">
            <summary>关联父键名，一般是Parent加主键，如ParentID</summary>
        </member>
        <member name="P:XCode.IEntityTreeSetting.Sort">
            <summary>排序字段，默认是"Sorting", "Sort", "Rank"之一</summary>
        </member>
        <member name="P:XCode.IEntityTreeSetting.Name">
            <summary>名称键名，如Name，否则使用第一个非自增字段</summary>
            <remarks>影响NodeName、TreeNodeName、TreeNodeName2、FindByPath、GetFullPath、GetFullPath2等</remarks>
        </member>
        <member name="P:XCode.IEntityTreeSetting.Text">
            <summary>文本键名</summary>
        </member>
        <member name="P:XCode.IEntityTreeSetting.BigSort">
            <summary>是否大排序，较大排序值在前面</summary>
        </member>
        <member name="P:XCode.IEntityTreeSetting.MaxDeepth">
            <summary>允许的最大深度。默认0，不限制</summary>
        </member>
        <member name="T:XCode.EntityTreeSetting`1">
            <summary>实体树设置</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.Factory">
            <summary>实体操作者</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.Key">
            <summary>关联键名称，一般是主键，如ID</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.Parent">
            <summary>关联父键名，一般是Parent加主键，如ParentID</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.Sort">
            <summary>排序字段，默认是"Sorting", "Sort", "Rank"之一</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.Name">
            <summary>名称键名，如Name，否则使用第一个非自增字段</summary>
            <remarks>影响NodeName、TreeNodeName、TreeNodeName2、FindByPath、GetFullPath、GetFullPath2等</remarks>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.Text">
            <summary>文本键名</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.BigSort">
            <summary>是否大排序，较大排序值在前面</summary>
        </member>
        <member name="P:XCode.EntityTreeSetting`1.MaxDeepth">
            <summary>允许的最大深度。默认0，不限制</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Jiaver.Sqls.SqlBaseData`1" -->
        <member name="M:Jiaver.Sqls.SqlBaseData`1.MapTo``1">
            <summary>
            使用automapper进行数据映射，须有映射关系
            </summary>
            <typeparam name="RT"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Jiaver.Sqls.SqlBaseData`1.Execute_Count(System.String)">
            <summary>
            执行select count(1) 返回结果
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:Jiaver.Sqls.SqlBaseData`1.DoInTransition(System.Action)">
            <summary>
            执行事务
            </summary>
            <param name="act"></param>
        </member>
        <member name="M:Jiaver.Sqls.SqlBaseDataHelper.SaveSync``1(Jiaver.Sqls.SqlBaseData{``0})">
            <summary>
            同步保存，用于并行时异步lock同步保存数据
            </summary>
            <typeparam name="TEntity"></typeparam>
            <param name="data"></param>
        </member>
        <member name="T:Jiaver.Models.SMS">
            <summary> 
            [sms]
            </summary> 
        </member>
        <member name="P:Jiaver.Models.SMS.id">
            <summary> 
            [id]
            </summary> 
        </member>
        <member name="P:Jiaver.Models.SMS.phone">
            <summary> 
            [phone]电话号码
            </summary> 
        </member>
        <member name="P:Jiaver.Models.SMS.smsid">
            <summary> 
            [smsid]短信id
            </summary> 
        </member>
        <member name="P:Jiaver.Models.SMS.message">
            <summary> 
            [message]短信内容
            </summary> 
        </member>
        <member name="T:Ji.CommonHelper.WPF.Extensions.INotifyAll">
            <summary></summary>
        </member>
        <member name="M:Ji.CommonHelper.WPF.Extensions.INotifyAllHelper.RaiseAll(Ji.CommonHelper.WPF.Extensions.INotifyAll)">
            <summary> 触发所有具有 Get 的属性通知 </summary>
            <param name="data"></param>
            <param name="pce"> </param>
        </member>
        <member name="T:Ji.CommonHelper.WPF.Helpers.ObservableCollectionHelper">
            <summary></summary>
        </member>
        <member name="T:Ji.CommonHelper.System.WindowsVersionHelper">
            <summary>
             <para>
              This utility is used by <see cref="!:PrerequisiteSoftwareValidation" /> to detect the
              Microsoft Windows version currently running on the machine.
             </para>
             <para>
              This class uses Win API function GetVersionEx() from kernel32 library to retrieve
              additional parameters about the installed Windows version.
             </para>
            </summary>
            <threadsafety>
             <para> This class is immutable and thread safe. </para>
            </threadsafety>
            <author> saarixx </author>
            <author> TCSDEVELOPER </author>
            <version> 1.0 </version>
            <copyright> Copyright (c) 2008, TopCoder, Inc. All rights reserved. </copyright>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows95">
            <summary>
             <para> Represents Windows 95. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows98">
            <summary>
             <para> Represents Windows 98. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsME">
            <summary>
             <para> Represents Windows ME. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsVista">
            <summary>
             <para> Represents Windows Vista. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2008">
            <summary>
             <para> Represents Windows Server 2008. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows10">
            <summary> Represents windows 10, windows server 2016 technical preview </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows8">
            <summary> Represents windows 8,8.1 </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2012">
            <summary> Represents windows server 2012 </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows7">
            <summary>
             <para> Represents Windows 7. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2003Storage">
            <summary>
             <para> Represents Windows Server 2003, Storage. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2003ComputeClusterEdition">
            <summary>
             <para> Represents Windows Server 2003, Compute Cluster Edition. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2003DatacenterEdition">
            <summary>
             <para> Represents Windows Server 2003, Datacenter Edition. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2003EnterpriseEdition">
            <summary>
             <para> Represents Windows Server 2003, Enterprise Edition. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2003WebEdition">
            <summary>
             <para> Represents Windows Server 2003, Web Edition. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsServer2003StandardEdition">
            <summary>
             <para> Represents Windows Server 2003, Standard Edition. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsXPHomeEdition">
            <summary>
             <para> Represents Windows XP Home Edition. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsXPProfessional">
            <summary>
             <para> Represents Windows XP Professional. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows2000Professional">
            <summary>
             <para> Represents Windows 2000 Professional. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows2000DatacenterServer">
            <summary>
             <para> Represents Windows 2000 Datacenter Server. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows2000AdvancedServer">
            <summary>
             <para> Represents Windows 2000 Advanced Server. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Windows2000Server">
            <summary>
             <para> Represents Windows 2000 Server. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsNT40">
            <summary>
             <para> Represents Windows NT 4.0. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.WindowsCE">
            <summary>
             <para> Represents Windows CE. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.Unknown">
            <summary>
             <para> Represents Unknown. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_NT_WORKSTATION">
            <summary>
             <para> Represents VER_NT_WORKSTATION from kernel32 library. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_SUITE_ENTERPRISE">
            <summary>
             <para> Represents VER_SUITE_ENTERPRISE from kernel32 library. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_SUITE_DATACENTER">
            <summary>
             <para> Represents VER_SUITE_DATACENTER from kernel32 library. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_SUITE_PERSONAL">
            <summary>
             <para> Represents VER_SUITE_PERSONAL from kernel32 library. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_SUITE_BLADE">
            <summary>
             <para> Represents VER_SUITE_BLADE from kernel32 library. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_SUITE_STORAGE_SERVER">
            <summary>
             <para> Represents VER_SUITE_STORAGE_SERVER from kernel32 library. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.VER_SUITE_COMPUTE_SERVER">
            <summary>
             <para> Represents VER_SUITE_COMPUTE_SERVER from kernel32 library. </para>
            </summary>
        </member>
        <member name="T:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx">
            <summary>
             <para>
              Contains operating system version information. The information includes major and minor
              version numbers, a build number, a platform identifier, and information about product
              suites and the latest Service Pack installed on the system.
             </para>
            </summary>
            <remarks>
             <para> Please refer to WIN API document for more detailed information. </para>
            </remarks>
            <author> saarixx </author>
            <author> TCSDEVELOPER </author>
            <version> 1.0 </version>
            <copyright> Copyright (c) 2008, TopCoder, Inc. All rights reserved. </copyright>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.dwOSVersionInfoSize">
            <summary>
             <para> The size of this data structure, in bytes. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.dwMajorVersion">
            <summary>
             <para> The major version number of the operating system. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.dwMinorVersion">
            <summary>
             <para> The minor version number of the operating system. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.dwBuildNumber">
            <summary>
             <para> The build number of the operating system. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.dwPlatformId">
            <summary>
             <para> The operating system platform. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.szCSDVersion">
            <summary>
             <para>
              A null-terminated string, such as "Service Pack 3", that indicates the latest
              Service Pack installed on the system. If no Service Pack has been installed, the
              string is empty.
             </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.wServicePackMajor">
            <summary>
             <para>
              The major version number of the latest Service Pack installed on the system. For
              example, for Service Pack 3, the major version number is 3. If no Service Pack has
              been installed, the value is zero.
             </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.wServicePackMinor">
            <summary>
             <para>
              The minor version number of the latest Service Pack installed on the system. For
              example, for Service Pack 3, the minor version number is 0.
             </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.wSuiteMask">
            <summary>
             <para> A bit mask that identifies the product suites available on the system. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.wProductType">
            <summary>
             <para> Any additional information about the system. </para>
            </summary>
        </member>
        <member name="F:Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx.wReserved">
            <summary>
             <para> Reserved for future use. </para>
            </summary>
        </member>
        <member name="M:Ji.CommonHelper.System.WindowsVersionHelper.GetVersionEx(Ji.CommonHelper.System.WindowsVersionHelper.OSVersionInfoEx@)">
            <summary>
             <para> Retrieves information about the current operating system. </para>
            </summary>
            <remarks>
             <para> Please refer to WIN API document for more detailed information. </para>
            </remarks>
            <param name="osVersionInfoEx"> A structure that receives the operating system information. </param>
            <returns>
             If the function succeeds, the return value is a nonzero value. If the function fails,
             the return value is zero.
            </returns>
        </member>
        <member name="M:Ji.CommonHelper.System.WindowsVersionHelper.GetVersion">
            <summary>
             <para> Retrieves the Windows version name. </para>
             <para>
              Currently the result can be one of: 
              <list type="bullet">
               <item> Windows 95 </item>
               <item> Windows 98 </item>
               <item> Windows ME </item>
               <item> Windows Vista </item>
               <item> Windows Server 2008 </item>
               <item> Windows 7 </item>
               <item> Windows Server 2003, Storage </item>
               <item> Windows Server 2003, Compute Cluster Edition </item>
               <item> Windows Server 2003, Datacenter Edition </item>
               <item> Windows Server 2003, Enterprise Edition </item>
               <item> Windows Server 2003, Web Edition </item>
               <item> Windows Server 2003, Standard Edition </item>
               <item> Windows XP Home Edition </item>
               <item> Windows XP Professional </item>
               <item> Windows 2000 Professional </item>
               <item> Windows 2000 Datacenter Server </item>
               <item> Windows 2000 Advanced Server </item>
               <item> Windows 2000 Server </item>
               <item> Windows NT 4.0 </item>
               <item> Windows CE </item>
               <item> Unknown </item>
              </list>
             </para>
            </summary>
            <returns>
             The Windows version name (e.g. "Windows Vista"), can not be null or empty.
               <!-- Windows 10 -->
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}" />
            </returns>
            <exception cref="!:PrerequisiteSoftwareValidationException">
             If an error occurred while getting the version.
            </exception>
        </member>
        <member name="M:Ji.CommonHelper.System.WindowsVersionHelper.GetServicePack">
            <summary>
             <para> Retrieves the Windows service pack. </para>
            </summary>
            <returns>
             The Windows service pack (can not be null, empty if no service packs are installed)
            </returns>
            <exception cref="!:PrerequisiteSoftwareValidationException">
             If an error occurred while getting the version of the service pack.
            </exception>
        </member>
        <member name="M:Ji.BaseData.INotifyOfInvocationListHelper.JudgeAddEventHandler``1(System.Object,System.Delegate,System.Boolean)">
            <summary> 增加委托到 _invocationList 委托列表中 ，执行重复检查 </summary>
            <typeparam name="T"> 具有 _invocationList 链的类型 </typeparam>
            <param name="data">                       具有线程通知的数据，此项为原委托链的数据类型 </param>
            <param name="handler">                    增加到委托链的委托 </param>
            <param name="isINotifyCollectionChanged"> 当前类型是否为 INotifyCollectionChanged </param>
            <returns> 执行增加是否成功 </returns>
        </member>
        <member name="M:Ji.BaseData.INotifyOfInvocationListHelper.JudgeRemoveEventHandler``1(System.Object,System.Object,System.Boolean,System.Boolean)">
            <summary> 清空具有 _invocationList 的委托列表 </summary>
            <typeparam name="T"> 具有 _invocationList 链的类型 </typeparam>
            <param name="data">                       具有线程通知的数据 </param>
            <param name="remove_targetdata">          删除指定类型中的所有此类型注册委托 </param>
            <param name="isINotifyCollectionChanged"> 当前类型是否为 INotifyCollectionChanged </param>
            <returns> 执行删除是否成功 </returns>
        </member>
        <member name="M:Ji.BaseData.INotifyOfInvocationListHelper.AddPropertyEventHandler``1(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler)">
            <summary> 对 INotifyPropertyChanged 的委托链增加委托函数 </summary>
            <typeparam name="T"> 具有线程通知的传入类型 </typeparam>
            <param name="property"> 实现线程通知的类型 </param>
            <param name="handler">  将要增加的委托 </param>
            <returns> 是否增加成功 </returns>
        </member>
        <member name="M:Ji.BaseData.INotifyOfInvocationListHelper.AddCollectionEventHandler``1(System.Collections.Specialized.INotifyCollectionChanged,System.Collections.Specialized.NotifyCollectionChangedEventHandler)">
            <summary> 对 INotifyCollectionChanged 的委托链增加委托函数 </summary>
            <typeparam name="T"> 具有线程通知的传入类型 </typeparam>
            <param name="collection"> 实现线程通知的类型 </param>
            <param name="handler">    将要增加的委托 </param>
            <returns> 是否增加成功 </returns>
        </member>
        <member name="M:Ji.BaseData.INotifyOfInvocationListHelper.RemovePropertyEventHandler``1(System.ComponentModel.INotifyPropertyChanged,System.Object)">
            <summary> 对 INotifyPropertyChanged 的委托链删除指定Target的委托函数 </summary>
            <typeparam name="T"> 具有线程通知的传入类型 </typeparam>
            <param name="property">          将要增加的委托 </param>
            <param name="remove_targetdata"></param>
            <returns> 是否删除成功 </returns>
        </member>
        <member name="M:Ji.BaseData.INotifyOfInvocationListHelper.RemoveCollectionEventHandler``1(System.Collections.Specialized.INotifyCollectionChanged,System.Object)">
            <summary> 对 INotifyCollectionChanged 的委托链删除指定Target的委托函数 </summary>
            <typeparam name="T"> 具有线程通知的传入类型 </typeparam>
            <param name="collection">        实现线程通知的类型 </param>
            <param name="remove_targetdata"> 将要增加的委托 </param>
            <returns> 是否删除成功 </returns>
        </member>
        <member name="M:Ji.NetHelper.HtmlHelper.DeleteHTMLTag(System.String)">
            <summary> 去除HTML标签 </summary>
            <param name="Htmlstring"> 传入的html页面字符串 </param>
            <returns> 除去常用html标签之后的返回值 </returns>
        </member>
        <member name="T:Ji.NetHelper.HttpHelper2">
            <summary> 基于Http的数据请求 </summary>
        </member>
        <member name="F:Ji.NetHelper.HttpHelper2.SetterSign">
            <summary> 默认设置当前的标识为I </summary>
        </member>
        <member name="F:Ji.NetHelper.HttpHelper2.CookieContainers">
            <summary> 设置Cookie容器 此项能在需要的时候保存Cookies </summary>
        </member>
        <member name="M:Ji.NetHelper.HttpHelper2.#cctor">
            <summary> 设置需要证书请求的时候默认为true </summary>
        </member>
        <member name="M:Ji.NetHelper.HttpHelper2.CreatRequest(System.String,System.String,System.Collections.Generic.List{System.String},System.String)">
            <summary> 向HTTP流中添加数据头 </summary>
            <param name="url"> 请求的URL </param>
            <param name="method"> 请求使用的方法 GET、POST </param>
            <returns> 返回创建的 HttpWebRequest </returns>
        </member>
        <member name="M:Ji.NetHelper.HttpHelper2.GetStreamResponse(System.String,System.String,System.String,System.Collections.Generic.List{System.String})">
            <summary> 根据URL获取回传的 Stream 无编码格式的确认 </summary>
            <param name="url"> 请求的URL </param>
            <returns> 返回的数据流 </returns>
        </member>
        <member name="M:Ji.NetHelper.HttpHelper2.GetStringResponse(System.String,System.String,System.String,System.Collections.Generic.List{System.String},System.String)">
            <summary> 以字符串形式获取返回值 </summary>
            <param name="url"> 请求的URl </param>
            <param name="method"> 传递方法 </param>
            <param name="data"> 传递数据 </param>
            <returns> 返回的字符串 UTF-8 编码 </returns>
        </member>
        <member name="M:Ji.NetHelper.HttpHelper2.GetStringResponse(System.String,System.Text.Encoding,System.String,System.String,System.Collections.Generic.List{System.String},System.String)">
            <summary> 以字符串形式获取返回值 </summary>
            <param name="url"> 请求的URl </param>
            <param name="encoding"> 编码格式 </param>
            <param name="method"> 传递方法 </param>
            <param name="data"> 传递数据 </param>
            <returns> 返回指定编码的字符串 </returns>
        </member>
        <member name="M:Ji.NetHelper.HttpHelper2.PostStringResponse(System.String,System.Text.Encoding,System.String)">
            <summary> 以字符串形式获取返回值 </summary>
            <param name="url"> 请求的URl </param>
            <param name="encoding"> 编码格式 </param>
            <param name="method"> 传递方法 </param>
            <param name="data"> 传递数据 </param>
            <returns> 返回指定编码的字符串 </returns>
        </member>
        <member name="M:Ji.NetHelper.UDPHelper.StartUDP(System.String)">
            <summary> udpClient.Send(new byte[] { 1, 0, 0, 0, 8 }, 5); </summary>
            <param name="port"></param>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:Ji.SystemHelper.StartupHelper.SetStartup(System.Boolean)">
            <summary> 增加开机启动项 </summary>
        </member>
        <member name="M:Ji.SystemHelper.StartupHelper.SetStartup(System.Reflection.Assembly,System.Boolean)">
            <summary> 增加开机启动项 </summary>
            <param name="assembly"> 执行自启的程序集 </param>
            <param name="isstartup"> 是否自启 </param>
        </member>
        <member name="M:Ji.SystemHelper.StartupHelper.CheckStartUp">
            <summary> 检查启动项是否存在 </summary>
        </member>
        <member name="M:Ji.SystemHelper.StartupHelper.CheckStartUp(System.Reflection.Assembly)">
            <summary> 检查启动项是否存在 </summary>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:Ji.ImageHelper.BitmapHelper.GetBitmap(System.String)">
            <summary> 从文件中读取 ImageSource </summary>
            <param name="filePath">文件路径</param>
            <returns>读取到的 ImageSource </returns>
        </member>
        <member name="M:Ji.MathHelper.CircleHelper.GetCircleArea(System.Double)">
            <summary> 获取圆面积 </summary>
            <param name="r"> 半径 </param>
            <returns></returns>
        </member>
        <member name="M:Ji.MathHelper.CircleHelper.GetCirclePerimete(System.Double)">
            <summary> 获取圆周长 </summary>
            <param name="r"> 半径 </param>
            <returns></returns>
        </member>
        <member name="T:Ji.MathHelper.EllipseArea">
            <summary> 椭圆焦点类型  </summary>
        </member>
        <member name="P:Ji.MathHelper.EllipseArea.Center1">
            <summary> 左焦点 </summary>
        </member>
        <member name="P:Ji.MathHelper.EllipseArea.Center2">
            <summary> 右焦点 </summary>
        </member>
        <member name="P:Ji.MathHelper.EllipseArea.Length">
            <summary> 椭圆圆周点到两焦点定长 </summary>
        </member>
        <member name="M:Ji.MathHelper.EllipseArea.IsInclude(Ji.MathHelper.Point)">
            <summary> 判断点是否在椭圆内 </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="T:Ji.MathHelper.EllipseHelper">
            <summary> 椭圆帮助类 </summary>
        </member>
        <member name="M:Ji.MathHelper.EllipseHelper.GetEllipseArea(Ji.MathHelper.Point,System.Double,System.Double,System.Double)">
            <summary> 计算椭圆焦点 </summary>
            <param name="location"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Ji.MathHelper.SectorHelper.GetCircleAreaByAngle(System.Double,System.Double)">
            <summary> 获取扇形面积 </summary>
        </member>
        <member name="M:Ji.MathHelper.SectorHelper.GetCircleAreaByArc(System.Double,System.Double)">
            <summary> 获取扇形面积 </summary>
        </member>
        <member name="M:Ji.MathHelper.SectorHelper.GetArcLength(System.Double,System.Double)">
            <summary> 获取扇形弧长 </summary>
        </member>
        <member name="M:Ji.MathHelper.SectorHelper.GetArcPerimete(System.Double)">
            <summary> 获取扇形周长 </summary>
        </member>
        <member name="M:Ji.MathHelper.SquareHelper.GetSquareArea(System.Double,System.Double)">
            <summary> 获取方形面积 </summary>
        </member>
        <member name="M:Ji.MathHelper.SquareHelper.GetSquarePerimete(System.Double,System.Double)">
            <summary> 获取方形周长 </summary>
        </member>
        <member name="M:Ji.DataHelper.RIPEHelper.GetRIPEMD160String(System.String)">
            <summary>
            RIPEMD160哈希算法
            </summary>
            <param name="para"></param>
            <returns></returns>
        </member>
        <member name="M:Ji.DataHelper.MD5Helper.MD5.StringToBytes(System.String)">
            <summary> 修改字符串默认UTF8编码 </summary>
        </member>
        <member name="M:Weber.ClientBase.DoGet(System.String,System.String[])">
            <summary>
            自定义Header 分割符为 ": "
            </summary>
            <param name="url"></param>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:Weber.ClientBase.DoPost(System.String,System.String,System.String[])">
            <summary>
            自定义Header 分割符为 ": "
            </summary>
            <param name="url"></param>
            <param name="body"></param>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="T:Jiper.Net.FtpClient">
            <summary>
            FTP客户端操作类
            </summary>
        </member>
        <member name="P:Jiper.Net.FtpClient.FtpServer">
            <summary>
            Ftp服务器ip
            </summary>
        </member>
        <member name="P:Jiper.Net.FtpClient.Username">
            <summary>
            Ftp 指定用户名
            </summary>
        </member>
        <member name="P:Jiper.Net.FtpClient.Password">
            <summary>
            Ftp 指定用户密码
            </summary>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetAnonymousClient(System.String)">
            <summary>
            获取一个匿名登录的ftp客户端
            </summary>
            <param name="serverIp">服务器IP地址</param>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetClient(System.String,System.String,System.String)">
            <summary>
            获取一个匿名登录的ftp客户端
            </summary>
            <param name="serverIp">服务器ip</param>
            <param name="username">用户名</param>
            <param name="password">密码</param>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.Download(System.String,System.String,System.Boolean,System.Action{System.Int32,System.Int32})">
            <summary>
            从FTP服务器下载文件，指定本地路径和本地文件名
            </summary>
            <param name="remoteFileName">远程文件名</param>
            <param name="localFileName">保存本地的文件名（包含路径）</param>
            <param name="ifCredential">是否启用身份验证（false：表示允许用户匿名下载）</param>
            <param name="updateProgress">报告进度的处理(第一个参数：总大小，第二个参数：当前进度)</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.BrokenDownload(System.String,System.String,System.Boolean,System.Int64,System.Action{System.Int32,System.Int32})">
            <summary>
            从FTP服务器下载文件，指定本地路径和本地文件名（支持断点下载）
            </summary>
            <param name="remoteFileName">远程文件名</param>
            <param name="localFileName">保存本地的文件名（包含路径）</param>
            <param name="ifCredential">是否启用身份验证（false：表示允许用户匿名下载）</param>
            <param name="size">已下载文件流大小</param>
            <param name="updateProgress">报告进度的处理(第一个参数：总大小，第二个参数：当前进度)</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.Download(System.String,System.String,System.Boolean,System.Boolean,System.Action{System.Int32,System.Int32})">
            <summary>
            从FTP服务器下载文件，指定本地路径和本地文件名
            </summary>
            <param name="remoteFileName">远程文件名</param>
            <param name="localFileName">保存本地的文件名（包含路径）</param>
            <param name="ifCredential">是否启用身份验证（false：表示允许用户匿名下载）</param>
            <param name="updateProgress">报告进度的处理(第一个参数：总大小，第二个参数：当前进度)</param>
            <param name="brokenOpen">是否断点下载：true 会在localFileName 找是否存在已经下载的文件，并计算文件流大小</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.UploadFile(System.String,System.String,System.Action{System.Int32,System.Int32})">
            <summary>
            上传文件到FTP服务器
            </summary>
            <param name="relativePath">相对目录</param>
            <param name="localFullPathName">本地带有完整路径的文件名</param>
            <param name="updateProgress">报告进度的处理(第一个参数：总大小，第二个参数：当前进度)</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.UploadBroken(System.String,System.String,System.Action{System.Int32,System.Int32})">
            <summary>
            上传文件到FTP服务器(断点续传)
            </summary>
            <param name="localFullPath">本地文件全路径名称：C:\Users\JianKunKing\Desktop\IronPython脚本测试工具</param>
            <param name="remoteFilepath">远程文件所在文件夹路径</param>
            <param name="updateProgress">报告进度的处理(第一个参数：总大小，第二个参数：当前进度)</param>
            <returns></returns> 
        </member>
        <member name="M:Jiper.Net.FtpClient.RemoveSpaces(System.String)">
            <summary>
            去除空格
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetFileSize(System.String,System.String)">
            <summary>
            获取已上传文件大小
            </summary>
            <param name="filePath">文件名称</param>
            <param name="remoteFilepath">服务器文件路径</param>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetFilesDetails(System.String)">
            <summary>
            获取当前目录下明细(包含文件和文件夹)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetFiles(System.String,System.String)">
            <summary>
            获取当前目录下文件列表(仅文件)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetDirectories(System.String)">
            <summary>
            获取当前目录下所有的文件夹列表(仅文件夹)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.Delete(System.String)">
            <summary>
            删除文件
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Jiper.Net.FtpClient.RemoveDirectory(System.String)">
            <summary>
            删除文件夹
            </summary>
            <param name="dirPath"></param>
        </member>
        <member name="M:Jiper.Net.FtpClient.GetFileSize(System.String)">
            <summary>
            获取指定文件大小
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:Jiper.Net.FtpClient.DirectoryExist(System.String)">
            <summary>
            判断当前目录下指定的子目录是否存在
            </summary>
            <param name="remoteDirPath">指定的目录名</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.FileExist(System.String)">
            <summary>
            判断当前目录下指定的文件是否存在
            </summary>
            <param name="remoteFileName">远程文件名</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.MakeDir(System.String,System.String)">
            <summary>
            创建文件夹
            </summary>
            <param name="relativePath">路径</param>
            <param name="newDir">新建文件夹</param>
        </member>
        <member name="M:Jiper.Net.FtpClient.Rename(System.String,System.String,System.String)">
            <summary>
            改名
            </summary>
            <param name="relativePath">相对路径</param>
            <param name="currentFilename"></param>
            <param name="newFilename"></param>
        </member>
        <member name="M:Jiper.Net.FtpClient.MoveFile(System.String,System.String,System.String)">
            <summary>
            移动文件
            </summary>
            <param name="relativePath">相对路径</param>
            <param name="currentFilename"></param>
            <param name="newDirectory"></param>
        </member>
        <member name="M:Jiper.Net.IPHelper.CalcBroadcast(System.String,System.String)">
             <summary>
             计算广播地址算法
             <remarks>        
             计算方法 
            首先 计算网络地址 = IP地址  逻辑与   子网掩码 
            先把IP，子网掩码转为2进制，然后进行逻辑与运算，得出网络地址 
            <example>
            例： 
            IP 192.168.1.3  子网掩码 255.255.0.0 
            IP转二进制 11000000.10100100.00000001.00000011 
            子网掩码    11111111.11111111.00000000.00000000 
            与运算后    11000000.10100100.00000000.00000000 
            192.168.0.0这就是网络地址，其中子网掩码全1对应为网络号,全0对应的是主机号,
            即192.168.0.0对应的网络号为192.168,主机号为0.0.
            将网络地址主机部分全取反后得到的地址便是广播地址: 
            广播地址    11000000.10100100.11111111.11111111 
            换成10进制则为192.168.0.0 
            </example>
             </remarks>
             </summary>
        </member>
        <member name="T:NewLife.Ftp.FtpClient">
            <summary>
            Ftp客户端
            </summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.Hostname">
            <summary>主机名</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.Credentials">
            <summary>验证</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.UseDefaultCredentials">
            <summary>使用默认认证</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.UseBinary">
            <summary>获取或设置一个 Boolean 值，该值指定文件传输的数据类型。</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.LocalRequest">
            <summary>本地请求对象</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.Root">
            <summary>根</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.Files">
            <summary>文件</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.Directories">
            <summary>目录</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpClient.UserState">
            <summary>用户数据</summary>
        </member>
        <member name="E:NewLife.Ftp.FtpClient.OnDownloadFile">
            <summary>
            下载文件事件
            </summary>
        </member>
        <member name="E:NewLife.Ftp.FtpClient.OnDownloadFileFinished">
            <summary>
            下载文件完成事件
            </summary>
        </member>
        <member name="E:NewLife.Ftp.FtpClient.OnUploadFile">
            <summary>
            上传文件事件
            </summary>
        </member>
        <member name="E:NewLife.Ftp.FtpClient.OnUploadFileFinished">
            <summary>
            上传文件事件完成
            </summary>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.#ctor">
            <summary>
            构造一个Ftp客户端实例
            </summary>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.#ctor(System.String)">
            <summary>
            构造一个Ftp客户端实例
            </summary>
            <param name="hostname"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.#ctor(System.String,System.String,System.String)">
            <summary>
            构造一个Ftp客户端实例
            </summary>
            <param name="hostname"></param>
            <param name="user"></param>
            <param name="pass"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            构造一个Ftp客户端实例
            </summary>
            <param name="hostname"></param>
            <param name="user"></param>
            <param name="pass"></param>
            <param name="domain"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.ListDirectory(System.String)">
            <summary>
            列出目录
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.ListDirectoryDetails(System.String)">
            <summary>
            列出目录明细
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.ListDirectoryDetailsString(System.String)">
            <summary>
            
            </summary>
            <param name="directory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.UploadFile(System.String,System.String,NewLife.Ftp.FtpTransportMode)">
            <summary>
            上传文件
            </summary>
            <param name="localfile">本地文件</param>
            <param name="remotefile">远程文件</param>
            <param name="mode">模式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.UploadDirectory(System.String,NewLife.Ftp.FtpDirectory,NewLife.Ftp.FtpTransportMode)">
            <summary>
            上传目录
            </summary>
            <param name="localpath"></param>
            <param name="dir"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.DownloadFile(System.String,System.String,NewLife.Ftp.FtpTransportMode)">
            <summary>
            下载文件
            </summary>
            <param name="remotefile">远程文件</param>
            <param name="localfile">本地文件</param>
            <param name="mode">端点续传模式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.DownloadDirectory(NewLife.Ftp.FtpDirectory,System.String,NewLife.Ftp.FtpTransportMode)">
            <summary>
            下载目录
            </summary>
            <param name="dir"></param>
            <param name="localpath"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.DeleteFile(System.String)">
            <summary>
            删除
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.GetFileSize(System.String)">
            <summary>
            取文件大小
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.Rename(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="oldfile"></param>
            <param name="newfile"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.MakeDirectory(System.String)">
            <summary>
            建立目录
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.RemoveDirectory(System.String)">
            <summary>
            删除目录
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.GetFtpRequest(System.String)">
            <summary>
            取得Ftp请求对象
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.GetFtpRequest(System.Uri)">
            <summary>
            取得Ftp请求对象
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.GetResponse(System.Net.FtpWebRequest)">
            <summary>
            取响应
            </summary>
            <param name="ftp"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.GetStringResponse(System.Net.FtpWebRequest)">
            <summary>
            取得响应字符串
            </summary>
            <param name="ftp"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.GetSize(System.Net.FtpWebRequest)">
            <summary>
            取得响应大小
            </summary>
            <param name="ftp"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpClient.AdjustDir(System.String)">
            <summary>
            调整目录
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Ftp.FtpDirectory">
            <summary>
            Ftp目录
            </summary>
        </member>
        <member name="M:NewLife.Ftp.FtpDirectory.#ctor(NewLife.Ftp.FtpClient,System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="client"></param>
            <param name="line"></param>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpDirectory.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Ftp.FtpDirectory.Path">
            <summary>路径</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpDirectory.Client">
            <summary>Ftp客户端</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpDirectory.Files">
            <summary>该目录下的文件</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpDirectory.Directories">
            <summary>该目录下的子目录</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpDirectory.Parent">
            <summary>父目录</summary>
        </member>
        <member name="M:NewLife.Ftp.FtpDirectory.Contains(System.String)">
            <summary>
            是否包含指定的文件或者目录
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpDirectory.CreateDirectory(System.String)">
            <summary>
            建立子目录
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpDirectory.UploadFile(System.String,System.String,NewLife.Ftp.FtpTransportMode)">
            <summary>
            上传
            </summary>
            <param name="localfile"></param>
            <param name="remotefile"></param>
            <param name="mode">模式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpDirectory.UploadFile(System.String,NewLife.Ftp.FtpTransportMode)">
            <summary>
            上传
            </summary>
            <param name="localfile"></param>
            <param name="mode">模式</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Ftp.FtpFile">
            <summary>
            Ftp文件
            </summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.Path">
            <summary>路径</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.IsDirectory">
            <summary>是否目录</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.Size">
            <summary>大小</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.Permission">
            <summary>权限</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.FileDateTime">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.Client">
            <summary>Ftp客户端</summary>
        </member>
        <member name="P:NewLife.Ftp.FtpFile.Parent">
            <summary>父目录</summary>
        </member>
        <member name="M:NewLife.Ftp.FtpFile.#ctor(System.Text.RegularExpressions.Match,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="m"></param>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpFile.Create(System.String,System.String)">
            <summary>
            建立对象
            </summary>
            <param name="line"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpFile.ToString">
            <summary>
            已重载。
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Ftp.FtpFile.Download(System.String,NewLife.Ftp.FtpTransportMode)">
            <summary>
            下载该文件
            </summary>
            <param name="localfile"></param>
            <param name="mode"></param>
        </member>
        <member name="M:NewLife.Ftp.FtpFile.Delete">
            <summary>
            删除
            </summary>
        </member>
        <member name="T:NewLife.Ftp.FtpPath">
            <summary>
            Ftp路径
            </summary>
        </member>
        <member name="M:NewLife.Ftp.FtpPath.Combine(System.String,System.String)">
            <summary>
            合并路径
            </summary>
            <param name="path1"></param>
            <param name="path2"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Ftp.FtpTransportMode">
            <summary>
            Ftp传输模式
            </summary>
        </member>
        <member name="F:NewLife.Ftp.FtpTransportMode.None">
            <summary>
            默认
            </summary>
        </member>
        <member name="F:NewLife.Ftp.FtpTransportMode.OverWrite">
            <summary>
            覆盖
            </summary>
        </member>
        <member name="F:NewLife.Ftp.FtpTransportMode.Append">
            <summary>
            断点续传
            </summary>
        </member>
        <member name="T:NewLife.Ftp.FtpWebResponseException">
            <summary>
            Ftp响应异常
            </summary>
        </member>
        <member name="P:NewLife.Ftp.FtpWebResponseException.Response">
            <summary>响应</summary>
        </member>
        <member name="M:NewLife.Ftp.FtpWebResponseException.#ctor(System.Net.WebException)">
            <summary>
            
            </summary>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.Ftp.LoadFileEventArgs">
            <summary>
            上传/下载文件事件参数
            </summary>
        </member>
        <member name="P:NewLife.Ftp.LoadFileEventArgs.Src">
            <summary>Ftp文件</summary>
        </member>
        <member name="P:NewLife.Ftp.LoadFileEventArgs.SrcSize">
            <summary>源文件大小</summary>
        </member>
        <member name="P:NewLife.Ftp.LoadFileEventArgs.Des">
            <summary>目标文件</summary>
        </member>
        <member name="P:NewLife.Ftp.LoadFileEventArgs.DesSize">
            <summary>目标文件大小</summary>
        </member>
        <member name="T:NewLife.IP.Ip">
            <summary>IP搜索</summary>
        </member>
        <member name="P:NewLife.IP.Ip.DbFile">
            <summary>数据文件</summary>
        </member>
        <member name="M:NewLife.IP.Ip.GetAddress(System.String)">
            <summary>获取IP地址</summary>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IP.Ip.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.IP.Zip.Stream">
            <summary>数据流</summary>
        </member>
        <member name="M:NewLife.IP.Zip.Finalize">
            <summary>析构</summary>
        </member>
        <member name="M:NewLife.IP.Zip.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="T:NewLife.IP.Zip.IndexInfo">
            <summary>索引结构</summary>
        </member>
        <member name="T:NewLife.Caching.Cache">
            <summary>缓存</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Default">
            <summary>默认缓存</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Expire">
            <summary>默认过期时间。避免Set操作时没有设置过期时间，默认0秒表示不过期</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Item(System.String)">
            <summary>获取和设置缓存，使用默认过期时间</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Cache.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.Init(System.String)">
            <summary>使用连接字符串初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.Cache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Set``1(System.String,``0,System.Int32)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Get``1(System.String)">
            <summary>获取缓存项</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.Cache.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.Cache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetOrAdd``1(System.String,System.Func{System.String,``0},System.Int32)">
            <summary>获取 或 添加 缓存数据，在数据不存在时执行委托请求数据</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="callback"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Commit">
            <summary>提交变更。部分提供者需要刷盘</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.AcquireLock(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <param name="msExpire">锁超时时间，单位毫秒</param>
            <param name="throwOnFailure">失败时是否抛出异常，如果不抛出异常，可通过返回null得知申请锁失败</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Bench(System.Boolean,System.Int32)">
            <summary>多线程性能测试</summary>
            <param name="rand">随机读写。顺序，每个线程多次操作一个key；随机，每个线程每次操作不同key</param>
            <param name="batch">批量操作。默认0不分批，分批仅针对随机读写，对顺序读写的单key操作没有意义</param>
            <remarks>
            Memory性能测试[顺序]，逻辑处理器 32 个 2,000MHz Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz
            
            测试 10,000,000 项，  1 线程
            赋值 10,000,000 项，  1 线程，耗时   3,764ms 速度 2,656,748 ops
            读取 10,000,000 项，  1 线程，耗时   1,296ms 速度 7,716,049 ops
            删除 10,000,000 项，  1 线程，耗时   1,230ms 速度 8,130,081 ops
            
            测试 20,000,000 项，  2 线程
            赋值 20,000,000 项，  2 线程，耗时   3,088ms 速度 6,476,683 ops
            读取 20,000,000 项，  2 线程，耗时   1,051ms 速度 19,029,495 ops
            删除 20,000,000 项，  2 线程，耗时   1,011ms 速度 19,782,393 ops
            
            测试 40,000,000 项，  4 线程
            赋值 40,000,000 项，  4 线程，耗时   3,060ms 速度 13,071,895 ops
            读取 40,000,000 项，  4 线程，耗时   1,023ms 速度 39,100,684 ops
            删除 40,000,000 项，  4 线程，耗时     994ms 速度 40,241,448 ops
            
            测试 80,000,000 项，  8 线程
            赋值 80,000,000 项，  8 线程，耗时   3,124ms 速度 25,608,194 ops
            读取 80,000,000 项，  8 线程，耗时   1,171ms 速度 68,317,677 ops
            删除 80,000,000 项，  8 线程，耗时   1,199ms 速度 66,722,268 ops
            
            测试 320,000,000 项， 32 线程
            赋值 320,000,000 项， 32 线程，耗时  13,857ms 速度 23,093,021 ops
            读取 320,000,000 项， 32 线程，耗时   1,950ms 速度 164,102,564 ops
            删除 320,000,000 项， 32 线程，耗时   3,359ms 速度 95,266,448 ops
            
            测试 320,000,000 项， 64 线程
            赋值 320,000,000 项， 64 线程，耗时   9,648ms 速度 33,167,495 ops
            读取 320,000,000 项， 64 线程，耗时   1,974ms 速度 162,107,396 ops
            删除 320,000,000 项， 64 线程，耗时   1,907ms 速度 167,802,831 ops
            
            测试 320,000,000 项，256 线程
            赋值 320,000,000 项，256 线程，耗时  12,429ms 速度 25,746,238 ops
            读取 320,000,000 项，256 线程，耗时   1,907ms 速度 167,802,831 ops
            删除 320,000,000 项，256 线程，耗时   2,350ms 速度 136,170,212 ops
            </remarks>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchOne(System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchGet(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>读取测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchSet(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>赋值测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchRemove(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>删除测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchInc(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>累加测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Cache.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.CacheLock">
            <summary>分布式锁</summary>
        </member>
        <member name="F:NewLife.Caching.CacheLock._hasLock">
            <summary>
            是否持有锁
            </summary>
        </member>
        <member name="P:NewLife.Caching.CacheLock.Key">
            <summary>键</summary>
        </member>
        <member name="M:NewLife.Caching.CacheLock.#ctor(NewLife.Caching.ICache,System.String)">
            <summary>实例化</summary>
            <param name="client"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.CacheLock.Acquire(System.Int32,System.Int32)">
            <summary>申请锁</summary>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <param name="msExpire">锁过期时间，单位毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.CacheLock.AcquireOnce(System.Int32)">
            <summary>
            尝试一次加锁
            </summary>
            <param name="msExpire"> ms </param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.CacheLock.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Caching.ICache">
            <summary>缓存接口</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Expire">
            <summary>默认缓存时间。默认0秒表示不过期</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Item(System.String)">
            <summary>获取和设置缓存，永不过期</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.ICache.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.ICache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Set``1(System.String,``0,System.Int32)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.ICache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Get``1(System.String)">
            <summary>获取缓存项</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.ICache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
        </member>
        <member name="M:NewLife.Caching.ICache.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.ICache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.ICache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <remarks>
            常常配合Increment使用，用于累加到一定数后重置归零，又避免多线程冲突。
            </remarks>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败，解决缓存穿透问题</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetOrAdd``1(System.String,System.Func{System.String,``0},System.Int32)">
            <summary>获取 或 添加 缓存数据，在数据不存在时执行委托请求数据</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="callback"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Commit">
            <summary>提交变更。部分提供者需要刷盘</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.AcquireLock(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout">锁等待时间，单位毫秒</param>
            <param name="msExpire">锁超时时间，单位毫秒</param>
            <param name="throwOnFailure">失败时是否抛出异常，如果不抛出异常，可通过返回null得知申请锁失败</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Bench(System.Boolean,System.Int32)">
            <summary>多线程性能测试</summary>
            <param name="rand">随机读写。顺序，每个线程多次操作一个key；随机，每个线程每次操作不同key</param>
            <param name="batch">批量操作。默认0不分批，分批仅针对随机读写，对顺序读写的单key操作没有意义</param>
        </member>
        <member name="T:NewLife.Caching.IProducerConsumer`1">
            <summary>轻量级生产者消费者接口</summary>
            <remarks>
            不一定支持Ack机制；也不支持消息体与消息键分离
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Caching.IProducerConsumer`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="P:NewLife.Caching.IProducerConsumer`1.IsEmpty">
            <summary>集合是否为空</summary>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Add(`0[])">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Take(System.Int32)">
            <summary>消费获取一批</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.TakeOne(System.Int32)">
            <summary>消费获取一个</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.TakeOneAsync(System.Int32)">
            <summary>异步消费获取一个</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Acknowledge(System.String[])">
            <summary>确认消费</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.MemoryCache">
            <summary>默认字典缓存</summary>
        </member>
        <member name="F:NewLife.Caching.MemoryCache._cache">
            <summary>缓存核心</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Capacity">
            <summary>容量。容量超标时，采用LRU机制删除，默认100_000</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Period">
            <summary>定时清理时间，默认60秒</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Instance">
            <summary>默认缓存</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.#ctor">
            <summary>实例化一个内存字典缓存</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Count">
            <summary>缓存项。原子计数</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Keys">
            <summary>所有键。实际返回只读列表新实例，数据量较大时注意性能</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Init(System.String)">
            <summary>初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAdd``1(System.String,``0,System.Int32)">
            <summary>获取或添加缓存项</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Set``1(System.String,``0,System.Int32)">
            <summary>添加缓存项，已存在时更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Get``1(System.String)">
            <summary>获取缓存项，不存在时返回默认值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns>实际移除个数</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
            <returns>设置是否成功</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetExpire(System.String)">
            <summary>获取缓存项有效期，不存在时返回Zero</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新，常用于锁争夺</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败</summary>
            <remarks>
            在 MemoryCache 中，如果某个key过期，在清理之前仍然可以通过TryGet访问，并且更新访问时间，避免被清理。
            </remarks>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAdd``1(System.String,System.Func{System.String,``0},System.Int32)">
            <summary>获取 或 添加 缓存数据，在数据不存在时执行委托请求数据</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="callback"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <remarks>基于HashSet，非线程安全</remarks>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAddItem(System.String,System.Func{System.String,System.Object})">
            <summary>获取 或 添加 缓存项</summary>
            <param name="key"></param>
            <param name="valueFactory"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.MemoryCache.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.VisitTime">
            <summary>访问时间</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.#ctor(System.Object,System.Int32)">
            <summary>构造缓存项</summary>
            <param name="value"></param>
            <param name="expire"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Set(System.Object,System.Int32)">
            <summary>设置数值和过期时间</summary>
            <param name="value"></param>
            <param name="expire"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Visit">
            <summary>更新访问时间并返回数值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Inc(System.Object)">
            <summary>递增</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Dec(System.Object)">
            <summary>递减</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Caching.MemoryCache.clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Save(System.IO.Stream)">
            <summary>保存到数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Load(System.IO.Stream)">
            <summary>从数据流加载</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Save(System.String,System.Boolean)">
            <summary>保存到文件</summary>
            <param name="file"></param>
            <param name="compressed"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Load(System.String,System.Boolean)">
            <summary>从文件加载</summary>
            <param name="file"></param>
            <param name="compressed"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.BenchOne(System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="T:NewLife.Caching.MemoryQueue`1">
            <summary>生产者消费者</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.#ctor">
            <summary>实例化内存队列</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>实例化内存队列</summary>
            <param name="collection"></param>
        </member>
        <member name="P:NewLife.Caching.MemoryQueue`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryQueue`1.IsEmpty">
            <summary>集合是否为空</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Add(`0[])">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Take(System.Int32)">
            <summary>消费获取</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.TakeOne(System.Int32)">
            <summary>消费一个</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.TakeOneAsync(System.Int32)">
            <summary>消费获取，异步阻塞</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>消费获取，异步阻塞</summary>
            <param name="timeout">超时。默认0秒，永久等待</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Acknowledge(System.String[])">
            <summary>确认消费</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Redis">
            <summary>Redis客户端</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/redis
            
            强烈建议保持唯一的Redis对象供多次使用，Redis内部有连接池并且支持多线程并发访问。
            高级功能需要引用NewLife.Redis，然后实例化FullRedis类。
            </remarks>
        </member>
        <member name="P:NewLife.Caching.Redis.Server">
            <summary>服务器，带端口。例如127.0.0.1:6397，支持逗号分隔的多地址，网络异常时，自动切换到其它节点，60秒后切回来</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.UserName">
            <summary>用户名。Redis6.0支持</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Db">
            <summary>目标数据库。默认0</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Timeout">
            <summary>读写超时时间。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Retry">
            <summary>出错重试次数。如果出现协议解析错误，可以重试的次数，默认3</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.FullPipeline">
            <summary>完全管道。读取操作是否合并进入管道，默认false</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.AutoPipeline">
            <summary>自动管道。管道操作达到一定数量时，自动提交，默认0</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Encoder">
            <summary>编码器。决定对象存储在redis中的格式，默认json</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.ThrowOnFailure">
            <summary>失败时抛出异常。默认true</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.MaxMessageSize">
            <summary>最大消息大小。超过时抛出异常，默认1024*1024字节，行业标准是32k算大Value，这里超过1m报错</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Counter">
            <summary>性能计数器</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Tracer">
            <summary>性能跟踪器。仅记录read/write，形成调用链，key在tag中，没有记录异常。高速海量操作时不建议开启</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Info">
            <summary>服务器信息</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.#ctor(System.String,System.String,System.Int32)">
            <summary>实例化Redis，指定服务器地址、密码、库</summary>
            <param name="server"></param>
            <param name="password"></param>
            <param name="db"></param>
        </member>
        <member name="M:NewLife.Caching.Redis.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>实例化Redis，指定服务器地址、用户、密码、库</summary>
            <param name="server"></param>
            <param name="username"></param>
            <param name="password"></param>
            <param name="db"></param>
        </member>
        <member name="M:NewLife.Caching.Redis.#ctor(System.IServiceProvider,System.String)">
            <summary>按照配置服务实例化Redis，用于NETCore依赖注入</summary>
            <param name="provider">服务提供者，将要解析IConfigProvider</param>
            <param name="name">缓存名称，也是配置中心key</param>
        </member>
        <member name="M:NewLife.Caching.Redis.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.Redis.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Init(System.String)">
            <summary>使用连接字符串初始化</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.Redis.OnCreate">
            <summary>创建连接客户端</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Redis.Pool">
            <summary>连接池</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.Execute``1(System.String,System.Func{NewLife.Caching.RedisClient,``0},System.Boolean)">
            <summary>执行命令</summary>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="key">命令key，用于选择集群节点</param>
            <param name="func">回调函数</param>
            <param name="write">是否写入操作</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.ExecuteAsync``1(System.String,System.Func{NewLife.Caching.RedisClient,System.Threading.Tasks.Task{``0}},System.Boolean)">
            <summary>异步执行命令</summary>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="key">命令key，用于选择集群节点</param>
            <param name="func">回调函数</param>
            <param name="write">是否写入操作</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.StartPipeline">
            <summary>开始管道模式</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.StopPipeline(System.Boolean)">
            <summary>结束管道模式</summary>
            <param name="requireResult">要求结果。默认true</param>
        </member>
        <member name="M:NewLife.Caching.Redis.Commit">
            <summary>提交变更。处理某些残留在管道里的命令</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.CreateSub(System.Int32)">
            <summary>为同一服务器创建不同Db的子级库</summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Redis.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Keys">
            <summary>获取所有键，限制10000项，超额请使用FullRedis.Search</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.GetInfo(System.Boolean)">
            <summary>获取信息</summary>
            <param name="all">是否获取全部信息，包括Commandstats</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Set``1(System.String,``0,System.Int32)">
            <summary>单个实体项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.Redis.Get``1(System.String)">
            <summary>获取单体</summary>
            <param name="key">键</param>
        </member>
        <member name="M:NewLife.Caching.Redis.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
        </member>
        <member name="M:NewLife.Caching.Redis.Clear">
            <summary>清空所有缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.ContainsKey(System.String)">
            <summary>是否存在</summary>
            <param name="key">键</param>
        </member>
        <member name="M:NewLife.Caching.Redis.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
        </member>
        <member name="M:NewLife.Caching.Redis.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.Redis.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.TryGetValue``1(System.String,``0@)">
            <summary>尝试获取指定键，返回是否包含值。有可能缓存项刚好是默认值，或者只是反序列化失败</summary>
            <remarks>
            在 Redis 中，可能有key（此时TryGet返回true），但是因为反序列化失败，从而得不到value。
            </remarks>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值。即使有值也不一定能够返回，可能缓存项刚好是默认值，或者只是反序列化失败</param>
            <returns>返回是否包含值，即使反序列化失败</returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Increment(System.String,System.Double)">
            <summary>累加，原子操作，乘以100后按整数操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Decrement(System.String,System.Double)">
            <summary>递减，原子操作，乘以100后按整数操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Bench(System.Boolean,System.Int32)">
            <summary>性能测试</summary>
            <remarks>
            Redis性能测试[随机]，批大小[100]，逻辑处理器 40 个 2,400MHz Intel(R) Xeon(R) CPU E5-2640 v4 @ 2.40GHz
            测试 100,000 项，  1 线程
            赋值 100,000 项，  1 线程，耗时     418ms 速度   239,234 ops
            读取 100,000 项，  1 线程，耗时     520ms 速度   192,307 ops
            删除 100,000 项，  1 线程，耗时     125ms 速度   800,000 ops
            测试 200,000 项，  2 线程
            赋值 200,000 项，  2 线程，耗时     548ms 速度   364,963 ops
            读取 200,000 项，  2 线程，耗时     549ms 速度   364,298 ops
            删除 200,000 项，  2 线程，耗时     315ms 速度   634,920 ops
            测试 400,000 项，  4 线程
            赋值 400,000 项，  4 线程，耗时     694ms 速度   576,368 ops
            读取 400,000 项，  4 线程，耗时     697ms 速度   573,888 ops
            删除 400,000 项，  4 线程，耗时     438ms 速度   913,242 ops
            测试 800,000 项，  8 线程
            赋值 800,000 项，  8 线程，耗时   1,206ms 速度   663,349 ops
            读取 800,000 项，  8 线程，耗时   1,236ms 速度   647,249 ops
            删除 800,000 项，  8 线程，耗时     791ms 速度 1,011,378 ops
            测试 4,000,000 项， 40 线程
            赋值 4,000,000 项， 40 线程，耗时   4,848ms 速度   825,082 ops
            读取 4,000,000 项， 40 线程，耗时   5,399ms 速度   740,877 ops
            删除 4,000,000 项， 40 线程，耗时   6,281ms 速度   636,841 ops
            测试 4,000,000 项， 64 线程
            赋值 4,000,000 项， 64 线程，耗时   6,806ms 速度   587,716 ops
            读取 4,000,000 项， 64 线程，耗时   5,365ms 速度   745,573 ops
            删除 4,000,000 项， 64 线程，耗时   6,716ms 速度   595,592 ops
            </remarks>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Redis.BenchOne(System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="M:NewLife.Caching.Redis.BenchInc(System.String,System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>累加测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="P:NewLife.Caching.Redis.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Caching.RedisClient">
            <summary>Redis客户端</summary>
            <remarks>
            以极简原则进行设计，每个客户端不支持并行命令处理，可通过多客户端多线程解决。
            </remarks>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Server">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Host">
            <summary>宿主</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Logined">
            <summary>是否已登录</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.LoginTime">
            <summary>登录时间</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Busy">
            <summary>是否正在处理命令</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.#ctor(NewLife.Caching.Redis,NewLife.Net.NetUri)">
            <summary>实例化</summary>
            <param name="redis"></param>
            <param name="server"></param>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetStream(System.Boolean)">
            <summary>新建连接获取数据流</summary>
            <param name="create">新建连接</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetRequest(System.IO.Stream,System.String,NewLife.Data.Packet[],System.Object[])">
            <summary>发出请求</summary>
            <param name="ms"></param>
            <param name="cmd"></param>
            <param name="args"></param>
            <param name="oriArgs">原始参数，仅用于输出日志</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetResponse(System.IO.Stream,System.Int32)">
            <summary>接收响应</summary>
            <param name="ns"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ExecuteCommand(System.String,NewLife.Data.Packet[],System.Object[])">
            <summary>执行命令，发请求，取响应</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <param name="oriArgs">原始参数，仅用于输出日志</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetResponseAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>异步接收响应</summary>
            <param name="ns">网络数据流</param>
            <param name="count">响应个数</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ExecuteCommandAsync(System.String,NewLife.Data.Packet[],System.Object[],System.Threading.CancellationToken)">
            <summary>异步执行命令，发请求，取响应</summary>
            <param name="cmd">命令</param>
            <param name="args">参数数组</param>
            <param name="oriArgs">原始参数，仅用于输出日志</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Reset">
            <summary>重置。干掉历史残留数据</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Execute(System.String,System.Object[])">
            <summary>执行命令。返回字符串、Packet、Packet[]</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Execute``1(System.String,System.Object[])">
            <summary>执行命令。返回基本类型、对象、对象数组</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.TryExecute``1(System.String,System.Object[],``0@)">
            <summary>尝试执行命令。返回基本类型、对象、对象数组</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ReadMore``1">
            <summary>读取更多。用于PubSub等多次读取命令</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ExecuteAsync(System.String,System.Object[],System.Threading.CancellationToken)">
            <summary>异步执行命令。返回字符串、Packet、Packet[]</summary>
            <param name="cmd">命令</param>
            <param name="args">参数数组</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ExecuteAsync``1(System.String,System.Object[])">
            <summary>异步执行命令。返回基本类型、对象、对象数组</summary>
            <param name="cmd">命令</param>
            <param name="args">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ExecuteAsync``1(System.String,System.Object[],System.Threading.CancellationToken)">
            <summary>异步执行命令。返回基本类型、对象、对象数组</summary>
            <param name="cmd">命令</param>
            <param name="args">参数数组</param>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ReadMoreAsync``1(System.Threading.CancellationToken)">
            <summary>读取更多。用于PubSub等多次读取命令</summary>
            <param name="cancellationToken">取消通知</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.TryChangeType(System.Object,System.Type,System.Object@)">
            <summary>尝试转换类型</summary>
            <param name="value"></param>
            <param name="type"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.RedisClient.PipelineCommands">
            <summary>管道命令个数</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.StartPipeline">
            <summary>开始管道模式</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.StopPipeline(System.Boolean)">
            <summary>结束管道模式</summary>
            <param name="requireResult">要求结果</param>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Ping">
            <summary>心跳</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Select(System.Int32)">
            <summary>选择Db</summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Auth(System.String,System.String)">
            <summary>验证密码</summary>
            <param name="username"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Quit">
            <summary>退出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>批量设置</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetHeaderBytes(System.String,System.Int32)">
            <summary>获取命令对应的字节数组，全局缓存</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Caching.IRedisEncoder">
            <summary>Redis编码器</summary>
        </member>
        <member name="M:NewLife.Caching.IRedisEncoder.Encode(System.Object)">
            <summary>数值转字节数组</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IRedisEncoder.Decode(NewLife.Data.Packet,System.Type)">
            <summary>字节数组转对象</summary>
            <param name="pk"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisJsonEncoder">
            <summary>Redis编码器</summary>
        </member>
        <member name="P:NewLife.Caching.RedisJsonEncoder.ThrowOnError">
            <summary>解码出错时抛出异常。默认false不抛出异常，仅返回默认值</summary>
        </member>
        <member name="M:NewLife.Caching.RedisJsonEncoder.Encode(System.Object)">
            <summary>数值转字节数组</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisJsonEncoder.Decode(NewLife.Data.Packet,System.Type)">
            <summary>字节数组转对象</summary>
            <param name="pk"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Common.RedisException">
            <summary>Redis异常</summary>
        </member>
        <member name="M:NewLife.Caching.Common.RedisException.#ctor(System.String)">
            <summary>实例化Redis异常</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Caching.Common.RedisException.#ctor(System.String,System.Exception)">
            <summary>实例化Redis异常</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="T:NewLife.Caching.FullRedis">
            <summary>增强版Redis</summary>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Register">
            <summary>注册</summary>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Create(System.String)">
            <summary>根据连接字符串创建</summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.FullRedis.Mode">
            <summary>模式</summary>
        </member>
        <member name="P:NewLife.Caching.FullRedis.Cluster">
            <summary>集群</summary>
        </member>
        <member name="M:NewLife.Caching.FullRedis.#ctor">
            <summary>实例化增强版Redis</summary>
        </member>
        <member name="M:NewLife.Caching.FullRedis.#ctor(System.String)">
            <summary>
            Redis使用配置连接
            "server=103.151.229.60:36379;password=1qazxcvbnm;db=11"
            </summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.FullRedis.#ctor(System.String,System.String,System.Int32)">
            <summary>实例化增强版Redis</summary>
            <param name="server"></param>
            <param name="password"></param>
            <param name="db"></param>
        </member>
        <member name="M:NewLife.Caching.FullRedis.#ctor(System.IServiceProvider,System.String)">
            <summary>按照配置服务实例化Redis，用于NETCore依赖注入</summary>
            <param name="provider">服务提供者，将要解析IConfigProvider</param>
            <param name="name">缓存名称，也是配置中心key</param>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Init(System.String)">
            <summary>初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Execute``1(System.String,System.Func{NewLife.Caching.RedisClient,``0},System.Boolean)">
            <summary>重载执行，支持集群</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="func"></param>
            <param name="write">是否写入操作</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetQueue``1(System.String)">
            <summary>获取队列，快速LIST结构，无需确认</summary>
            <typeparam name="T"></typeparam>
            <param name="topic">消息队列主题</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetReliableQueue``1(System.String)">
            <summary>获取可靠队列，消息需要确认</summary>
            <typeparam name="T"></typeparam>
            <param name="topic">消息队列主题</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetDelayQueue``1(System.String)">
            <summary>获取延迟队列</summary>
            <typeparam name="T"></typeparam>
            <param name="topic">消息队列主题</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetStack``1(System.String)">
            <summary>获取栈</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetSet``1(System.String)">
            <summary>获取Set</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetStream``1(System.String)">
            <summary>获取消息流</summary>
            <typeparam name="T"></typeparam>
            <param name="topic">消息队列主题</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetSortedSet``1(System.String)">
            <summary>获取有序集合</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Append(System.String,System.String)">
            <summary>附加字符串</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns>返回字符串长度</returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.GetRange(System.String,System.Int32,System.Int32)">
            <summary>获取字符串区间</summary>
            <param name="key"></param>
            <param name="start"></param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SetRange(System.String,System.Int32,System.String)">
            <summary>设置字符串区间</summary>
            <param name="key"></param>
            <param name="offset"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.StrLen(System.String)">
            <summary>字符串长度</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Rename(System.String,System.String,System.Boolean)">
            <summary>重命名指定键</summary>
            <param name="key"></param>
            <param name="newKey"></param>
            <param name="overwrite"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Search(NewLife.Caching.Models.SearchModel)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="model">搜索模型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.Search(System.String,System.Int32)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="pattern">匹配表达式</param>
            <param name="count">返回个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SearchSpace(System.String)">
            <summary>
            查找空间下所有值
            </summary>
            <param name="pattern"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.RPUSH``1(System.String,``0[])">
            <summary>向列表末尾插入</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.LPUSH``1(System.String,``0[])">
            <summary>向列表头部插入</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.RPOP``1(System.String)">
            <summary>从列表末尾弹出一个元素</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.RPOPLPUSH``1(System.String,System.String)">
            <summary>从列表末尾弹出一个元素并插入到另一个列表头部</summary>
            <remarks>适用于做安全队列</remarks>
            <typeparam name="T"></typeparam>
            <param name="source">源列表名称</param>
            <param name="destination">元素后写入的新列表名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.BRPOPLPUSH``1(System.String,System.String,System.Int32)">
            <summary>
            从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。
            适用于做安全队列(通过secTimeout决定阻塞时长)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source">源列表名称</param>
            <param name="destination">元素后写入的新列表名称</param>
            <param name="secTimeout">设置的阻塞时长，单位为秒。设置前请确认该值不能超过FullRedis.Timeout 否则会出现异常</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.LPOP``1(System.String)">
            <summary>从列表头部弹出一个元素</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.BRPOP``1(System.String[],System.Int32)">
            <summary>从列表末尾弹出一个元素，阻塞</summary>
            <remarks>
            RPOP 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。
            该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <param name="secTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.BRPOP``1(System.String,System.Int32)">
            <summary>从列表末尾弹出一个元素，阻塞</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="secTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.BLPOP``1(System.String[],System.Int32)">
            <summary>从列表头部弹出一个元素，阻塞</summary>
            <remarks>
            命令 LPOP 的阻塞版本，这是因为当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞。
            当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <param name="secTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.BLPOP``1(System.String,System.Int32)">
            <summary>从列表头部弹出一个元素，阻塞</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="secTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SADD``1(System.String,``0[])">
            <summary>向集合添加多个元素</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SREM``1(System.String,``0[])">
            <summary>向集合删除多个元素</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SMEMBERS``1(System.String)">
            <summary>获取所有元素</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SCARD(System.String)">
            <summary>返回集合元素个数</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SISMEMBER``1(System.String,``0)">
            <summary>成员 member 是否是存储的集合 key的成员</summary>
            <param name="key"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SMOVE``1(System.String,System.String,``0)">
            <summary>将member从source集合移动到destination集合中</summary>
            <param name="key"></param>
            <param name="dest"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SRANDMEMBER``1(System.String,System.Int32)">
            <summary>随机获取多个</summary>
            <param name="key"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.FullRedis.SPOP``1(System.String,System.Int32)">
            <summary>随机获取并弹出</summary>
            <param name="key"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.HyperLogLog">
            <summary>超级基数估算</summary>
            <remarks>
            HyperLogLog可以使用固定且很少的内存（每个HyperLogLog结构需要12K字节再加上key本身的几个字节）来存储集合的唯一元素。
            返回的可见集合基数并不是精确值， 而是一个带有 0.81% 标准错误（standard error）的近似值。
            例如为了记录一天会执行多少次各不相同的搜索查询， 一个程序可以在每次执行搜索查询时调用一次PFADD， 并通过调用PFCOUNT命令来获取这个记录的近似结果。
            注意: 这个命令的一个副作用是可能会导致HyperLogLog内部被更改，出于缓存的目的,它会用8字节的来记录最近一次计算得到基数,所以PFCOUNT命令在技术上是个写命令。
            </remarks>
        </member>
        <member name="M:NewLife.Caching.HyperLogLog.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化超级基数</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.HyperLogLog.Add(System.String[])">
            <summary>添加</summary>
            <remarks>
            这个命令的一个副作用是它可能会更改这个HyperLogLog的内部来反映在每添加一个唯一的对象时估计的基数(集合的基数)。
            如果一个HyperLogLog的估计的近似基数在执行命令过程中发了变化， PFADD 返回1，否则返回0，
            如果指定的key不存在，这个命令会自动创建一个空的HyperLogLog结构（指定长度和编码的字符串）。
            如果在调用该命令时仅提供变量名而不指定元素也是可以的，如果这个变量名存在，则不会有任何操作，如果不存在，则会创建一个数据结构（返回1）
            </remarks>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.HyperLogLog.Count">
            <summary>近似基数</summary>
            <remarks>
            返回存储在HyperLogLog结构体的该变量的近似基数，如果该变量不存在,则返回0。
            当参数为多个key时，返回这些HyperLogLog并集的近似基数，这个值是将所给定的所有key的HyperLoglog结构合并到一个临时的HyperLogLog结构中计算而得到的。
            </remarks>
        </member>
        <member name="M:NewLife.Caching.HyperLogLog.Merge(System.String[])">
            <summary>合并</summary>
            <remarks>
            将多个 HyperLogLog 合并（merge）为一个 HyperLogLog ， 合并后的 HyperLogLog 的基数接近于所有输入 HyperLogLog 的可见集合（observed set）的并集。
            合并得出的 HyperLogLog 会被储存在目标变量（第一个参数）里面， 如果该键并不存在， 那么命令在执行之前， 会先为该键创建一个空的。
            </remarks>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Models.ConsumerInfo">
            <summary>消费者信息</summary>
        </member>
        <member name="P:NewLife.Caching.Models.ConsumerInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.Models.ConsumerInfo.Pending">
            <summary>挂起数</summary>
        </member>
        <member name="P:NewLife.Caching.Models.ConsumerInfo.Idle">
            <summary>空闲</summary>
        </member>
        <member name="M:NewLife.Caching.Models.ConsumerInfo.Parse(System.Object[])">
            <summary>分析</summary>
            <param name="vs"></param>
        </member>
        <member name="T:NewLife.Caching.Models.GeoInfo">
            <summary>地理坐标</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GeoInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GeoInfo.Longitude">
            <summary>经度</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GeoInfo.Latitude">
            <summary>纬度</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GeoInfo.Distance">
            <summary>距离</summary>
        </member>
        <member name="T:NewLife.Caching.Models.GroupInfo">
            <summary>消费组信息</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GroupInfo.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GroupInfo.Consumers">
            <summary>消费者</summary>
        </member>
        <member name="P:NewLife.Caching.Models.GroupInfo.Pending">
            <summary>挂起数</summary>
        </member>
        <member name="M:NewLife.Caching.Models.GroupInfo.Parse(System.Object[])">
            <summary>分析</summary>
            <param name="vs"></param>
        </member>
        <member name="T:NewLife.Caching.Models.Message">
            <summary>消息队列中消费得到的消息</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Message.Id">
            <summary>消息标识</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Message.Body">
            <summary>消息体</summary>
        </member>
        <member name="M:NewLife.Caching.Models.Message.GetBody``1">
            <summary>解码消息体为具体类型</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Models.Node">
            <summary>服务器节点。内部连接池</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Owner">
            <summary>拥有者</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.EndPoint">
            <summary>当前节点地址</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.ID">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Flags">
            <summary>标志</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Master">
            <summary>主机。当前节点对应的主机</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.LinkState">
            <summary>链接状态</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Slave">
            <summary>是否从节点</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Slaves">
            <summary>当前节点的从节点集合</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Slots">
            <summary>本节点数据槽</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Importings">
            <summary>正在转入</summary>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Migratings">
            <summary>正在转出</summary>
        </member>
        <member name="M:NewLife.Caching.Models.Node.ToString">
            <summary>已重载。返回地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Models.Node.Parse(System.String)">
            <summary>分析结果行</summary>
            <param name="line"></param>
        </member>
        <member name="M:NewLife.Caching.Models.Node.Contain(System.Int32)">
            <summary>是否包含数据槽</summary>
            <param name="slot"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Models.Node.GetSlots">
            <summary>返回所有槽</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Models.Node.Pool">
            <summary>连接池</summary>
        </member>
        <member name="M:NewLife.Caching.Models.Node.Execute``1(System.Func{NewLife.Caching.RedisClient,``0},System.Boolean)">
            <summary>执行命令</summary>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="func">回调函数</param>
            <param name="write">是否写入操作</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Models.PendingInfo">
            <summary>等待信息</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingInfo.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingInfo.StartId">
            <summary>开始Id</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingInfo.EndId">
            <summary>结束Id</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingInfo.Consumers">
            <summary>消费者挂起情况</summary>
        </member>
        <member name="M:NewLife.Caching.Models.PendingInfo.Parse(System.Object[])">
            <summary>分析</summary>
            <param name="vs"></param>
        </member>
        <member name="T:NewLife.Caching.Models.PendingItem">
            <summary>等待项</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingItem.Id">
            <summary>消息Id</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingItem.Consumer">
            <summary>消费者</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingItem.Idle">
            <summary>空闲时间。从读取到现在经历过的毫秒数</summary>
        </member>
        <member name="P:NewLife.Caching.Models.PendingItem.Delivery">
            <summary>传递次数</summary>
        </member>
        <member name="M:NewLife.Caching.Models.PendingItem.Parse(System.Object[])">
            <summary>分析</summary>
            <param name="vs"></param>
        </member>
        <member name="T:NewLife.Caching.Models.RedisQueueStatus">
            <summary>Redis队列状态</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.Key">
            <summary>标识消费者的唯一Key</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.MachineName">
            <summary>机器名</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.UserName">
            <summary>用户名</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.ProcessId">
            <summary>进程</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.Ip">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.CreateTime">
            <summary>开始时间</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.Consumes">
            <summary>消费消息数</summary>
        </member>
        <member name="P:NewLife.Caching.Models.RedisQueueStatus.Acks">
            <summary>确认消息数</summary>
        </member>
        <member name="T:NewLife.Caching.Models.SearchModel">
            <summary>模糊搜索模型</summary>
        </member>
        <member name="P:NewLife.Caching.Models.SearchModel.Pattern">
            <summary>匹配表达式</summary>
        </member>
        <member name="P:NewLife.Caching.Models.SearchModel.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.Models.SearchModel.Position">
            <summary>开始位置，同时由内部填充返回</summary>
        </member>
        <member name="T:NewLife.Caching.Models.Slot">
            <summary>数据槽区间</summary>
        </member>
        <member name="F:NewLife.Caching.Models.Slot.From">
            <summary>起始</summary>
        </member>
        <member name="F:NewLife.Caching.Models.Slot.To">
            <summary>结束</summary>
        </member>
        <member name="M:NewLife.Caching.Models.Slot.ToString">
            <summary>已重载。返回区间</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Models.StreamInfo">
            <summary>消息流信息</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.RadixTreeKeys">
            <summary>基数树</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.RadixTreeNodes">
            <summary>基数树节点数</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.Groups">
            <summary>消费组</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.LastGeneratedId">
            <summary>最后生成Id</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.FirstId">
            <summary>第一个Id</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.FirstValues">
            <summary>第一个消息</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.LastId">
            <summary>最后一个Id</summary>
        </member>
        <member name="P:NewLife.Caching.Models.StreamInfo.LastValues">
            <summary>最后一个消息</summary>
        </member>
        <member name="M:NewLife.Caching.Models.StreamInfo.Parse(System.Object[])">
            <summary>分析</summary>
            <param name="vs"></param>
        </member>
        <member name="T:NewLife.Caching.MultipleConsumerGroupsQueue`1">
            <summary>
            Redis多消费组可重复消费的队列
            相同组,相同名称只会有一个Client收到消息
            且只收到订阅开始后的消息
            </summary>
            <typeparam name="T">消息类型</typeparam>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.IsDoing">
            <summary>
            是否执行中
            </summary>
        </member>
        <member name="F:NewLife.Caching.MultipleConsumerGroupsQueue`1._Redis">
            <summary>
            Redis客户端
            </summary>
        </member>
        <member name="F:NewLife.Caching.MultipleConsumerGroupsQueue`1._Queue">
            <summary>
            消息列队
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.TimeOut">
            <summary>
            读写超时(默认15000ms)
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.SubscribeAppName">
            <summary>
            订阅者名称 
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.GroupName">
            <summary>
            消费组名
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.Topic">
            <summary>
            队列名称 消息主题 Topic
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.ConsumeGroupExistErrMsgKeyWord">
            <summary>
            消费者组名已经存在的Redis错误消息关键词
            5.x 使用默认 exists
            同版本的redis错误消息关键词可能不一样
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.QueueLen">
            <summary>
            列队长度
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.Log">
            <summary>
            日志对像
            </summary>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.Connect(System.String,System.String,System.Int32,System.String,System.Int32)">
            <summary>
            连接Redis服务器
            </summary>
            <param name="host">Redis地址</param>
            <param name="queueName">列队名称</param>
            <param name="port">端口(默认6379)</param>
            <param name="password">密码</param>
            <param name="db">连接Redis数据库</param>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.Publish(`0)">
            <summary>
            发送消息
            </summary>
            <param name="data"></param>
        </member>
        <member name="F:NewLife.Caching.MultipleConsumerGroupsQueue`1._Cts">
            <summary>
            独立线程消费
            </summary>
        </member>
        <member name="P:NewLife.Caching.MultipleConsumerGroupsQueue`1.IsNew">
            <summary>
            如果标记为非新建用户,则第一次直接消费完所有数据
            </summary>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.ClearMessage">
            <summary>
            一次性消费剩下所有消息,充当清空
            </summary>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.Subscribe(System.String)">
            <summary>
            订阅消息
            </summary>
            <param name="subscribeAppName">消费者名称</param>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.UnSubscribe">
            <summary>
            取消订阅
            </summary>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.getSubscribe(System.String)">
            <summary>
            获取消费消息
            </summary>
            <param name="subscribeAppName">订阅APP名称</param>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.Dispose">
            <summary>
            销毁对像
            </summary>
        </member>
        <member name="T:NewLife.Caching.MultipleConsumerGroupsQueue`1.ReceivedHandler">
            <summary>
            通知订阅者接收到新消息
            </summary>
            <param name="data">命令</param>
        </member>
        <member name="E:NewLife.Caching.MultipleConsumerGroupsQueue`1.Received">
            <summary>
            通知订阅者接收到新消息
            </summary>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.OnReceived(`0)">
            <summary>
            通知订阅者接收到新消息
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:NewLife.Caching.MultipleConsumerGroupsQueue`1.StopSubscribeHandler">
            <summary>
            通知订阅者停止订阅
            </summary>
            <param name="msg">停止消息</param>
        </member>
        <member name="E:NewLife.Caching.MultipleConsumerGroupsQueue`1.StopSubscribe">
            <summary>
            通知订阅者停止订阅,有可能已经被拉活,需要判断
             队列不存在等情况都会导致停止
             遇到异常时停止订阅，等待5秒后重新订阅，不遗漏消息
            </summary>
            <remarks>可以在这里处理重新订阅的相关业务逻辑</remarks>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.OnStopSubscribe(System.String)">
            <summary>通知订阅者停止订阅 默认自动 5s 后拉活</summary>
            <param name="msg">停止消息</param>
        </member>
        <member name="T:NewLife.Caching.MultipleConsumerGroupsQueue`1.DisconnectedHandler">
            <summary>
            通知订阅者断开连接
            </summary>
            <param name="msg">停止消息</param>
        </member>
        <member name="E:NewLife.Caching.MultipleConsumerGroupsQueue`1.Disconnected">
            <summary>
            通知订阅者断开连接
            </summary>
            <remarks>可以在这里处理重新连接的相关业务逻辑</remarks>
        </member>
        <member name="M:NewLife.Caching.MultipleConsumerGroupsQueue`1.OnDisconnected(System.String)">
            <summary>
            通知订阅者断开连接,有可能已经被拉活,需要判断
            </summary>
            <param name="msg">停止消息</param>
        </member>
        <member name="T:NewLife.Caching.PubSub">
            <summary>发布订阅</summary>
        </member>
        <member name="M:NewLife.Caching.PubSub.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化发布订阅</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.PubSub.SubscribeAsync(System.Action{System.String,System.String},System.Threading.CancellationToken)">
            <summary>订阅大循环</summary>
            <param name="onMessage"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.PubSub.Publish(System.String)">
            <summary>发布消息</summary>
            <param name="message">消息内容</param>
            <returns>返回接收到消息的客户端个数</returns>
        </member>
        <member name="T:NewLife.Caching.QueueBase">
            <summary>消息队列基类</summary>
        </member>
        <member name="P:NewLife.Caching.QueueBase.TraceName">
            <summary>追踪名。默认Key，主要用于解决动态Topic导致产生大量埋点的问题</summary>
        </member>
        <member name="P:NewLife.Caching.QueueBase.AttachTraceId">
            <summary>是否在消息报文中自动注入TraceId。TraceId用于跨应用在生产者和消费者之间建立调用链，默认true</summary>
        </member>
        <member name="P:NewLife.Caching.QueueBase.ThrowOnFailure">
            <summary>失败时抛出异常。默认false</summary>
        </member>
        <member name="P:NewLife.Caching.QueueBase.RetryTimesWhenSendFailed">
            <summary>发送消息失败时的重试次数。默认3次</summary>
        </member>
        <member name="P:NewLife.Caching.QueueBase.RetryIntervalWhenSendFailed">
            <summary>重试间隔。默认1000ms</summary>
        </member>
        <member name="P:NewLife.Caching.QueueBase.Topic">
            <summary>消息队列主题</summary>
        </member>
        <member name="M:NewLife.Caching.QueueBase.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化延迟队列</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.QueueBase.ValidWhenSendFailed(NewLife.Log.ISpan)">
            <summary>验证失败</summary>
            <param name="span"></param>
        </member>
        <member name="T:NewLife.Caching.QueueExtensions">
            <summary>IProducerConsumer接口扩展</summary>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.IProducerConsumer{System.String},System.Func{``0,System.String,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,NewLife.Log.ILog,System.String)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <param name="idField">消息标识字段名，用于处理错误重试</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.IProducerConsumer{System.String},System.Action{``0},System.Threading.CancellationToken,NewLife.Log.ILog,System.String)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <param name="idField">消息标识字段名，用于处理错误重试</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.RedisReliableQueue{System.String},System.Func{``0,System.String,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,NewLife.Log.ILog,System.String)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <param name="idField">消息标识字段名，用于处理错误重试</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.RedisReliableQueue{System.String},System.Action{``0},System.Threading.CancellationToken,NewLife.Log.ILog,System.String)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <param name="idField">消息标识字段名，用于处理错误重试</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.RedisReliableQueue{System.String},System.Action{System.String},System.Threading.CancellationToken,NewLife.Log.ILog)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.RedisStream{System.String},System.Func{``0,NewLife.Caching.Models.Message,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,NewLife.Log.ILog)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.QueueExtensions.ConsumeAsync``1(NewLife.Caching.RedisStream{System.String},System.Action{``0},System.Threading.CancellationToken,NewLife.Log.ILog)">
            <summary>队列消费大循环，处理消息后自动确认</summary>
            <typeparam name="T">消息类型</typeparam>
            <param name="queue">队列</param>
            <param name="onMessage">消息处理。如果处理消息时抛出异常，消息将延迟后回到队列</param>
            <param name="cancellationToken">取消令牌</param>
            <param name="log">日志对象</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisBase">
            <summary>基础结构</summary>
        </member>
        <member name="P:NewLife.Caching.RedisBase.Redis">
            <summary>客户端对象</summary>
        </member>
        <member name="P:NewLife.Caching.RedisBase.Key">
            <summary>键</summary>
        </member>
        <member name="M:NewLife.Caching.RedisBase.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisBase.Execute``1(System.Func{NewLife.Caching.RedisClient,``0},System.Boolean)">
            <summary>执行命令</summary>
            <typeparam name="T"></typeparam>
            <param name="func"></param>
            <param name="write">是否写入操作</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisBase.ExecuteAsync``1(System.Func{NewLife.Caching.RedisClient,System.Threading.Tasks.Task{``0}},System.Boolean)">
            <summary>异步执行命令</summary>
            <typeparam name="T"></typeparam>
            <param name="func"></param>
            <param name="write">是否写入操作</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisBase.ToBytes(System.Object)">
            <summary>数值转字节数组</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisBase.FromBytes(NewLife.Data.Packet,System.Type)">
            <summary>字节数组转对象</summary>
            <param name="pk"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisBase.FromBytes``1(NewLife.Data.Packet)">
            <summary>字节数组转对象</summary>
            <typeparam name="T"></typeparam>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisCluster">
            <summary>Redis集群</summary>
        </member>
        <member name="P:NewLife.Caching.RedisCluster.Nodes">
            <summary>集群节点</summary>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.#ctor(NewLife.Caching.Redis)">
            <summary>实例化</summary>
            <param name="redis"></param>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.ParseNodes(System.String)">
            <summary>分析节点</summary>
            <param name="nodes"></param>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.SelectNode(System.String)">
            <summary>根据Key选择节点</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.Map(System.String,System.String)">
            <summary>把Key映射到指定地址的节点</summary>
            <param name="endpoint"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.Meet(System.String,System.Int32)">
            <summary>向集群添加新节点</summary>
            <param name="ip"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.AddSlots(NewLife.Caching.Models.Node,System.Int32[])">
            <summary>向节点增加槽</summary>
            <param name="node"></param>
            <param name="slots"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.DeleteSlots(NewLife.Caching.Models.Node,System.Int32[])">
            <summary>从节点删除槽</summary>
            <param name="node"></param>
            <param name="slots"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisCluster.Rebalance">
            <summary>重新负载均衡</summary>
            <remarks>
            节点迁移太负责，直接干掉原来的分配，重新全局分配
            </remarks>
        </member>
        <member name="T:NewLife.Caching.RedisDelayQueue`1">
            <summary>Redis延迟队列</summary>
            <remarks>
            延迟Redis队列，每次生产操作1次Redis，消费操作4次Redis。
            </remarks>
        </member>
        <member name="P:NewLife.Caching.RedisDelayQueue`1.TransferInterval">
            <summary>转移延迟消息到主队列的间隔。默认10s</summary>
        </member>
        <member name="P:NewLife.Caching.RedisDelayQueue`1.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.RedisDelayQueue`1.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="P:NewLife.Caching.RedisDelayQueue`1.Delay">
            <summary>默认延迟时间。默认60秒</summary>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化延迟队列</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.Add(`0,System.Int32)">
            <summary>添加延迟消息</summary>
            <param name="value"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.Add(`0[])">
            <summary>批量生产</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.Remove(`0)">
            <summary>删除项</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.TakeOne(System.Int32)">
            <summary>获取一个</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步获取一个</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.NewLife#Caching#IProducerConsumer{T}#TakeOneAsync(System.Int32)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.Take(System.Int32)">
            <summary>获取一批</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.TryPop(`0)">
            <summary>争夺消费，只有一个线程能够成功删除，作为抢到的标志。同时备份到Ack队列</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.Acknowledge(`0[])">
            <summary>确认删除</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.NewLife#Caching#IProducerConsumer{T}#Acknowledge(System.String[])">
            <summary>确认删除</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisDelayQueue`1.TransferAsync(NewLife.Caching.IProducerConsumer{`0},System.Action{System.Exception},System.Threading.CancellationToken)">
            <summary>异步转移消息，已到期消息转移到目标队列</summary>
            <param name="queue">队列</param>
            <param name="onException">异常处理</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisGeo">
            <summary>地理信息数据</summary>
            <remarks>
            将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。
            这些数据将会存储到sorted set这样的目的是为了方便使用GEORADIUS或者GEORADIUSBYMEMBER命令对数据进行半径查询等操作。
            该命令以采用标准格式的参数x,y,所以经度必须在纬度之前。这些坐标的限制是可以被编入索引的，区域面积可以很接近极点但是不能索引。
            </remarks>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化地理信息</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.Add(System.String,System.Double,System.Double)">
            <summary>添加</summary>
            <param name="name"></param>
            <param name="longitude"></param>
            <param name="latitude"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.Add(NewLife.Caching.Models.GeoInfo[])">
            <summary>添加</summary>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.GetDistance(System.String,System.String,System.String)">
            <summary>两点距离</summary>
            <param name="from">开始点</param>
            <param name="to">结束点</param>
            <param name="unit">单位。m/km/mi/ft</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.GetPosition(System.String[])">
            <summary>获取一批点的坐标</summary>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.GetHash(System.String[])">
            <summary>获取一批点的GeoHash一维编码</summary>
            <remarks>
            一维编码表示一个矩形区域，前缀表示更大区域，例如北京wx4fbzdvs80包含在wx4fbzdvs里面。
            这个特性可以用于附近地点搜索。
            GeoHash编码位数及距离关系：
            1位，+-2500km；
            2位，+-630km；
            3位，+-78km；
            4位，+-20km；
            5位，+-2.4km；
            6位，+-610m；
            7位，+-76m；
            8位，+-19m；
            </remarks>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.GetRadius(System.Double,System.Double,System.Double,System.String,System.Int32)">
            <summary>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素</summary>
            <param name="longitude"></param>
            <param name="latitude"></param>
            <param name="radius"></param>
            <param name="unit"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisGeo.GetRadius(System.String,System.Double,System.String,System.Int32)">
            <summary>以给定的点位为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素</summary>
            <param name="member"></param>
            <param name="radius"></param>
            <param name="unit"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisHash`2">
            <summary>哈希结构</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="P:NewLife.Caching.RedisHash`2.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.RedisHash`2.Keys">
            <summary>获取所有键</summary>
        </member>
        <member name="P:NewLife.Caching.RedisHash`2.Values">
            <summary>获取所有值</summary>
        </member>
        <member name="P:NewLife.Caching.RedisHash`2.Item(`0)">
            <summary>获取 或 设置 指定键的值</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.ContainsKey(`0)">
            <summary>是否包含指定键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.Add(`0,`1)">
            <summary>添加</summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.Remove(`0)">
            <summary>删除</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.TryGetValue(`0,`1@)">
            <summary>尝试获取</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.Clear">
            <summary>清空</summary>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.GetEnumerator">
            <summary>迭代</summary>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HDel(`0[])">
            <summary>批量删除</summary>
            <param name="fields"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HMGet(`0[])">
            <summary>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值</summary>
            <param name="fields"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HMSet(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>批量插入</summary>
            <param name="keyValues"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.GetAll">
            <summary>获取所有名值对</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HIncrBy(`0,System.Int64)">
            <summary>增加指定字段值</summary>
            <param name="field"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HIncrBy(`0,System.Double)">
            <summary>增加指定字段值</summary>
            <param name="field"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HSetNX(`0,`1)">
            <summary>只在 key 指定的哈希集中不存在指定的字段时，设置字段的值</summary>
            <param name="field"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.HStrLen(`0)">
            <summary>返回hash指定field的value的字符串长度</summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.Search(NewLife.Caching.Models.SearchModel)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="model">搜索模型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisHash`2.Search(System.String,System.Int32)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="pattern">匹配表达式</param>
            <param name="count">返回个数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisHelper">
            <summary>Redis助手</summary>
        </member>
        <member name="M:NewLife.Caching.RedisHelper.AttachTraceId(NewLife.Caching.Redis,System.Object)">
            <summary>在消息队列发布消息前</summary>
            <param name="redis"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisList`1">
            <summary>列表结构，右边进入</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="P:NewLife.Caching.RedisList`1.Item(System.Int32)">
            <summary>获取 或 设置 指定位置的值</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.RedisList`1.Count">
            <summary>个数</summary>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.Add(`0)">
            <summary>添加元素在后面</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>批量添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.Clear">
            <summary>清空列表-start>end 清空</summary>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.Contains(`0)">
            <summary>是否包含指定元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.CopyTo(`0[],System.Int32)">
            <summary>复制到目标数组</summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.IndexOf(`0)">
            <summary>查找指定元素位置</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.Insert(System.Int32,`0)">
            <summary>在指定位置插入</summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.Remove(`0)">
            <summary>删除指定元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.RemoveAt(System.Int32)">
            <summary>删除指定位置数据</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.GetEnumerator">
            <summary>遍历</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.RPUSH(System.Collections.Generic.IEnumerable{`0})">
            <summary>右边批量添加，返回队列元素总数</summary>
            <param name="values"></param>
            <returns>队列元素总数</returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LPUSH(System.Collections.Generic.IEnumerable{`0})">
            <summary>左边批量添加，返回队列元素总数</summary>
            <param name="values"></param>
            <returns>队列元素总数</returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.RPOP">
            <summary>移除并返回最右边一个元素</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LPOP">
            <summary>移除并返回最左边一个元素</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.RPOPLPUSH(System.String)">
            <summary>移除并返回最右边一个元素，并插入目标列表左边，原子操作</summary>
            <remarks>
            用于高可靠性消费
            </remarks>
            <param name="destKey">目标列表</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.BRPOPLPUSH(System.String,System.Int32)">
            <summary>移除并返回最右边一个元素，并插入目标列表左边，原子操作</summary>
            <remarks>
            用于高可靠性消费
            </remarks>
            <param name="destKey">目标列表</param>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LInsertBefore(`0,`0)">
            <summary>在指定元素之前插入</summary>
            <param name="pivot"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LInsertAfter(`0,`0)">
            <summary>返回指定范围的列表</summary>
            <param name="pivot"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LRange(System.Int32,System.Int32)">
            <summary>返回指定范围的列表</summary>
            <param name="start"></param>
            <param name="stop"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.GetAll">
            <summary>获取所有元素</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LTrim(System.Int32,System.Int32)">
            <summary>修剪一个已存在的列表</summary>
            <remarks>
            LTRIM foobar 0 2 将会对存储在 foobar 的列表进行修剪，只保留列表里的前3个元素。
            </remarks>
            <param name="start">由0开始计数，-1 表示列表里的最后一个元素</param>
            <param name="stop">由0开始计数，-1 表示列表里的最后一个元素</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisList`1.LRem(System.Int32,`0)">
            <summary>从存于 key 的列表里移除前 count 次出现的值为 value 的元素</summary>
            <param name="count"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisQueue`1">
            <summary>Redis队列，左进右出</summary>
            <remarks>
            默认弹出消费，不需要确认，使用非常简单，但如果消费者处理失败，消息将会丢失；
            
            普通Redis队列，每次生产操作1次Redis，消费操作1次Redis。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Caching.RedisQueue`1.MinPipeline">
            <summary>最小管道阈值，达到该值时使用管道，默认3</summary>
        </member>
        <member name="P:NewLife.Caching.RedisQueue`1.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.RedisQueue`1.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化队列</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.Add(`0)">
            <summary>生产添加</summary>
            <param name="value">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.Add(`0[])">
            <summary>批量生产添加</summary>
            <param name="values">消息集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.TakeOne(System.Int32)">
            <summary>消费获取，支持阻塞</summary>
            <param name="timeout">超时，0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.NewLife#Caching#IProducerConsumer{T}#TakeOneAsync(System.Int32)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.Take(System.Int32)">
            <summary>批量消费获取</summary>
            <param name="count">要消费的消息个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.NewLife#Caching#IProducerConsumer{T}#Acknowledge(System.String[])">
            <summary>确认消费。不支持</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisReliableQueue`1">
            <summary>可靠Redis队列，左进右出</summary>
            <remarks>
            严格模式下消费，弹出消息的同时插入Ack队列，消费者处理成功后将从ACK队列删除该消息，若处理失败，则将延迟消费Ack消息；
            
            可信队列对象不是线程安全，要求每个线程独享队列对象。
            为了让严格模式支持多线程消费，确认队列AckKey构造为 Key:Ack:Rand16 的格式，每一个消费者都将有自己完全独一无二的确认队列。
            消费者每30秒（RetryInterval）清理一次确认队列的死信（未确认消息），重新投入主队列。
            应用异常退出时，可能产生一些死信，在应用启动首次消费时通过TakeAllAck消费清理所有Ack队列。
            由于引入状态队列，清理不活跃消费者时，不会影响正常消费者。
            
            设计要点：
            1，消费时，RPOPLPUSH从Key弹出并备份到AckKey，消息处理完成后，再从AckKey删除
            2，AckKey设计为Key:Ack:ukey，ukey=Rand16，让每个实例都有专属的Ack确认队列
            3，消费时，每60秒更新一次状态到Key:Status:ukey，表明ukey还在消费
            4，全局定期扫描Key:Status:ukey，若不活跃，回滚它的Ack消息
            
            消费者要慎重处理错误消息，有可能某条消息一直处理失败，如果未确认，队列会反复把消息送回主队列。
            建议用户自己处理并确认消费，通过消息体或者redisKey计数。
            
            高级队列技巧：
            1，按kv写入消息体，然后key作为消息键写入队列并消费，成功消费后从kv删除；
            2，消息键key自定义，随时可以查看或删除消息体，也可以避免重复生产；
            3，Redis队列确保至少消费一次，消息体和消息键分离后，可以做到有且仅有一次，若有二次消费，再也拿不到数据内容；
            4，同一个消息被重复生产时，尽管队列里面有两条消息键，但由于消息键相同，消息体只有一份，从而避免重复消费；
            
            可信Redis队列，每次生产操作1次Redis，消费操作2次Redis；
            高级Redis队列，每次生产操作3次Redis，消费操作4次Redis；
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Caching.RedisReliableQueue`1.AckKey">
            <summary>用于确认的列表</summary>
        </member>
        <member name="P:NewLife.Caching.RedisReliableQueue`1.RetryInterval">
            <summary>重新处理确认队列中死信的间隔。默认60s</summary>
        </member>
        <member name="P:NewLife.Caching.RedisReliableQueue`1.MinPipeline">
            <summary>最小管道阈值，达到该值时使用管道，默认3</summary>
        </member>
        <member name="P:NewLife.Caching.RedisReliableQueue`1.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.RedisReliableQueue`1.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="P:NewLife.Caching.RedisReliableQueue`1.Status">
            <summary>消费状态</summary>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化队列</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Finalize">
            <summary>析构</summary>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Dispose">
            <summary>释放</summary>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Dispose(System.Boolean)">
            <summary>释放</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Add(`0[])">
            <summary>批量生产添加</summary>
            <param name="values">消息集合</param>
            <returns>返回插入后的LIST长度</returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.TakeOne(System.Int32)">
            <summary>消费获取，从Key弹出并备份到AckKey，支持阻塞</summary>
            <remarks>假定前面获取的消息已经确认，因该方法内部可能回滚确认队列，避免误杀</remarks>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.NewLife#Caching#IProducerConsumer{T}#TakeOneAsync(System.Int32)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Take(System.Int32)">
            <summary>批量消费获取，从Key弹出并备份到AckKey</summary>
            <remarks>假定前面获取的消息已经确认，因该方法内部可能回滚确认队列，避免误杀</remarks>
            <param name="count">要消费的消息个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Acknowledge(System.String[])">
            <summary>确认消费，从AckKey中删除</summary>
            <param name="keys"></param>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.InitDelay">
            <summary>初始化延迟队列功能。生产者自动初始化，消费者最好能够按队列初始化一次</summary>
            <remarks>
            该功能是附加功能，需要消费者主动调用，每个队列的多消费者开一个即可。
            核心工作是启动延迟队列的TransferAsync大循环，每个进程内按队列开一个最合适，多了没有用反而形成争夺。
            </remarks>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.AddDelay(`0,System.Int32)">
            <summary>添加延迟消息</summary>
            <param name="value"></param>
            <param name="delay"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.Publish(System.Collections.Generic.IDictionary{System.String,`0},System.Int32)">
            <summary>高级生产消息。消息体和消息键分离，业务层指定消息键，可随时查看或删除，同时避免重复生产</summary>
            <remarks>
            Publish 必须跟 ConsumeAsync 配对使用。
            </remarks>
            <param name="messages">消息字典，id为键，消息体为值</param>
            <param name="expire">消息体过期时间，单位秒</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.ConsumeAsync``1(System.Func{`0,System.Threading.Tasks.Task{``0}},System.Int32)">
            <summary>高级消费消息。消息处理成功后，自动确认并删除消息体</summary>
            <remarks>
            Publish 必须跟 ConsumeAsync 配对使用。
            </remarks>
            <param name="func"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.TakeAck(System.Int32)">
            <summary>从确认列表弹出消息，用于消费中断后，重新恢复现场时获取</summary>
            <remarks>理论上Ack队列只存储极少数数据</remarks>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.ClearAllAck">
            <summary>清空所有Ack队列。危险操作！！！</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.RollbackAck(System.String,System.String)">
            <summary>回滚指定AckKey内的消息到Key</summary>
            <param name="key"></param>
            <param name="ackKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.RollbackAllAck">
            <summary>全局回滚死信，一般由单一线程执行，避免干扰处理中数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisReliableQueue`1.RetryAck">
            <summary>处理未确认的死信，重新放入队列</summary>
        </member>
        <member name="T:NewLife.Caching.RedisSet`1">
            <summary>Set结构</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="P:NewLife.Caching.RedisSet`1.Count">
            <summary>个数</summary>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Add(`0)">
            <summary>添加元素在后面</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Clear">
            <summary>清空列表</summary>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Contains(`0)">
            <summary>是否包含指定元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.CopyTo(`0[],System.Int32)">
            <summary>复制到目标数组</summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Remove(`0)">
            <summary>删除指定元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.GetEnumerator">
            <summary>遍历</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.SAdd(`0[])">
            <summary>批量添加</summary>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.SDel(`0[])">
            <summary>批量删除</summary>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.GetAll">
            <summary>获取所有元素</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Move(System.String,`0)">
            <summary>将member从source集合移动到destination集合中</summary>
            <param name="dest"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.RandomGet(System.Int32)">
            <summary>随机获取多个</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Pop(System.Int32)">
            <summary>随机获取并弹出</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Search(NewLife.Caching.Models.SearchModel)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="model">搜索模型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSet`1.Search(System.String,System.Int32)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="pattern">匹配表达式</param>
            <param name="count">返回个数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisSortedSet`1">
            <summary>有序集合ZSET</summary>
        </member>
        <member name="P:NewLife.Caching.RedisSortedSet`1.Count">
            <summary>个数</summary>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化有序集合</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Add(`0,System.Double)">
            <summary>添加元素并指定分数，返回添加到集合的成员数量</summary>
            <param name="member">元素</param>
            <param name="score">分数</param>
            <returns>添加到有序集合的成员数量，不包括已经存在更新分数的成员</returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Add(System.Collections.Generic.IEnumerable{`0},System.Double)">
            <summary>批量添加，返回添加到集合的成员数量</summary>
            <param name="members"></param>
            <param name="score"></param>
            <returns>添加到有序集合的成员数量，不包括已经存在更新分数的成员</returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Remove(`0[])">
            <summary>删除元素</summary>
            <param name="members"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.GetScore(`0)">
            <summary>返回有序集key中，成员member的score值</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Add(System.String,System.Collections.Generic.IDictionary{`0,System.Double})">
            <summary>批量添加</summary>
            <remarks>
            将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。
            如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。
            
            
            ZADD 命令在key后面分数/成员（score/member）对前面支持一些参数，他们是：
            XX: 仅仅更新存在的成员，不添加新成员。
            NX: 不更新存在的成员。只添加新成员。
            CH: 修改返回值为发生变化的成员总数，原始是返回新添加成员的总数(CH 是 changed 的意思)。
            更改的元素是新添加的成员，已经存在的成员更新分数。 所以在命令中指定的成员有相同的分数将不被计算在内。
            注：在通常情况下，ZADD返回值只计算新添加成员的数量。
            INCR: 当ZADD指定这个选项时，成员的操作就等同ZINCRBY命令，对成员的分数进行递增操作。
            </remarks>
            <param name="options">支持参数</param>
            <param name="members"></param>
            <returns>添加到有序集合的成员数量，不包括已经存在更新分数的成员</returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Increment(`0,System.Double)">
            <summary>为有序集key的成员member的score值加上增量increment</summary>
            <param name="member"></param>
            <param name="score"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.PopMax(System.Int32)">
            <summary>删除并返回有序集合key中的最多count个具有最高得分的成员</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.PopMin(System.Int32)">
            <summary>删除并返回有序集合key中的最多count个具有最低得分的成员</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.FindCount(System.Double,System.Double)">
            <summary>
            返回有序集key中，score值在min和max之间(默认包括score值等于min或max)的成员个数
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Range(System.Int32,System.Int32)">
            <summary>返回指定范围的列表</summary>
            <param name="start"></param>
            <param name="stop"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.RangeWithScores(System.Int32,System.Int32)">
            <summary>返回指定范围的成员分数对</summary>
            <param name="start"></param>
            <param name="stop"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.RangeByScore(System.Double,System.Double,System.Int32,System.Int32)">
            <summary>返回指定分数区间的成员列表，低分到高分排序</summary>
            <param name="min">低分，包含</param>
            <param name="max">高分，包含</param>
            <param name="offset">偏移</param>
            <param name="count">个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.RangeByScoreAsync(System.Double,System.Double,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>返回指定分数区间的成员列表，低分到高分排序</summary>
            <param name="min">低分，包含</param>
            <param name="max">高分，包含</param>
            <param name="offset">偏移</param>
            <param name="count">个数</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.RangeByScoreWithScores(System.Double,System.Double,System.Int32,System.Int32)">
            <summary>返回指定分数区间的成员分数对，低分到高分排序</summary>
            <param name="min">低分，包含</param>
            <param name="max">高分，包含</param>
            <param name="offset">偏移</param>
            <param name="count">个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Rank(`0)">
            <summary>返回有序集key中成员member的排名。其中有序集成员按score值递增(从小到大)顺序排列</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisSortedSet`1.Search(System.String,System.Int32,System.Int32)">
            <summary>模糊搜索，支持?和*</summary>
            <param name="pattern"></param>
            <param name="count"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisStack`1">
            <summary>Redis栈，右进右出</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Caching.RedisStack`1.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStack`1.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStack`1.MinPipeline">
            <summary>最小管道阈值，达到该值时使用管道，默认3</summary>
        </member>
        <member name="M:NewLife.Caching.RedisStack`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化队列</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisStack`1.Add(`0[])">
            <summary>批量生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStack`1.Take(System.Int32)">
            <summary>批量消费获取</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStack`1.TakeOne(System.Int32)">
            <summary>消费获取，支持阻塞</summary>
            <param name="timeout">超时，0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStack`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStack`1.NewLife#Caching#IProducerConsumer{T}#TakeOneAsync(System.Int32)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.SaveDelegate">
            <summary>保存指定key数据的委托</summary>
            <param name="key"></param>
            <param name="data"></param>
        </member>
        <member name="T:NewLife.Caching.RedisStat">
            <summary>Redis流式统计</summary>
            <remarks>
            借助Redis进行流式增量计算。
            1，HASH结构对Key下的统计标量进行累加
            2，有变化的Key进入延迟队列，延迟一定时间后进入普通队列
            3，消费队列，得到Key后进行Rename，然后把数据取回来写入数据库
            </remarks>
        </member>
        <member name="P:NewLife.Caching.RedisStat.Name">
            <summary>统计名称。如StationDayStat等</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStat.OnSave">
            <summary>取回统计数据后的委托。一般用于保存到数据库</summary>
        </member>
        <member name="M:NewLife.Caching.RedisStat.#ctor(NewLife.Caching.FullRedis,System.String)">
            <summary>实例化</summary>
            <param name="redis"></param>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Caching.RedisStat.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.RedisStat.Increment(System.String,System.String,System.Int32)">
            <summary>增加指定标量的值</summary>
            <param name="key"></param>
            <param name="field"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Caching.RedisStat.AddDelayQueue(System.String,System.Int32)">
            <summary>放入延迟队列</summary>
            <param name="key"></param>
            <param name="delay"></param>
        </member>
        <member name="M:NewLife.Caching.RedisStat.OnProcess(System.String)">
            <summary>消费处理</summary>
            <param name="key"></param>
        </member>
        <member name="T:NewLife.Caching.RedisStatGroup">
            <summary>Redis统计组</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStatGroup.Redis">
            <summary>实例</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStatGroup.Stats">
            <summary>统计集合</summary>
        </member>
        <member name="T:NewLife.Caching.RedisStream`1">
            <summary>Redis5.0的Stream数据结构，完整态消息队列，支持多消费组</summary>
            <remarks>
            特殊的$，表示接收从阻塞那一刻开始添加到流的消息
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.Count">
            <summary>个数</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.IsEmpty">
            <summary>是否为空</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.RetryInterval">
            <summary>重新处理确认队列中死信的间隔。默认60s</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.PrimitiveKey">
            <summary>基元类型数据添加该key构成集合。默认__data</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.MaxLenngth">
            <summary>最大队列长度。要保留的消息个数，超过则移除较老消息，非精确，实际上略大于该值，默认100万</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.MaxRetry">
            <summary>最大重试次数。超过该次数后，消息将被抛弃，默认10次</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.StartId">
            <summary>开始编号。独立消费时使用，消费组消费时不使用，默认0-0</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.Group">
            <summary>消费者组。指定消费组后，不再使用独立消费。通过SetGroup可自动创建消费组</summary>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.Consumer">
            <summary>消费者</summary>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.#ctor(NewLife.Caching.Redis,System.String)">
            <summary>实例化队列</summary>
            <param name="redis"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.SetGroup(System.String)">
            <summary>设置消费组。如果消费组不存在则创建</summary>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Add(`0,System.String)">
            <summary>生产添加</summary>
            <param name="value">消息体</param>
            <param name="msgId">消息ID</param>
            <returns>返回消息ID</returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.NewLife#Caching#IProducerConsumer{T}#Add(`0[])">
            <summary>批量生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Take(System.Int32)">
            <summary>批量消费获取，前移指针StartId</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.TakeOne(System.Int32)">
            <summary>消费获取一个</summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.TakeOneAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费获取一个</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.NewLife#Caching#IProducerConsumer{T}#TakeOneAsync(System.Int32)">
            <summary>异步消费获取</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞；负数表示直接返回，不阻塞。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.TakeMessageAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费获取一个</summary>
            <param name="timeout">超时时间，默认0秒永远阻塞</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Acknowledge(System.String[])">
            <summary>消费确认</summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.RetryAck">
            <summary>处理未确认的死信，重新放入队列</summary>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Delete(System.String)">
            <summary>删除指定消息</summary>
            <param name="id">消息Id</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Trim(System.Int32)">
            <summary>裁剪队列到指定大小</summary>
            <param name="maxLen">最大长度。为了提高效率，最大长度并没有那么精准</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Ack(System.String,System.String)">
            <summary>确认消息</summary>
            <param name="group">消费组名称</param>
            <param name="id">消息Id</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Claim(System.String,System.String,System.String,System.Int32)">
            <summary>改变待处理消息的所有权，抢夺他人未确认消息</summary>
            <param name="group">消费组名称</param>
            <param name="consumer">目标消费者</param>
            <param name="id">消息Id</param>
            <param name="msIdle">空闲时间。默认3600_000</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Range(System.String,System.String,System.Int32)">
            <summary>获取区间消息</summary>
            <param name="startId"></param>
            <param name="endId"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Range(System.DateTime,System.DateTime,System.Int32)">
            <summary>获取区间消息</summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Read(System.String,System.Int32)">
            <summary>原始独立消费</summary>
            <remarks>
            特殊的$，表示接收从阻塞那一刻开始添加到流的消息
            </remarks>
            <param name="startId">开始编号</param>
            <param name="count">消息个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.ReadAsync(System.String,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>异步原始独立消费</summary>
            <remarks>
            特殊的$，表示接收从阻塞那一刻开始添加到流的消息
            </remarks>
            <param name="startId">开始编号</param>
            <param name="count">消息个数</param>
            <param name="block">阻塞毫秒数，0表示永远</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GetPending(System.String)">
            <summary>获取等待列表信息</summary>
            <param name="group">消费组名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.Pending(System.String,System.String,System.String,System.Int32)">
            <summary>获取等待列表消息</summary>
            <param name="group">消费组名称</param>
            <param name="startId"></param>
            <param name="endId"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.RedisStream`1.IsNew">
            <summary>
            如果标记为非新建用户,则第一次直接消费完所有数据
            </summary>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GroupCreate(System.String,System.String)">
            <summary>创建消费组</summary>
            <param name="group">消费组名称</param>
            <param name="startId">开始编号。0表示从开头，$表示从末尾，收到下一条生产消息才开始消费 stream不存在，则会报错，所以在后面 加上 mkstream</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.ClearMessage">
            <summary>
            一次性消费剩下所有消息,充当清空
            </summary>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GroupDestroy(System.String)">
            <summary>销毁消费组</summary>
            <param name="group">消费组名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GroupDeleteConsumer(System.String,System.String)">
            <summary>销毁消费者</summary>
            <param name="group">消费组名称</param>
            <param name="consumer">消费者</param>
            <returns>返回消费者在被删除之前所拥有的待处理消息数量</returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GroupSetId(System.String,System.String)">
            <summary>设置消费组Id</summary>
            <param name="group">消费组名称</param>
            <param name="startId">开始编号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.ReadGroup(System.String,System.String,System.Int32)">
            <summary>消费组消费</summary>
            <param name="group">消费组</param>
            <param name="consumer">消费组</param>
            <param name="count">消息个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.ReadGroupAsync(System.String,System.String,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>异步消费组消费</summary>
            <param name="group">消费组</param>
            <param name="consumer">消费组</param>
            <param name="count">消息个数</param>
            <param name="block">阻塞毫秒数，0表示永远</param>
            <param name="cancellationToken">取消令牌</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GetInfo">
            <summary>获取信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GetGroups">
            <summary>获取消费组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisStream`1.GetConsumers(System.String)">
            <summary>获取消费者</summary>
            <param name="group">消费组名称</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.DbCache">
            <summary>数据库缓存。利用数据表来缓存信息</summary>
            <remarks>
            构建一个操作队列，新增、更新、删除等操作全部排队单线程执行，以改进性能
            </remarks>
        </member>
        <member name="P:NewLife.Caching.DbCache.Factory">
            <summary>实体工厂</summary>
        </member>
        <member name="P:NewLife.Caching.DbCache.KeyField">
            <summary>主键字段</summary>
        </member>
        <member name="P:NewLife.Caching.DbCache.TimeField">
            <summary>时间字段</summary>
        </member>
        <member name="M:NewLife.Caching.DbCache.#ctor(XCode.IEntityFactory,System.String,System.String)">
            <summary>实例化一个数据库缓存</summary>
            <param name="factory"></param>
            <param name="keyName"></param>
            <param name="timeName"></param>
        </member>
        <member name="M:NewLife.Caching.DbCache.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Caching.DbCache.Count">
            <summary>缓存个数。高频使用时注意性能</summary>
        </member>
        <member name="P:NewLife.Caching.DbCache.Keys">
            <summary>所有键。实际返回只读列表新实例，数据量较大时注意性能</summary>
        </member>
        <member name="M:NewLife.Caching.DbCache.Init(System.String)">
            <summary>初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.DbCache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.DbCache.Set``1(System.String,``0,System.Int32)">
            <summary>添加缓存项，已存在时更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.DbCache.Get``1(System.String)">
            <summary>获取缓存项，不存在时返回默认值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.DbCache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns>实际移除个数</returns>
        </member>
        <member name="M:NewLife.Caching.DbCache.Clear">
            <summary>删除所有配置项</summary>
        </member>
        <member name="M:NewLife.Caching.DbCache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
            <returns>设置是否成功</returns>
        </member>
        <member name="M:NewLife.Caching.DbCache.GetExpire(System.String)">
            <summary>获取缓存项有效期，不存在时返回Zero</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.DbCache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新，常用于锁争夺</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间</param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Caching.DbCache.clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Caching.DbCache.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.DbCache.BenchOne(System.Int64,System.Int32,System.Boolean,System.Int32)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
            <param name="batch">批量操作</param>
        </member>
        <member name="T:NewLife.Caching.IDbCache">
            <summary>数据缓存接口</summary>
        </member>
        <member name="P:NewLife.Caching.IDbCache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.IDbCache.Value">
            <summary>键值</summary>
        </member>
        <member name="P:NewLife.Caching.IDbCache.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:NewLife.Caching.IDbCache.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="M:NewLife.Caching.IDbCache.SaveAsync(System.Int32)">
            <summary>异步保存</summary>
            <param name="msDelay"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.BloomFilter">
            <summary>布隆过滤器</summary>
            <remarks>
            以极小内存进行海量键值的存在判断，碰撞几率很小。
            </remarks>
        </member>
        <member name="M:NewLife.Collections.BloomFilter.#ctor(System.Int32)">
            <summary>实例化布隆过滤器</summary>
            <param name="length">位数组大小。建议为预估数据量的32倍，可得到0.004%的误判率</param>
        </member>
        <member name="M:NewLife.Collections.BloomFilter.#ctor(System.Int64,System.Double)">
            <summary>实例化布隆过滤器</summary>
            <param name="n">预估数据量</param>
            <param name="fpp">期望的误判率。小于1</param>
        </member>
        <member name="M:NewLife.Collections.BloomFilter.Set(System.String)">
            <summary>设置指定键进入集合</summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Collections.BloomFilter.Get(System.String)">
            <summary>判断指定键是否存在于集合中</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ConcurrentHashSet`1">
            <summary>并行哈希集合</summary>
            <remarks>
            主要用于频繁添加删除而又要遍历的场合
            </remarks>
        </member>
        <member name="P:NewLife.Collections.ConcurrentHashSet`1.IsEmpty">
            <summary>是否空集合</summary>
        </member>
        <member name="P:NewLife.Collections.ConcurrentHashSet`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.Contain(`0)">
            <summary>是否包含元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.TryAdd(`0)">
            <summary>尝试添加</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.TryRemove(`0)">
            <summary>尝试删除</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2">
            <summary>字典缓存。当指定键的缓存项不存在时，调用委托获取值，并写入缓存。</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/dictionary_cache
            常用匿名函数或者Lambda表达式作为委托。
            </remarks>
            <typeparam name="TKey">键类型</typeparam>
            <typeparam name="TValue">值类型</typeparam>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Expire">
            <summary>过期时间。单位是秒，默认0秒，表示永不过期</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Period">
            <summary>定时清理时间，默认0秒，表示不清理过期项</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Capacity">
            <summary>容量。容量超标时，采用LRU机制删除，默认10_000</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.AllowNull">
            <summary>是否允许缓存控制，避免缓存穿透。默认false</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.FindMethod">
            <summary>查找数据的方法</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor">
            <summary>实例化一个字典缓存</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个字典缓存</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个字典缓存</summary>
            <param name="findMethod"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.VisitTime">
            <summary>访问时间</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.CacheItem.Visit">
            <summary>更新访问时间并返回数值</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Item(`0)">
            <summary>重写索引器。取值时如果没有该项则返回默认值；赋值时如果已存在该项则覆盖，否则添加。</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetOrAdd(`0)">
            <summary>获取 GetOrAdd</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Get(`0)">
            <summary>获取 GetOrAdd</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.TryGetValue(`0,`1@)">
            <summary>尝试获取数据</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Set(`0,`1)">
            <summary>设置 AddOrUpdate</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.TryAdd(`0,`1,System.Boolean,`1@)">
            <summary>尝试添加，或返回旧值</summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="updateIfExists"></param>
            <param name="resultingValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,System.Func{`0,`1})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Remove(`0)">
            <summary>移除指定缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Clear">
            <summary>清空</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Count">
            <summary>缓存项。原子计数</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.ContainsKey(`0)">
            <summary>是否包含指定键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.CopyTo(NewLife.Collections.DictionaryCache{`0,`1})">
            <summary>赋值到目标缓存</summary>
            <param name="cache"></param>
        </member>
        <member name="F:NewLife.Collections.DictionaryCache`2._timer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetEnumerator">
            <summary>枚举</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ICluster`2">
            <summary>集群管理</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:NewLife.Collections.ICluster`2.Current">
            <summary>最后使用资源</summary>
        </member>
        <member name="P:NewLife.Collections.ICluster`2.GetItems">
            <summary>资源列表</summary>
        </member>
        <member name="M:NewLife.Collections.ICluster`2.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Collections.ICluster`2.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Collections.ICluster`2.Get">
            <summary>从集群中获取资源</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ICluster`2.Put(`1)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="T:NewLife.Collections.ClusterHelper">
            <summary>集群助手</summary>
        </member>
        <member name="M:NewLife.Collections.ClusterHelper.Invoke``3(NewLife.Collections.ICluster{``0,``1},System.Func{``1,``2})">
            <summary>借助集群资源处理事务</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="cluster"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ClusterHelper.InvokeAsync``3(NewLife.Collections.ICluster{``0,``1},System.Func{``1,System.Threading.Tasks.Task{``2}})">
            <summary>借助集群资源处理事务</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="cluster"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.IPool`1">
            <summary>对象池接口</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/object_pool
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.IPool`1.Max">
            <summary>对象池大小</summary>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Get">
            <summary>获取</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Clear">
            <summary>清空</summary>
        </member>
        <member name="T:NewLife.Collections.Pool">
            <summary>对象池扩展</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/object_pool
            </remarks>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilder">
            <summary>字符串构建器池</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.Put(System.Text.StringBuilder,System.Boolean)">
            <summary>归还一个字符串构建器到对象池</summary>
            <param name="sb"></param>
            <param name="requireResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Pool.StringBuilderPool">
            <summary>字符串构建器池</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilderPool.InitialCapacity">
            <summary>初始容量。默认100个</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilderPool.MaximumCapacity">
            <summary>最大容量。超过该大小时不进入池内，默认4k</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.OnCreate">
            <summary>创建</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.Put(System.Text.StringBuilder)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStream">
            <summary>内存流池</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.Put(System.IO.MemoryStream,System.Boolean)">
            <summary>归还一个内存流到对象池</summary>
            <param name="ms"></param>
            <param name="requireResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Pool.MemoryStreamPool">
            <summary>内存流池</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStreamPool.InitialCapacity">
            <summary>初始容量。默认1024个</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStreamPool.MaximumCapacity">
            <summary>最大容量。超过该大小时不进入池内，默认64k</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.OnCreate">
            <summary>创建</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.Put(System.IO.MemoryStream)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.NullableDictionary`2">
            <summary>可空字典。获取数据时如果指定键不存在可返回空而不是抛出异常</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor">
            <summary>实例化一个可空字典</summary>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>指定比较器实例化一个可空字典</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个可空字典</summary>
            <param name="dic"></param>
            <param name="comparer"></param>
        </member>
        <member name="P:NewLife.Collections.NullableDictionary`2.Item(`0)">
            <summary>获取 或 设置 数据</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ObjectPool`1">
            <summary>资源池。支持空闲释放，主要用于数据库连接池和网络连接池</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/object_pool
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.FreeCount">
            <summary>空闲个数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.BusyCount">
            <summary>繁忙个数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Max">
            <summary>最大个数。默认100，0表示无上限</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Min">
            <summary>最小个数。默认1</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.IdleTime">
            <summary>空闲清理时间。最小个数之上的资源超过空闲时间时被清理，默认10s</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.AllIdleTime">
            <summary>完全空闲清理时间。最小个数之下的资源超过空闲时间时被清理，默认0s永不清理</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._free">
            <summary>基础空闲集合。只保存最小个数，最热部分</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._free2">
            <summary>扩展空闲集合。保存最小个数以外部分</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._busy">
            <summary>借出去的放在这</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.#ctor">
            <summary>实例化一个资源池</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Item.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Item.LastTime">
            <summary>过期时间</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Get">
            <summary>借出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnGet(`0)">
            <summary>借出时是否可用</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.GetItem">
            <summary>申请资源包装项，Dispose时自动归还到池中</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnPut(`0)">
            <summary>归还时是否可用</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Clear">
            <summary>清空已有对象</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnDispose(`0)">
            <summary>销毁</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Total">
            <summary>总请求数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Success">
            <summary>成功数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._NewCount">
            <summary>新创建数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._ReleaseCount">
            <summary>释放数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1.Cost">
            <summary>平均耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Collections.PoolItem`1">
            <summary>资源池包装项，自动归还资源到池中</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.PoolItem`1.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.PoolItem`1.Pool">
            <summary>池</summary>
        </member>
        <member name="M:NewLife.Collections.PoolItem`1.#ctor(NewLife.Collections.IPool{`0},`0)">
            <summary>包装项</summary>
            <param name="pool"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.PoolItem`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Collections.Pool`1">
            <summary>轻量级对象池。数组无锁实现，高性能</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/object_pool
            内部 1+N 的存储结果，保留最热的一个对象在外层，便于快速存取。
            数组具有极快的查找速度，结构体确保没有GC操作。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.Pool`1.Max">
            <summary>对象池大小。默认CPU*2，初始化后改变无效</summary>
        </member>
        <member name="M:NewLife.Collections.Pool`1.#ctor(System.Int32)">
            <summary>实例化对象池。默认大小CPU*2</summary>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Get">
            <summary>获取</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Clear">
            <summary>清空</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.IQueueService`1">
            <summary>主动式消息服务</summary>
            <typeparam name="T">数据类型</typeparam>
        </member>
        <member name="M:NewLife.Collections.IQueueService`1.Public(System.String,`0)">
            <summary>发布消息</summary>
            <param name="topic">主题</param>
            <param name="value">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.IQueueService`1.Subscribe(System.String,System.String)">
            <summary>订阅</summary>
            <param name="clientId">客户标识</param>
            <param name="topic">主题</param>
        </member>
        <member name="M:NewLife.Collections.IQueueService`1.UnSubscribe(System.String,System.String)">
            <summary>取消订阅</summary>
            <param name="clientId">客户标识</param>
            <param name="topic">主题</param>
        </member>
        <member name="M:NewLife.Collections.IQueueService`1.Consume(System.String,System.String,System.Int32)">
            <summary>消费消息</summary>
            <param name="clientId">客户标识</param>
            <param name="topic">主题</param>
            <param name="count">要拉取的消息数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.QueueService`1">
            <summary>轻量级主动式消息服务</summary>
            <typeparam name="T">数据类型</typeparam>
        </member>
        <member name="P:NewLife.Collections.QueueService`1.Cache">
            <summary>数据存储</summary>
        </member>
        <member name="F:NewLife.Collections.QueueService`1._topics">
            <summary>每个主题的所有订阅者</summary>
        </member>
        <member name="M:NewLife.Collections.QueueService`1.Public(System.String,`0)">
            <summary>发布消息</summary>
            <param name="topic">主题</param>
            <param name="value">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.QueueService`1.Subscribe(System.String,System.String)">
            <summary>订阅</summary>
            <param name="clientId">客户标识</param>
            <param name="topic">主题</param>
        </member>
        <member name="M:NewLife.Collections.QueueService`1.UnSubscribe(System.String,System.String)">
            <summary>取消订阅</summary>
            <param name="clientId">客户标识</param>
            <param name="topic">主题</param>
        </member>
        <member name="M:NewLife.Collections.QueueService`1.Consume(System.String,System.String,System.Int32)">
            <summary>消费消息</summary>
            <param name="clientId">客户标识</param>
            <param name="topic">主题</param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IDisposable2">
            <summary>具有是否已释放和释放后事件的接口</summary>
        </member>
        <member name="P:NewLife.IDisposable2.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.IDisposable2.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="T:NewLife.DisposeBase">
            <summary>具有销毁资源处理的抽象基类</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/disposebase
            </remarks>
            <example>
            <code>
            /// &lt;summary&gt;子类重载实现资源释放逻辑时必须首先调用基类方法&lt;/summary&gt;
            /// &lt;param name="disposing"&gt;从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            /// 因为该方法只会被调用一次，所以该参数的意义不太大。&lt;/param&gt;
            protected override void Dispose(bool disposing)
            {
                base.OnDispose(disposing);
            
                if (disposing)
                {
                    // 如果是构造函数进来，不执行这里的代码
                }
            }
            </code>
            </example>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="P:NewLife.DisposeBase.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.DisposeBase.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose(System.Boolean)">
            <summary>释放资源，参数表示是否由Dispose调用。重载时先调用基类方法</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.OnDispose(System.Boolean)">
            <summary>释放资源，参数表示是否由Dispose调用。该方法保证OnDispose只被调用一次！</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.Finalize">
            <summary>析构函数</summary>
            <remarks>
            如果忘记调用Dispose，这里会释放非托管资源
            如果曾经调用过Dispose，因为GC.SuppressFinalize(this)，不会再调用该析构函数
            </remarks>
        </member>
        <member name="T:NewLife.DisposeHelper">
            <summary>销毁助手。扩展方法专用</summary>
        </member>
        <member name="M:NewLife.DisposeHelper.TryDispose(System.Object)">
            <summary>尝试销毁对象，如果有<see cref="T:System.IDisposable"/>则调用</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.MachineInfo">
            <summary>机器信息</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/machine_info
            
            刷新信息成本较高，建议采用单例模式
            </remarks>
        </member>
        <member name="P:NewLife.MachineInfo.OSName">
            <summary>系统名称</summary>
        </member>
        <member name="P:NewLife.MachineInfo.OSVersion">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Product">
            <summary>产品名称。制造商</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Processor">
            <summary>处理器型号</summary>
        </member>
        <member name="P:NewLife.MachineInfo.CpuID">
            <summary>处理器序列号</summary>
        </member>
        <member name="P:NewLife.MachineInfo.UUID">
            <summary>硬件唯一标识</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Guid">
            <summary>系统标识</summary>
        </member>
        <member name="P:NewLife.MachineInfo.DiskID">
            <summary>磁盘序列号</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Memory">
            <summary>内存总量</summary>
        </member>
        <member name="P:NewLife.MachineInfo.AvailableMemory">
            <summary>可用内存</summary>
        </member>
        <member name="P:NewLife.MachineInfo.CpuRate">
            <summary>CPU占用率</summary>
        </member>
        <member name="P:NewLife.MachineInfo.UplinkSpeed">
            <summary>网络上行速度。字节每秒，初始化后首次读取为0</summary>
        </member>
        <member name="P:NewLife.MachineInfo.DownlinkSpeed">
            <summary>网络下行速度。字节每秒，初始化后首次读取为0</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Temperature">
            <summary>温度</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Battery">
            <summary>电池剩余</summary>
        </member>
        <member name="P:NewLife.MachineInfo.Current">
            <summary>当前机器信息。默认null，在RegisterAsync后才能使用</summary>
        </member>
        <member name="M:NewLife.MachineInfo.RegisterAsync">
            <summary>异步注册一个初始化后的机器信息实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetCurrent">
            <summary>获取当前信息，如果未设置则等待异步注册结果</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.Resolve">
            <summary>从对象容器中获取一个已注册机器信息实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.Init">
            <summary>刷新</summary>
        </member>
        <member name="M:NewLife.MachineInfo.Refresh">
            <summary>获取实时数据，如CPU、内存、温度</summary>
        </member>
        <member name="M:NewLife.MachineInfo.RefreshSpeed">
            <summary>刷新网络速度</summary>
        </member>
        <member name="M:NewLife.MachineInfo.GetLinuxName">
            <summary>获取Linux发行版名称</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.ReadWmic(System.String,System.String[])">
            <summary>通过WMIC命令读取信息</summary>
            <param name="type"></param>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetFreeSpace(System.String)">
            <summary>获取指定目录所在盘可用空间，默认当前目录</summary>
            <param name="path"></param>
            <returns>返回可用空间，字节，获取失败返回-1</returns>
        </member>
        <member name="M:NewLife.MachineInfo.GetFiles(System.String,System.Boolean)">
            <summary>获取指定目录下文件名，支持去掉后缀的去重，主要用于Linux</summary>
            <param name="path"></param>
            <param name="trimSuffix"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Common.PinYin">
            <summary>汉字拼音转换类</summary>
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirst(System.Char)">
            <summary>取拼音第一个字段</summary>        
            <param name="ch"></param>        
            <returns></returns>        
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirst(System.String)">
            <summary>取拼音第一个字段</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirstOne(System.String)">
            <summary>取拼音第一个字段</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.Get(System.Char)">
            <summary>获取单字拼音</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.Get(System.String)">
            <summary>把汉字转换成拼音(全拼)</summary>
            <param name="str">汉字字符串</param>
            <returns>转换后的拼音(全拼)字符串</returns>
        </member>
        <member name="T:NewLife.Common.SysConfig">
            <summary>系统设置。提供系统名称、版本等基本设置</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Name">
            <summary>系统名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Version">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.DisplayName">
            <summary>显示名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Company">
            <summary>公司</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Instance">
            <summary>应用实例。单应用多实例部署时用于唯一标识实例节点</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Develop">
            <summary>开发者模式</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.InstallTime">
            <summary>安装时间</summary>
        </member>
        <member name="M:NewLife.Common.SysConfig.OnLoaded">
            <summary>加载后触发</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig.SysAssembly">
            <summary>系统主程序集</summary>
        </member>
        <member name="T:NewLife.Runtime">
            <summary>运行时</summary>
        </member>
        <member name="P:NewLife.Runtime.IsConsole">
            <summary>是否控制台。用于判断是否可以执行一些控制台操作。</summary>
        </member>
        <member name="P:NewLife.Runtime.Mono">
            <summary>是否Mono环境</summary>
        </member>
        <member name="P:NewLife.Runtime.IsWeb">
            <summary>是否Web环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Windows">
            <summary>是否Windows环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Linux">
            <summary>是否Linux环境</summary>
        </member>
        <member name="P:NewLife.Runtime.OSX">
            <summary>是否OSX环境</summary>
        </member>
        <member name="T:NewLife.Configuration.Config`1">
            <summary>配置文件基类 [Config(nameof(xxx))] 必填</summary>
            <remarks>
            标准用法：TConfig.Current
            类注释可增加 [DisplayName("系统Config测试")]
            属性可增加  [DisplayName("系统名称")] [Description("用于标识系统的英文名")]
            允许使用自定义类型和集合
            配置实体类通过<see cref="T:NewLife.Configuration.ConfigAttribute"/>特性指定配置文件路径。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="E:NewLife.Configuration.Config`1.OnPropertyChanging">
            <summary>
            属性更改通知
            </summary>
        </member>
        <member name="P:NewLife.Configuration.Config`1.Provider">
            <summary>当前使用的提供者</summary>
        </member>
        <member name="P:NewLife.Configuration.Config`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="P:NewLife.Configuration.Config`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Configuration.Config`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Configuration.Config`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="M:NewLife.Configuration.Config`1.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="T:NewLife.Configuration.ConfigAttribute">
            <summary>配置特性</summary>
            <remarks>
            声明配置模型使用哪一种配置提供者，以及所需要的文件名和分类名。
            如未指定提供者，则使用全局默认，此时将根据全局代码配置或环境变量配置使用不同提供者，实现配置信息整体转移。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.ConfigAttribute.Provider">
            <summary>提供者。内置ini/xml/json/http，一般不指定，使用全局默认</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigAttribute.Name">
            <summary>配置名。可以是文件名或分类名</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigAttribute.#ctor(System.String,System.String)">
            <summary>指定配置名</summary>
            <param name="name">配置名。可以是文件名或分类名</param>
            <param name="provider">提供者。内置ini/xml/json/http，一般不指定，使用全局默认</param>
        </member>
        <member name="T:NewLife.Configuration.ConfigCacheLevel">
            <summary>配置数据缓存等级</summary>
        </member>
        <member name="F:NewLife.Configuration.ConfigCacheLevel.NoCache">
            <summary>不缓存</summary>
        </member>
        <member name="F:NewLife.Configuration.ConfigCacheLevel.Json">
            <summary>Json格式缓存</summary>
        </member>
        <member name="F:NewLife.Configuration.ConfigCacheLevel.Encrypted">
            <summary>加密缓存</summary>
        </member>
        <member name="T:NewLife.Configuration.ConfigHelper">
            <summary>配置助手</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.Find(NewLife.Configuration.IConfigSection,System.String,System.Boolean)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="section"></param>
            <param name="key"></param>
            <param name="createOnMiss"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.AddChild(NewLife.Configuration.IConfigSection,System.String)">
            <summary>添加子节点</summary>
            <param name="section"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.GetOrAddChild(NewLife.Configuration.IConfigSection,System.String)">
            <summary>查找或添加子节点</summary>
            <param name="section"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.SetValue(NewLife.Configuration.IConfigSection,System.Object)">
            <summary>设置节点值。格式化友好字符串</summary>
            <param name="section"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.MapTo(NewLife.Configuration.IConfigSection,System.Object,NewLife.Configuration.IConfigProvider)">
            <summary>映射配置树到实例公有属性</summary>
            <param name="section">数据源</param>
            <param name="model">模型</param>
            <param name="provider">提供者</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigHelper.MapFrom(NewLife.Configuration.IConfigSection,System.Object)">
            <summary>从实例公有属性映射到配置树</summary>
            <param name="section"></param>
            <param name="model"></param>
        </member>
        <member name="T:NewLife.Configuration.FileConfigProvider">
            <summary>文件配置提供者</summary>
            <remarks>
            每个提供者实例对应一个配置文件，支持热更新
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.FileConfigProvider.FileName">
            <summary>文件名。最高优先级，优先于模型特性指定的文件名</summary>
        </member>
        <member name="P:NewLife.Configuration.FileConfigProvider.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="P:NewLife.Configuration.FileConfigProvider.Period">
            <summary>更新周期。默认30秒</summary>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.ToString">
            <summary>已重载。输出友好信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.LoadAll">
            <summary>加载配置</summary>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置</param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.OnWrite(System.String,NewLife.Configuration.IConfigSection)">
            <summary>写入配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.FileConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="T:NewLife.Configuration.GetConfigCallback">
            <summary>获取配置委托。便于集成配置中心</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.IConfigMapping">
            <summary>配置映射接口。用于自定义映射配置树到当前对象</summary>
            <remarks>
            整体配置数据改变时触发调用该接口，但不表示当前对象所绑定路径的配置数据有改变，用户需要自己判断所属配置数据是否已改变。
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.IConfigMapping.MapConfig(NewLife.Configuration.IConfigProvider,NewLife.Configuration.IConfigSection)">
            <summary>映射配置树到当前对象</summary>
            <param name="provider">配置提供者</param>
            <param name="section">配置数据段</param>
        </member>
        <member name="T:NewLife.Configuration.IConfigProvider">
            <summary>配置提供者</summary>
            <remarks>
            建立树状配置数据体系，以分布式配置中心为核心，支持基于key的索引读写，也支持Load/Save/Bind的实体模型转换。
            key索引支持冒号分隔的多层结构，在配置中心中不同命名空间使用不同提供者实例，在文件配置中不同文件使用不同提供者实例。
            
            一个配置类，支持从不同持久化提供者读取，可根据需要选择配置持久化策略。
            例如，小系统采用ini/xml/json文件配置，分布式系统采用配置中心。
            
            可通过实现IConfigMapping接口来自定义映射配置到模型实例。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Root">
            <summary>根元素</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Keys">
            <summary>所有键</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">配置名，支持冒号分隔的多级名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.GetSection(System.String)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="key">配置名</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Configuration.IConfigProvider.GetConfig">
            <summary>返回获取配置的委托</summary>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Load``1(System.String)">
            <summary>加载配置到模型</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.IConfigProvider.Bind``1(``0,System.String,System.Action{NewLife.Configuration.IConfigSection})">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
            <param name="onChange">配置改变时执行的委托</param>
        </member>
        <member name="T:NewLife.Configuration.ConfigProvider">
            <summary>配置提供者基类</summary>
            <remarks>
            同时也是基于Items字典的内存配置提供者。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Root">
            <summary>根元素</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Keys">
            <summary>所有键</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.UsedKeys">
            <summary>已使用的键</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.MissedKeys">
            <summary>缺失的键</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.GetSection(System.String)">
            <summary>查找配置项。可得到子级和配置</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.GetConfig">
            <summary>返回获取配置的委托</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Init(System.String)">
            <summary>初始化提供者</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.LoadAll">
            <summary>从数据源加载数据到配置树</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Load``1(System.String)">
            <summary>加载配置到模型</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="path">路径。配置树位置，配置中心等多对象混合使用时</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.SaveAll">
            <summary>保存配置树到数据源</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Save``1(``0,System.String)">
            <summary>保存模型实例</summary>
            <typeparam name="T">模型</typeparam>
            <param name="model">模型实例</param>
            <param name="path">路径。配置树位置</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Bind``1(``0,System.Boolean,System.String)">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="autoReload">是否自动更新。默认true</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Bind``1(``0,System.String,System.Action{NewLife.Configuration.IConfigSection})">
            <summary>绑定模型，使能热更新，配置存储数据改变时同步修改模型属性</summary>
            <typeparam name="T">模型。可通过实现IConfigMapping接口来自定义映射配置到模型实例</typeparam>
            <param name="model">模型实例</param>
            <param name="path">命名空间。配置树位置，配置中心等多对象混合使用时</param>
            <param name="onChange">配置改变时执行的委托</param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.NotifyChange(System.Boolean)">
            <summary>通知绑定对象，配置数据有改变</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigProvider.DefaultProvider">
            <summary>默认提供者。默认xml</summary>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Register``1(System.String)">
            <summary>注册提供者</summary>
            <typeparam name="TProvider"></typeparam>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Configuration.ConfigProvider.Create(System.String)">
            <summary>根据指定名称创建提供者</summary>
            <remarks>
            如果是文件名，根据后缀确定使用哪一种提供者。
            </remarks>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.IConfigSection">
            <summary>配置对象</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Key">
            <summary>配置名</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Value">
            <summary>配置值</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Comment">
            <summary>注释</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Childs">
            <summary>子级</summary>
        </member>
        <member name="P:NewLife.Configuration.IConfigSection.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">配置名，支持冒号分隔的多级名称</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.ConfigSection">
            <summary>配置项</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Key">
            <summary>配置名</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Value">
            <summary>配置值</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Comment">
            <summary>注释</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Childs">
            <summary>子级</summary>
        </member>
        <member name="P:NewLife.Configuration.ConfigSection.Item(System.String)">
            <summary>获取 或 设置 配置值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.ConfigSection.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.InIConfigProvider">
            <summary>Ini文件配置提供者</summary>
            <remarks>
            支持从不同配置文件加载到不同配置模型
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.InIConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.InIConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.InIConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Configuration.JsonConfigProvider">
            <summary>Json文件配置提供者</summary>
            <remarks>
            支持从不同配置文件加载到不同配置模型
            </remarks>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.Map(System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Configuration.IConfigSection)">
            <summary>字典映射到配置树</summary>
            <param name="src"></param>
            <param name="section"></param>
        </member>
        <member name="M:NewLife.Configuration.JsonConfigProvider.Map(NewLife.Configuration.IConfigSection,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>配置树映射到字典</summary>
            <param name="section"></param>
            <param name="dst"></param>
        </member>
        <member name="T:NewLife.Configuration.XmlConfigProvider">
            <summary>Xml文件配置提供者</summary>
            <remarks>
            支持从不同配置文件加载到不同配置模型
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.XmlConfigProvider.RootName">
            <summary>根元素名称</summary>
        </member>
        <member name="M:NewLife.Configuration.XmlConfigProvider.Init(System.String)">
            <summary>初始化</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Configuration.XmlConfigProvider.OnRead(System.String,NewLife.Configuration.IConfigSection)">
            <summary>读取配置文件</summary>
            <param name="fileName">文件名</param>
            <param name="section">配置段</param>
        </member>
        <member name="M:NewLife.Configuration.XmlConfigProvider.GetString(NewLife.Configuration.IConfigSection)">
            <summary>获取字符串形式</summary>
            <param name="section">配置段</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.BinaryTree">
            <summary>二叉树</summary>
        </member>
        <member name="M:NewLife.Data.BinaryTree.GetAll(System.Int32)">
            <summary>遍历所有二叉树</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.Build(NewLife.Data.BinaryTree.Node,System.Double[],System.Collections.Generic.List{System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression}},System.Collections.Generic.List{System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression}})">
            <summary>构建表达式树</summary>
            <param name="node"></param>
            <param name="numbers"></param>
            <param name="ops"></param>
            <param name="sops"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.FullPermute``1(``0[])">
            <summary>遍历全排列</summary>
            <typeparam name="T"></typeparam>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.OperatorPermute(System.Collections.Generic.List{System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression}},System.Int32)">
            <summary>从4种运算符中挑选3个运算符</summary>
            <param name="operators"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.Cbrt(System.Double)">
            <summary>立方根</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.Execute(System.Double[],System.Double)">
            <summary>数学运算</summary>
            <param name="numbers"></param>
            <param name="result"></param>
        </member>
        <member name="T:NewLife.Data.DbRow">
            <summary>数据行</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/dbtable
            </remarks>
        </member>
        <member name="P:NewLife.Data.DbRow.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:NewLife.Data.DbRow.Index">
            <summary>行索引</summary>
        </member>
        <member name="M:NewLife.Data.DbRow.#ctor(NewLife.Data.DbTable,System.Int32)">
            <summary>构造数据行</summary>
            <param name="table"></param>
            <param name="index"></param>
        </member>
        <member name="P:NewLife.Data.DbRow.Item(System.Int32)">
            <summary>基于列索引访问</summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Data.DbRow.Item(System.String)">
            <summary>基于列名访问</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbRow.Get``1(System.String)">
            <summary>读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.DbTable">
            <summary>数据表</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/dbtable
            </remarks>
        </member>
        <member name="P:NewLife.Data.DbTable.Columns">
            <summary>数据列</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Types">
            <summary>数据列类型</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Rows">
            <summary>数据行</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Total">
            <summary>总行数</summary>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.Data.IDataReader)">
            <summary>读取数据</summary>
            <param name="dr"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadHeader(System.Data.IDataReader)">
            <summary>读取头部</summary>
            <param name="dr"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadData(System.Data.IDataReader,System.Int32[])">
            <summary>读取数据</summary>
            <param name="dr">数据读取器</param>
            <param name="fields">要读取的字段序列</param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadAsync(System.Data.Common.DbDataReader)">
            <summary>读取数据</summary>
            <param name="dr"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadDataAsync(System.Data.Common.DbDataReader,System.Int32[])">
            <summary>读取数据</summary>
            <param name="dr">数据读取器</param>
            <param name="fields">要读取的字段序列</param>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.IO.Stream)">
            <summary>从数据流读取</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadHeader(NewLife.Serialization.Binary)">
            <summary>读取头部</summary>
            <param name="bn"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadData(NewLife.Serialization.Binary,System.Int32)">
            <summary>读取数据</summary>
            <param name="bn"></param>
            <param name="rows"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(NewLife.Data.Packet)">
            <summary>读取</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.LoadFile(System.String,System.Boolean)">
            <summary>从文件加载</summary>
            <param name="file"></param>
            <param name="compressed">是否压缩</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Write(System.IO.Stream)">
            <summary>写入数据流</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteHeader(NewLife.Serialization.Binary)">
            <summary>写入头部到数据流</summary>
            <param name="bn"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteData(NewLife.Serialization.Binary)">
            <summary>写入数据部分到数据流</summary>
            <param name="bn"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ToPacket">
            <summary>转数据包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.SaveFile(System.String,System.Boolean)">
            <summary>保存到文件</summary>
            <param name="file"></param>
            <param name="compressed">是否压缩</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToJson(System.Boolean,System.Boolean,System.Boolean)">
            <summary>转Json字符串</summary>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToDictionary">
            <summary>转为字典数组形式</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.SaveCsv(System.String)">
            <summary>保存到Csv文件</summary>
            <param name="file"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.LoadCsv(System.String)">
            <summary>从Csv文件加载</summary>
            <param name="file"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.WriteModels``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>写入模型列表</summary>
            <typeparam name="T"></typeparam>
            <param name="models"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.ReadModels``1">
            <summary>数据表转模型列表。普通反射，便于DAL查询后转任意模型列表</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Get``1(System.Int32,System.String)">
            <summary>读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="row"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.TryGet``1(System.Int32,System.String,``0@)">
            <summary>尝试读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="row"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetColumn(System.String)">
            <summary>根据名称找字段序号</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToString">
            <summary>数据集</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Clone">
            <summary>克隆</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetEnumerator">
            <summary>获取枚举</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoAddress">
            <summary>地理地址</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Location">
            <summary>坐标</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Code">
            <summary>行政区域编码</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Country">
            <summary>国家</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Province">
            <summary>省份</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.City">
            <summary>城市</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.District">
            <summary>区县</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Township">
            <summary>乡镇</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Towncode">
            <summary>乡镇编码</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Street">
            <summary>街道</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.StreetNumber">
            <summary></summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Level">
            <summary>级别</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Precise">
            <summary>精确打点</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Confidence">
            <summary>可信度。[0-100]</summary>
        </member>
        <member name="M:NewLife.Data.GeoAddress.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoArea">
            <summary>地理区域</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Code">
            <summary>编码</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.ParentCode">
            <summary>父级</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Center">
            <summary>中心</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Polyline">
            <summary>边界</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Level">
            <summary>级别</summary>
        </member>
        <member name="M:NewLife.Data.GeoArea.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoHash">
            <summary>经纬坐标的一维编码表示</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/geo_hash
            
            一维编码表示一个矩形区域，前缀表示更大区域，例如北京wx4fbzdvs80包含在wx4fbzdvs里面。
            这个特性可以用于附近地点搜索。
            GeoHash编码位数及距离关系：
            1位，+-2500km；
            2位，+-630km；
            3位，+-78km；
            4位，+-20km；
            5位，+-2.4km；
            6位，+-610m；
            7位，+-76m；
            8位，+-19m；
            9位，+-2m；
            </remarks>
        </member>
        <member name="M:NewLife.Data.GeoHash.Encode(System.Double,System.Double,System.Int32)">
            <summary>编码坐标点为GeoHash字符串</summary>
            <param name="longitude">经度</param>
            <param name="latitude">纬度</param>
            <param name="charCount">字符个数。默认9位字符编码，精度2米</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.GeoHash.Decode(System.String)">
            <summary>解码GeoHash字符串为坐标点</summary>
            <param name="geohash"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoPoint">
            <summary>经纬度坐标</summary>
        </member>
        <member name="P:NewLife.Data.GeoPoint.Longitude">
            <summary>经度</summary>
        </member>
        <member name="P:NewLife.Data.GeoPoint.Latitude">
            <summary>纬度</summary>
        </member>
        <member name="M:NewLife.Data.GeoPoint.#ctor">
            <summary>经纬度坐标</summary>
        </member>
        <member name="M:NewLife.Data.GeoPoint.#ctor(System.Double,System.Double)">
            <summary>实例化经纬度坐标</summary>
            <param name="longitude"></param>
            <param name="latitude"></param>
        </member>
        <member name="M:NewLife.Data.GeoPoint.#ctor(System.String)">
            <summary>经纬度坐标</summary>
            <param name="location"></param>
        </member>
        <member name="M:NewLife.Data.GeoPoint.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IData">
            <summary>数据帧接口</summary>
        </member>
        <member name="P:NewLife.Data.IData.Packet">
            <summary>原始数据包</summary>
        </member>
        <member name="P:NewLife.Data.IData.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Data.IData.Message">
            <summary>解码后的消息</summary>
        </member>
        <member name="P:NewLife.Data.IData.UserState">
            <summary>用户自定义数据</summary>
        </member>
        <member name="T:NewLife.Data.IExtend">
            <summary>具有可读性的扩展数据</summary>
        </member>
        <member name="P:NewLife.Data.IExtend.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IExtend2">
            <summary>具有扩展数据字典</summary>
        </member>
        <member name="P:NewLife.Data.IExtend2.Keys">
            <summary>扩展数据键集合</summary>
        </member>
        <member name="T:NewLife.Data.IExtend3">
            <summary>具有扩展数据字典</summary>
        </member>
        <member name="P:NewLife.Data.IExtend3.Items">
            <summary>数据项</summary>
        </member>
        <member name="T:NewLife.Data.ExtendHelper">
            <summary>扩展数据助手</summary>
        </member>
        <member name="M:NewLife.Data.ExtendHelper.ToExtend(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>名值字典转扩展接口</summary>
            <param name="dictionary">字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.ExtendHelper.ToDictionary(NewLife.Data.IExtend)">
            <summary>扩展接口转名值字典</summary>
            <param name="extend">扩展对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.ExtendHelper.Copy(NewLife.Data.IExtend,NewLife.Data.IExtend)">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="source">源对象</param>
        </member>
        <member name="T:NewLife.Data.ExtendDictionary">
            <summary>扩展字典。引用型</summary>
        </member>
        <member name="P:NewLife.Data.ExtendDictionary.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Data.ExtendDictionary.Item(System.String)">
            <summary>获取 或 设置 数据</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IFilter">
            <summary>数据过滤器</summary>
        </member>
        <member name="P:NewLife.Data.IFilter.Next">
            <summary>下一个过滤器</summary>
        </member>
        <member name="M:NewLife.Data.IFilter.Execute(NewLife.Data.FilterContext)">
            <summary>对封包执行过滤器</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Data.FilterContext">
            <summary>过滤器上下文</summary>
        </member>
        <member name="P:NewLife.Data.FilterContext.Packet">
            <summary>封包</summary>
        </member>
        <member name="T:NewLife.Data.FilterHelper">
            <summary>过滤器助手</summary>
        </member>
        <member name="M:NewLife.Data.FilterHelper.Find(NewLife.Data.IFilter,System.Type)">
            <summary>在链条里面查找指定类型的过滤器</summary>
            <param name="filter"></param>
            <param name="filterType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.FilterBase">
            <summary>数据过滤器基类</summary>
        </member>
        <member name="P:NewLife.Data.FilterBase.Next">
            <summary>下一个过滤器</summary>
        </member>
        <member name="M:NewLife.Data.FilterBase.Execute(NewLife.Data.FilterContext)">
            <summary>对封包执行过滤器</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Data.FilterBase.OnExecute(NewLife.Data.FilterContext)">
            <summary>执行过滤</summary>
            <param name="context"></param>
            <returns>返回是否执行下一个过滤器</returns>
        </member>
        <member name="T:NewLife.Data.Packet">
            <summary>数据包</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/packet
            </remarks>
        </member>
        <member name="P:NewLife.Data.Packet.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Offset">
            <summary>偏移</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Count">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Next">
            <summary>下一个链式包</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Total">
            <summary>总长度</summary>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>根据数据区实例化</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.ArraySegment{System.Byte})">
            <summary>根据数组段实例化</summary>
            <param name="seg"></param>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.IO.Stream)">
            <summary>从可扩展内存流实例化，尝试窃取内存流内部的字节数组，失败后拷贝</summary>
            <remarks>因数据包内数组窃取自内存流，需要特别小心，避免多线程共用。常用于内存流转数据包，而内存流不再使用</remarks>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.Data.Packet.Item(System.Int32)">
            <summary>获取/设置 指定位置的字节</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Set(System.Byte[],System.Int32,System.Int32)">
            <summary>设置新的数据区</summary>
            <param name="data">数据区</param>
            <param name="offset">偏移</param>
            <param name="count">字节个数</param>
        </member>
        <member name="M:NewLife.Data.Packet.Slice(System.Int32,System.Int32)">
            <summary>截取子数据区</summary>
            <param name="offset">相对偏移</param>
            <param name="count">字节个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.IndexOf(System.Byte[],System.Int32,System.Int32)">
            <summary>查找目标数组</summary>
            <param name="data">目标数组</param>
            <param name="offset">本数组起始偏移</param>
            <param name="count">本数组搜索个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Append(NewLife.Data.Packet)">
            <summary>附加一个包到当前包链的末尾</summary>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Data.Packet.ToArray">
            <summary>返回字节数组。无差别复制</summary>
            <remarks>不一定是全新数据，如果需要全新数据请克隆</remarks>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ReadBytes(System.Int32,System.Int32)">
            <summary>从封包中读取指定数据，读取全部时直接返回缓冲区</summary>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToSegment">
            <summary>返回数据段</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToSegments">
            <summary>返回数据段集合</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.GetStream">
            <summary>获取封包的数据流形式</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.CopyTo(System.IO.Stream)">
            <summary>把封包写入到数据流</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.Packet.WriteTo(System.Byte[],System.Int32,System.Int32)">
            <summary>把封包写入到目标数组</summary>
            <param name="buffer">目标数组</param>
            <param name="offset">目标数组的偏移量</param>
            <param name="count">目标数组的字节数</param>
        </member>
        <member name="M:NewLife.Data.Packet.CopyToAsync(System.IO.Stream)">
            <summary>异步复制到目标数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Clone">
            <summary>深度克隆一份数据包，拷贝数据区</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToStr(System.Text.Encoding,System.Int32,System.Int32)">
            <summary>以字符串表示</summary>
            <param name="encoding">字符串编码，默认URF-8</param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToHex(System.Int32,System.String,System.Int32)">
            <summary>以十六进制编码表示</summary>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToBase64">
            <summary>转为Base64编码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.Byte[])~NewLife.Data.Packet">
            <summary>重载类型转换，字节数组直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.ArraySegment{System.Byte})~NewLife.Data.Packet">
            <summary>重载类型转换，一维数组直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.PageParameter">
            <summary>分页参数信息。可携带统计和数据权限扩展查询等信息</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/page_parameter
            </remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.Sort">
            <summary>获取 或 设置 排序字段，前台接收，便于做安全性校验</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.Desc">
            <summary>获取 或 设置 是否降序</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageIndex">
            <summary>获取 或 设置 页面索引。从1开始，默认1</summary>
            <remarks>如果设定了开始行，分页时将不再使用PageIndex</remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageSize">
            <summary>获取 或 设置 页面大小。默认20，若为0表示不分页</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.TotalCount">
            <summary>获取 或 设置 总记录数</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageCount">
            <summary>获取 页数</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.OrderBy">
            <summary>获取 或 设置 组合起来的排序字句。如果没有设置则取Sort+Desc，后台设置，不经过安全性校验</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.StartRow">
            <summary>获取 或 设置 开始行</summary>
            <remarks>如果设定了开始行，分页时将不再使用PageIndex</remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.RetrieveTotalCount">
            <summary>获取 或 设置 是否获取总记录数，默认false</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.State">
            <summary>获取 或 设置 状态。用于传递统计、扩展查询等用户数据</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.RetrieveState">
            <summary>获取 或 设置 是否获取统计，默认false</summary>
        </member>
        <member name="M:NewLife.Data.PageParameter.#ctor">
            <summary>实例化分页参数</summary>
        </member>
        <member name="M:NewLife.Data.PageParameter.#ctor(NewLife.Data.PageParameter)">
            <summary>通过另一个分页参数来实例化当前分页参数</summary>
            <param name="pm"></param>
        </member>
        <member name="M:NewLife.Data.PageParameter.CopyFrom(NewLife.Data.PageParameter)">
            <summary>从另一个分页参数拷贝到当前分页参数</summary>
            <param name="pm"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.PageParameter.GetKey">
            <summary>获取表示分页参数唯一性的键值，可用作缓存键</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.FlowId">
            <summary>流式Id</summary>
        </member>
        <member name="T:NewLife.Data.Snowflake">
            <summary>雪花算法。分布式Id，业务内必须确保单例</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/snow_flake
            
            使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增。
            1bit保留 + 41bit时间戳 + 10bit机器 + 12bit序列号
            
            内置自动选择机器workerId，IP+进程+线程，无法绝对保证唯一，从而导致整体生成的雪花Id有一定几率重复。
            如果想要绝对唯一，建议在外部设置唯一的workerId，再结合单例使用，此时确保最终生成的Id绝对不重复！
            高要求场合，推荐使用Redis自增序数作为workerId，在大型分布式系统中亦能保证绝对唯一。
            已提供JoinCluster方法，用于把当前对象加入集群，确保workerId唯一。
            </remarks>
        </member>
        <member name="P:NewLife.Data.Snowflake.Instance">
            <summary> 获取 Snowflake 单例 </summary>
        </member>
        <member name="P:NewLife.Data.Snowflake.StartTimestamp">
            <summary>开始时间戳。首次使用前设置，否则无效，默认1970-1-1</summary>
        </member>
        <member name="P:NewLife.Data.Snowflake.WorkerId">
            <summary>机器Id，取10位。内置默认取IP+进程+线程，不能保证绝对唯一，要求高的场合建议外部保证workerId唯一</summary>
        </member>
        <member name="P:NewLife.Data.Snowflake.Sequence">
            <summary>序列号，取12位。进程内静态，避免多个实例生成重复Id</summary>
        </member>
        <member name="P:NewLife.Data.Snowflake.Cluster">
            <summary>workerId分配集群。配置后可确保所有实例化的雪花对象得到唯一workerId，建议使用Redis</summary>
        </member>
        <member name="M:NewLife.Data.Snowflake.NewId">
            <summary>获取下一个Id</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.NewId(System.DateTime)">
            <summary>获取指定时间的Id，带上节点和序列号。可用于根据业务时间构造插入Id</summary>
            <param name="time">时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.GetId(System.DateTime)">
            <summary>时间转为Id，不带节点和序列号。可用于构建时间片段查询</summary>
            <param name="time">时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.TryParse(System.Int64,System.DateTime@,System.Int32@,System.Int32@)">
            <summary>尝试分析</summary>
            <param name="id"></param>
            <param name="time">时间</param>
            <param name="workerId">节点</param>
            <param name="sequence">序列号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Snowflake.JoinCluster(NewLife.Caching.ICache,System.String)">
            <summary>加入集群。由集群统一分配WorkerId，确保唯一，从而保证生成的雪花Id绝对唯一</summary>
            <param name="cache"></param>
            <param name="key"></param>
        </member>
        <member name="T:NewLife.EventArgs`1">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`1.Arg">
            <summary>参数</summary>
        </member>
        <member name="M:NewLife.EventArgs`1.#ctor(`0)">
            <summary>使用参数初始化</summary>
            <param name="arg"></param>
        </member>
        <member name="M:NewLife.EventArgs`1.Pop(`0@)">
            <summary>弹出</summary>
            <param name="arg"></param>
        </member>
        <member name="T:NewLife.EventArgs`2">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="M:NewLife.EventArgs`2.#ctor(`0,`1)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:NewLife.EventArgs`2.Pop(`0@,`1@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="T:NewLife.EventArgs`3">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="M:NewLife.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:NewLife.EventArgs`3.Pop(`0@,`1@,`2@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="T:NewLife.EventArgs`4">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg4">
            <summary>参数4</summary>
        </member>
        <member name="M:NewLife.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="M:NewLife.EventArgs`4.Pop(`0@,`1@,`2@,`3@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="T:NewLife.WeakAction`1">
            <summary>弱引用Action</summary>
            <remarks>
            常见的事件和委托，都包括两部分：对象和方法，当然如果委托到静态方法上，对象是为空的。
            如果把事件委托到某个对象的方法上，同时就间接的引用了这个对象，导致其一直无法被回收，从而造成内存泄漏。
            弱引用Action，原理就是把委托拆分，然后弱引用对象部分，需要调用委托的时候，再把对象“拉”回来，如果被回收了，就没有必要再调用它的方法了。
            
            文档 https://www.yuque.com/smartstone/nx/weak_action
            </remarks>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakAction`1.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Method">
            <summary>委托方法</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Handler">
            <summary>经过包装的新的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.UnHandler">
            <summary>取消注册的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Once">
            <summary>是否只使用一次，如果只使用一次，执行委托后马上取消注册</summary>
        </member>
        <member name="P:NewLife.WeakAction`1.IsAlive">
            <summary>是否可用</summary>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>实例化</summary>
            <param name="target">目标对象</param>
            <param name="method">目标方法</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo,System.Action{System.Action{`0}},System.Boolean)">
            <summary>实例化</summary>
            <param name="target">目标对象</param>
            <param name="method">目标方法</param>
            <param name="unHandler">取消注册回调</param>
            <param name="once">是否一次性事件</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate)">
            <summary>实例化</summary>
            <param name="handler">事件处理器</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate,System.Action{System.Action{`0}},System.Boolean)">
            <summary>使用事件处理器、取消注册回调、是否一次性事件来初始化</summary>
            <param name="handler">事件处理器</param>
            <param name="unHandler">取消注册回调</param>
            <param name="once">是否一次性事件</param>
        </member>
        <member name="M:NewLife.WeakAction`1.Invoke(`0)">
            <summary>调用委托</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.op_Implicit(NewLife.WeakAction{`0})~System.Action{`0}">
            <summary>把弱引用事件处理器转换为普通事件处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakAction`1.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.XException">
            <summary>X组件异常</summary>
        </member>
        <member name="M:NewLife.XException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="innerException"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:NewLife.ExceptionEventArgs">
            <summary>异常事件参数</summary>
        </member>
        <member name="P:NewLife.ExceptionEventArgs.Action">
            <summary>发生异常时进行的动作</summary>
        </member>
        <member name="P:NewLife.ExceptionEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="T:NewLife.ExceptionHelper">
            <summary>异常助手</summary>
        </member>
        <member name="M:NewLife.ExceptionHelper.IsDisposed(System.Exception)">
            <summary>是否对象已被释放异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Expressions.MathExpression">
            <summary>数学表达式</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.AddChar">
            <summary>加法</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.SubtractChar">
            <summary>减法</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.MultiplyChar">
            <summary>乘法</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.DivideChar">
            <summary>除法</summary>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.GetOperationLevel(System.String)">
            <summary>计算运算符优先级</summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.AdapteAndReplace(System.String)">
            <summary>适配和替换</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.Complie(System.String,System.Object[])">
            <summary>解逆波兰表达式</summary>
            <param name="expression">标准逆波兰表达式</param>
            <param name="args"></param>
            <returns>逆波兰表达式的解</returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.IsValid(System.String[])">
            <summary>是否有效</summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.ToDouble(System.String)">
            <summary>转为浮点数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.ComplieRpnExp(System.Double,System.Double,System.String)">
            <summary>
            计算逆波兰表达式
            </summary>
            <param name="last">最后压入数字堆栈的数字</param>
            <param name="first">首先压入数字堆栈的数字</param>
            <param name="op">操作运算符</param>
            <returns>返回计算结果</returns>
        </member>
        <member name="T:NewLife.Expressions.RpnExpression">
            <summary>逆波兰表达式</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.LeftBracket">
            <summary>左括号</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.RightBracket">
            <summary>右括号</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.JoinChar">
            <summary>连接符</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.EmptyChar">
            <summary>空格</summary>
        </member>
        <member name="P:NewLife.Expressions.RpnExpression.OperationChars">
            <summary>操作符数组</summary>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsBracket(System.String)">
            <summary>是否括号</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsBracket(System.Char)">
            <summary>是否括号</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.GetOperationLevel(System.String)">
            <summary>计算操作等级</summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsBracketMatch(System.String)">
            <summary>是否括号匹配</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.AdapteAndReplace(System.String)">
            <summary>适配器和替换</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Expressions.RpnExpression.Value">
            <summary>值</summary>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.ToExpression(System.String)">
            <summary>将中缀表达式转换为逆波兰表达式</summary>
            <param name="expression">标准中缀表达式</param>
            <returns>标准逆波兰表达式</returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsValid(System.String[])">
            <summary>是否有效</summary>
            <param name="splitArray"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.Complie(System.String,System.Object[])">
            <summary>编译计算</summary>
            <param name="expression"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Expressions.UnionExpresion">
            <summary>与或非表达式</summary>
        </member>
        <member name="F:NewLife.Expressions.UnionExpresion.AndChar">
            <summary>位与</summary>
        </member>
        <member name="F:NewLife.Expressions.UnionExpresion.OrChar">
            <summary>位或</summary>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.GetOperationLevel(System.String)">
            <summary>操作符等级</summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.AdapteAndReplace(System.String)">
            <summary>适配替换</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Expressions.UnionExpresion.Container">
            <summary>容器</summary>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.Complie(System.String,System.Object[])">
            <summary>解逆波兰表达式</summary>
            <param name="expression">标准逆波兰表达式</param>
            <param name="args"></param>
            <returns>逆波兰表达式的解</returns>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.IsValid(System.String[])">
            <summary>是否有效</summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.GetAllMarks">
            <summary>所有掩码</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.BitHelper">
            <summary>数据位助手</summary>
        </member>
        <member name="M:NewLife.BitHelper.SetBit(System.UInt16,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.SetBits(System.UInt16,System.Int32,System.Int32,System.UInt16)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="length"></param>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.SetBit(System.Byte,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.GetBit(System.UInt16,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.GetBits(System.UInt16,System.Int32,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.BitHelper.GetBit(System.Byte,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.EnumHelper">
            <summary>枚举类型助手类</summary>
        </member>
        <member name="M:NewLife.EnumHelper.Has(System.Enum,System.Enum)">
            <summary>枚举变量是否包含指定标识</summary>
            <param name="value">枚举变量</param>
            <param name="flag">要判断的标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.Set``1(System.Enum,``0,System.Boolean)">
            <summary>设置标识位</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="flag"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.GetDescription(System.Enum)">
            <summary>获取枚举字段的注释</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.GetDescriptions``1">
            <summary>获取枚举类型的所有字段注释</summary>
            <typeparam name="TEnum"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.EnumHelper.GetDescriptions(System.Type)">
            <summary>获取枚举类型的所有字段注释</summary>
            <param name="enumType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Extension.SpeakProvider.SpeakAsyncCancelAll">
            <summary>
            停止话音播报
            </summary>
        </member>
        <member name="T:NewLife.StringHelper">
            <summary>字符串助手类</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/string_helper
            </remarks>
        </member>
        <member name="M:NewLife.StringHelper.EqualIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串相等比较，判断是否与任意一个待比较字符串相等</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.StartsWithIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串开始比较，判断是否与任意一个待比较字符串开始</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.EndsWithIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串结束比较，判断是否以任意一个待比较字符串结束</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.IsNullOrEmpty(System.String)">
            <summary>指示指定的字符串是 null 还是 String.Empty 字符串</summary>
            <param name="value">字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.IsNullOrWhiteSpace(System.String)">
            <summary>是否空或者空白字符串</summary>
            <param name="value">字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Split(System.String,System.String[])">
            <summary>拆分字符串，过滤空格，无效时返回空数组</summary>
            <param name="value">字符串</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsInt(System.String,System.String[])">
            <summary>拆分字符串成为整型数组，默认逗号分号分隔，无效时返回空数组</summary>
            <remarks>过滤空格、过滤无效、不过滤重复</remarks>
            <param name="value">字符串</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsDictionary(System.String,System.String,System.String[])">
            <summary>拆分字符串成为不区分大小写的可空名值字典。逗号分号分组，等号分隔</summary>
            <param name="value">字符串</param>
            <param name="nameValueSeparator">名值分隔符，默认等于号</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsDictionary(System.String,System.String,System.String,System.Boolean)">
            <summary>拆分字符串成为不区分大小写的可空名值字典。逗号分组，等号分隔</summary>
            <param name="value">字符串</param>
            <param name="nameValueSeparator">名值分隔符，默认等于号</param>
            <param name="separator">分组分隔符，默认分号</param>
            <param name="trimQuotation">去掉括号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.SplitAsDictionaryT(System.String,System.Char,System.Char,System.Boolean)">
            <summary>
            在.netCore需要区分该部分内容
            </summary>
            <param name="value"></param>
            <param name="nameValueSeparator"></param>
            <param name="separator"></param>
            <param name="trimQuotation"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Join(System.Collections.IEnumerable,System.String)">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Join``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.Object})">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <param name="func">把对象转为字符串的委托</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Separate(System.Text.StringBuilder,System.String)">
            <summary>追加分隔符字符串，忽略开头，常用于拼接</summary>
            <param name="sb">字符串构造者</param>
            <param name="separator">分隔符</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.GetBytes(System.String,System.Text.Encoding)">
            <summary>字符串转数组</summary>
            <param name="value">字符串</param>
            <param name="encoding">编码，默认utf-8无BOM</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.F(System.String,System.Object[])">
            <summary>格式化字符串。特别支持无格式化字符串的时间参数</summary>
            <param name="value">格式字符串</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.IsMatch(System.String,System.String,System.StringComparison)">
            <summary>指定输入是否匹配目标表达式，支持*匹配</summary>
            <param name="pattern">匹配表达式</param>
            <param name="input">输入字符串</param>
            <param name="comparisonType">字符串比较方式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.EnsureStart(System.String,System.String)">
            <summary>确保字符串以指定的另一字符串开始，不区分大小写</summary>
            <param name="str">字符串</param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.EnsureEnd(System.String,System.String)">
            <summary>确保字符串以指定的另一字符串结束，不区分大小写</summary>
            <param name="str">字符串</param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.TrimStart(System.String,System.String[])">
            <summary>从当前字符串开头移除另一字符串，不区分大小写，循环多次匹配前缀</summary>
            <param name="str">当前字符串</param>
            <param name="starts">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.TrimEnd(System.String,System.String[])">
            <summary>从当前字符串结尾移除另一字符串，不区分大小写，循环多次匹配后缀</summary>
            <param name="str">当前字符串</param>
            <param name="ends">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Substring(System.String,System.String,System.String,System.Int32,System.Int32[])">
            <summary>从字符串中检索子字符串，在指定头部字符串之后，指定尾部字符串之前</summary>
            <remarks>常用于截取xml某一个元素等操作</remarks>
            <param name="str">目标字符串</param>
            <param name="after">头部字符串，在它之后</param>
            <param name="before">尾部字符串，在它之前</param>
            <param name="startIndex">搜索的开始位置</param>
            <param name="positions">位置数组，两个元素分别记录头尾位置</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Cut(System.String,System.Int32,System.String)">
            <summary>根据最大长度截取字符串，并允许以指定空白填充末尾</summary>
            <param name="str">字符串</param>
            <param name="maxLength">截取后字符串的最大允许长度，包含后面填充</param>
            <param name="pad">需要填充在后面的字符串，比如几个圆点</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.CutStart(System.String,System.String[])">
            <summary>从当前字符串开头移除另一字符串以及之前的部分</summary>
            <param name="str">当前字符串</param>
            <param name="starts">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.CutEnd(System.String,System.String[])">
            <summary>从当前字符串结尾移除另一字符串以及之后的部分</summary>
            <param name="str">当前字符串</param>
            <param name="ends">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LevenshteinSearch(System.String,System.String[])">
            <summary>编辑距离搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key">关键字</param>
            <param name="words">词组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LevenshteinDistance(System.String,System.String)">
            <summary>编辑距离</summary>
            <remarks>
            又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。
            许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="str1"></param>
            <param name="str2"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCSSearch(System.String,System.String[])">
            <summary>最长公共子序列搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key"></param>
            <param name="words"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCSDistance(System.String,System.String[])">
            <summary>
            最长公共子序列问题是寻找两个或多个已知数列最长的子序列。
            一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。
            The longest common subsequence (LCS) problem is to find the longest subsequence common to all sequences in a set of sequences (often just two). Note that subsequence is different from a substring, see substring vs. subsequence. It is a classic computer science problem, the basis of diff (a file comparison program that outputs the differences between two files), and has applications in bioinformatics.
            </summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="word"></param>
            <param name="keys">多个关键字。长度必须大于0，必须按照字符串长度升序排列。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCS``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>根据列表项成员计算距离</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.LCSSearch``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.Int32)">
            <summary>在列表项中进行模糊搜索</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Match``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>模糊匹配</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Match(System.String,System.String,System.Int32)">
            <summary>模糊匹配</summary>
            <param name="str"></param>
            <param name="key"></param>
            <param name="maxError"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Match``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.Int32,System.Double)">
            <summary>模糊匹配</summary>
            <typeparam name="T"></typeparam>
            <param name="list">列表项</param>
            <param name="keys">关键字</param>
            <param name="keySelector">匹配字符串选择</param>
            <param name="count">获取个数</param>
            <param name="confidence">权重阀值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.StringHelper.Speak(System.String)">
            <summary>调用语音引擎说出指定话</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.StringHelper.SpeakAsync(System.String)">
            <summary>异步调用语音引擎说出指定话。可能导致后来的调用打断前面的语音</summary>
            <param name="value"></param>
        </member>
        <member name="P:NewLife.StringHelper.EnableSpeechTip">
            <summary>启用语音提示</summary>
        </member>
        <member name="M:NewLife.StringHelper.SpeechTip(System.String)">
            <summary>语音提示操作</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.StringHelper.SpeakAsyncCancelAll(System.String)">
            <summary>
            停止所有语音播报
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.StringHelper.Run(System.String,System.String,System.Int32,System.Action{System.String},System.Action{System.Diagnostics.Process},System.String)">
            <summary>以隐藏窗口执行命令行</summary>
            <param name="cmd">文件名</param>
            <param name="arguments">命令参数</param>
            <param name="msWait">等待毫秒数</param>
            <param name="output">进程输出内容。默认为空时输出到日志</param>
            <param name="onExit">进程退出时执行</param>
            <param name="working">工作目录</param>
            <returns>进程退出代码</returns>
        </member>
        <member name="T:NewLife.Http.ControllerHandler">
            <summary>控制器处理器</summary>
        </member>
        <member name="P:NewLife.Http.ControllerHandler.ControllerType">
            <summary>控制器类型</summary>
        </member>
        <member name="M:NewLife.Http.ControllerHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.DefaultHttpClientFactory">
            <summary>默认HttpClient工厂</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpClientFactory.HandlerLifetime">
            <summary>处理器有效时间</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpClientFactory.InnerHandler">
            <summary>内部处理器</summary>
        </member>
        <member name="M:NewLife.Http.DefaultHttpClientFactory.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Http.DefaultHttpClientFactory.CreateClient(System.String)">
            <summary>创建HttpClient</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.DefaultHttpClientFactory.CreateHandler(System.String)">
            <summary>创建处理器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Http.DefaultHttpClientFactory.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Http.DefaultHttpClientFactory.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Http.FormFile">
            <summary>表单部分</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.ContentDisposition">
            <summary>内容部署</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Http.FormFile.Length">
            <summary>长度</summary>
        </member>
        <member name="M:NewLife.Http.FormFile.OpenReadStream">
            <summary>打开数据读取流</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.FormFile.SaveToFile(System.String)">
            <summary>保存到文件</summary>
            <param name="fileName"></param>
        </member>
        <member name="T:NewLife.Http.HttpBase">
            <summary>Http请求响应基类</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Version">
            <summary>协议版本</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Body">
            <summary>请求或响应的主体部分</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.BodyLength">
            <summary>主体长度</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.IsCompleted">
            <summary>是否已完整。头部未指定长度，或指定长度后内容已满足</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Headers">
            <summary>头部集合</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Item(System.String)">
            <summary>获取/设置 头部</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.FastValidHeader(NewLife.Data.Packet)">
            <summary>快速验证协议头，剔除非HTTP协议。仅排除，验证通过不一定就是HTTP协议</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.Parse(NewLife.Data.Packet)">
            <summary>分析请求头</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpBase.Build">
            <summary>创建请求响应包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpCodec">
            <summary>Http编解码器</summary>
        </member>
        <member name="P:NewLife.Http.HttpCodec.AllowParseHeader">
            <summary>允许分析头部。默认false</summary>
            <remarks>
            分析头部对性能有一定损耗
            </remarks>
        </member>
        <member name="M:NewLife.Http.HttpCodec.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpCodec.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpMessage">
            <summary>Http消息</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Error">
            <summary>是否有错</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.OneWay">
            <summary>单向请求</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Header">
            <summary>头部数据</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Method">
            <summary>请求方法</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Uri">
            <summary>请求资源</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Http.HttpMessage.Headers">
            <summary>头部集合</summary>
        </member>
        <member name="M:NewLife.Http.HttpMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Http.HttpMessage.ParseHeaders">
            <summary>解码头部</summary>
        </member>
        <member name="M:NewLife.Http.HttpMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpEncoder">
            <summary>Http编码器</summary>
        </member>
        <member name="P:NewLife.Http.HttpEncoder.UseHttpStatus">
            <summary>是否使用Http状态。默认false，使用json包装响应码</summary>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.Encode(System.String,System.Int32,System.Object)">
            <summary>编码</summary>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.DecodeParameters(System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>解码参数</summary>
            <param name="action"></param>
            <param name="data"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.DecodeResult(System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>解码结果</summary>
            <param name="action"></param>
            <param name="data"></param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.Convert(System.Object,System.Type)">
            <summary>转换为目标类型</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.CreateRequest(System.String,System.Object)">
            <summary>创建请求</summary>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.CreateResponse(NewLife.Messaging.IMessage,System.String,System.Int32,System.Object)">
            <summary>创建响应</summary>
            <param name="msg"></param>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpEncoder.Decode(NewLife.Messaging.IMessage,System.String@,System.Int32@,NewLife.Data.Packet@)">
            <summary>解码 请求/响应</summary>
            <param name="msg">消息</param>
            <param name="action">服务动作</param>
            <param name="code">错误码</param>
            <param name="value">参数或结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpHelper">
            <summary>Http帮助类</summary>
        </member>
        <member name="P:NewLife.Http.HttpHelper.Tracer">
            <summary>性能跟踪器</summary>
        </member>
        <member name="P:NewLife.Http.HttpHelper.Filter">
            <summary>Http过滤器</summary>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeRequest(System.String,System.Uri,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Data.Packet)">
            <summary>创建请求包</summary>
            <param name="method"></param>
            <param name="uri"></param>
            <param name="headers"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeResponse(System.Net.HttpStatusCode,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Data.Packet)">
            <summary>创建响应包</summary>
            <param name="code"></param>
            <param name="headers"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ParseHeader(NewLife.Data.Packet)">
            <summary>分析头部</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostJsonAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>异步提交Json</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostJson(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步提交Json</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostXmlAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>异步提交Xml</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostXml(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步提交Xml</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostFormAsync(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>异步提交表单</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.PostForm(System.Net.Http.HttpClient,System.String,System.Object,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步提交表单</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="data">数据</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.GetString(System.Net.Http.HttpClient,System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>同步获取字符串</summary>
            <param name="client">Http客户端</param>
            <param name="requestUri">请求资源地址</param>
            <param name="headers">附加头部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.DownloadFileAsync(System.Net.Http.HttpClient,System.String,System.String)">
            <summary>下载文件</summary>
            <param name="client"></param>
            <param name="address"></param>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(NewLife.Http.WebSocket,NewLife.Caching.IProducerConsumer{System.String},System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket"></param>
            <param name="queue"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(NewLife.Http.WebSocket,NewLife.Caching.ICache,System.String,System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket"></param>
            <param name="host"></param>
            <param name="topic"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(System.Net.WebSockets.WebSocket,NewLife.Caching.IProducerConsumer{System.String},System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket"></param>
            <param name="queue"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ConsumeAndPushAsync(System.Net.WebSockets.WebSocket,NewLife.Caching.ICache,System.String,System.Threading.CancellationTokenSource)">
            <summary>从队列消费消息并推送到WebSocket客户端</summary>
            <param name="socket"></param>
            <param name="host"></param>
            <param name="topic"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpRequest">
            <summary>Http请求</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Method">
            <summary>Http方法</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Url">
            <summary>资源路径</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Host">
            <summary>目标主机</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Files">
            <summary>文件集合</summary>
        </member>
        <member name="M:NewLife.Http.HttpRequest.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpRequest.FastParse(NewLife.Data.Packet)">
            <summary>快速分析请求头，只分析第一行</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpRequest.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpRequest.ParseFormData">
            <summary>分析表单数据</summary>
        </member>
        <member name="M:NewLife.Http.HttpRequest.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpResponse">
            <summary>Http响应</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.StatusCode">
            <summary>状态码</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.StatusDescription">
            <summary>状态描述</summary>
        </member>
        <member name="M:NewLife.Http.HttpResponse.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpResponse.Build">
            <summary>创建请求响应包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpResponse.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpResponse.Valid">
            <summary>验证，如果失败则抛出异常</summary>
        </member>
        <member name="M:NewLife.Http.HttpResponse.SetResult(System.Object,System.String)">
            <summary>设置结果，影响Body和ContentType</summary>
            <param name="result"></param>
            <param name="contentType"></param>
        </member>
        <member name="M:NewLife.Http.HttpResponse.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpServer">
            <summary>Http服务器</summary>
        </member>
        <member name="P:NewLife.Http.HttpServer.ServerName">
            <summary>Http响应头Server名称</summary>
        </member>
        <member name="P:NewLife.Http.HttpServer.Routes">
            <summary>路由映射</summary>
        </member>
        <member name="M:NewLife.Http.HttpServer.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Http.HttpServer.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map(System.String,NewLife.Http.IHttpHandler)">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map(System.String,NewLife.Http.HttpProcessDelegate)">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``1(System.String,System.Func{``0})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``2(System.String,System.Func{``0,``1})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``3(System.String,System.Func{``0,``1,``2})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``4(System.String,System.Func{``0,``1,``2,``3})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.Map``5(System.String,System.Func{``0,``1,``2,``3,``4})">
            <summary>映射路由处理器</summary>
            <param name="path"></param>
            <param name="handler"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MapController``1(System.String)">
            <summary>映射控制器</summary>
            <typeparam name="TController"></typeparam>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MapController(System.Type,System.String)">
            <summary>映射控制器</summary>
            <param name="controllerType"></param>
            <param name="path"></param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MapStaticFiles(System.String,System.String)">
            <summary>映射静态文件</summary>
            <param name="path">映射路径，如 /js</param>
            <param name="contentPath">内容目录，如 /wwwroot/js</param>
        </member>
        <member name="M:NewLife.Http.HttpServer.MatchHandler(System.String)">
            <summary>匹配处理器</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpSession">
            <summary>Http会话</summary>
        </member>
        <member name="P:NewLife.Http.HttpSession.Request">
            <summary>请求</summary>
        </member>
        <member name="M:NewLife.Http.HttpSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Http.HttpSession.OnNewRequest(NewLife.Http.HttpRequest,NewLife.Net.ReceivedEventArgs)">
            <summary>收到新的Http请求，只有头部</summary>
            <param name="request"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Http.HttpSession.ProcessRequest(NewLife.Http.HttpRequest,NewLife.Net.ReceivedEventArgs)">
            <summary>处理Http请求</summary>
            <param name="request"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpSession.PrepareRequest(NewLife.Http.IHttpContext)">
            <summary>准备请求参数</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.HttpTraceHandler">
            <summary>支持APM跟踪的HttpClient处理器</summary>
        </member>
        <member name="P:NewLife.Http.HttpTraceHandler.Tracer">
            <summary>APM跟踪器</summary>
        </member>
        <member name="M:NewLife.Http.HttpTraceHandler.#ctor(System.Net.Http.HttpMessageHandler)">
            <summary>实例化一个支持APM的HttpClient处理器</summary>
            <param name="innerHandler"></param>
        </member>
        <member name="M:NewLife.Http.HttpTraceHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <summary>发送请求</summary>
            <param name="request"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.IHttpClientFactory">
            <summary>HttpClient工厂</summary>
        </member>
        <member name="M:NewLife.Http.IHttpClientFactory.CreateClient(System.String)">
            <summary>创建HttpClient</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.IHttpContext">
            <summary>Http上下文</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Connection">
            <summary>连接会话</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.WebSocket">
            <summary>WebSocket连接</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Path">
            <summary>执行路径</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Http.IHttpContext.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="T:NewLife.Http.DefaultHttpContext">
            <summary>默认Http上下文</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Connection">
            <summary>连接会话</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.WebSocket">
            <summary>WebSocket连接</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Path">
            <summary>执行路径</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Http.DefaultHttpContext.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="T:NewLife.Http.IHttpFilter">
            <summary>Http过滤器，拦截请求前后</summary>
        </member>
        <member name="M:NewLife.Http.IHttpFilter.OnRequest(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,System.Object)">
            <summary>请求前</summary>
            <param name="client">客户端</param>
            <param name="request">请求消息</param>
            <param name="state">状态数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.IHttpFilter.OnResponse(System.Net.Http.HttpClient,System.Net.Http.HttpResponseMessage,System.Object)">
            <summary>获取响应后</summary>
            <param name="client">客户端</param>
            <param name="response">响应消息</param>
            <param name="state">状态数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.IHttpFilter.OnError(System.Net.Http.HttpClient,System.Exception,System.Object)">
            <summary>发生错误时</summary>
            <param name="client">客户端</param>
            <param name="exception">异常</param>
            <param name="state">状态数据</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.IHttpHandler">
            <summary>Http处理器</summary>
        </member>
        <member name="M:NewLife.Http.IHttpHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.HttpProcessDelegate">
            <summary>Http请求处理委托</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.DelegateHandler">
            <summary>委托Http处理器</summary>
        </member>
        <member name="P:NewLife.Http.DelegateHandler.Callback">
            <summary>委托</summary>
        </member>
        <member name="M:NewLife.Http.DelegateHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Http.DelegateHandler.OnInvoke(System.Delegate,NewLife.Http.IHttpContext)">
            <summary>复杂调用</summary>
            <param name="handler"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.StaticFilesHandler">
            <summary>静态文件处理器</summary>
        </member>
        <member name="P:NewLife.Http.StaticFilesHandler.Path">
            <summary>映射路径</summary>
        </member>
        <member name="P:NewLife.Http.StaticFilesHandler.ContentPath">
            <summary>内容目录</summary>
        </member>
        <member name="M:NewLife.Http.StaticFilesHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Http.TinyHttpClient">
            <summary>迷你Http客户端。支持https和302跳转</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.BaseAddress">
            <summary>基础地址</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.StatusCode">
            <summary>状态码</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.StatusDescription">
            <summary>状态描述</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Timeout">
            <summary>超时时间。默认15s</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Headers">
            <summary>头部集合</summary>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetStreamAsync(System.Uri)">
            <summary>获取网络数据流</summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendDataAsync(System.Uri,NewLife.Data.Packet)">
            <summary>异步请求</summary>
            <param name="uri"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendAsync(System.Uri,System.Byte[])">
            <summary>异步发出请求，并接收响应</summary>
            <param name="uri"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.ReadChunkAsync(NewLife.Data.Packet)">
            <summary>读取分片，返回链式Packet</summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetStream(System.Uri)">
            <summary>获取网络数据流</summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendData(System.Uri,NewLife.Data.Packet)">
            <summary>异步请求</summary>
            <param name="uri"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.Send(System.Uri,System.Byte[])">
            <summary>异步发出请求，并接收响应</summary>
            <param name="uri"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.ReadChunk(NewLife.Data.Packet)">
            <summary>读取分片，返回链式Packet</summary>
            <param name="body"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.BuildRequest(System.Uri,System.Byte[])">
            <summary>构造请求头</summary>
            <param name="uri"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.ParseResponse(NewLife.Data.Packet)">
            <summary>解析响应</summary>
            <param name="rs"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetPool(System.String)">
            <summary>根据主机获取对象池</summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetStringAsync(System.String)">
            <summary>异步获取</summary>
            <param name="url">地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetString(System.String)">
            <summary>同步获取</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.Invoke``1(System.String,System.Object)">
            <summary>同步调用，阻塞等待</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.TokenHttpFilter">
            <summary>Http令牌过滤器，请求前加上令牌，请求后拦截401/403</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.UserName">
            <summary>用户</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Password">
            <summary>密钥</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.SecurityKey">
            <summary>安全密钥。keyName$keyValue</summary>
            <remarks>
            公钥，用于RSA加密用户密码，在通信链路上保护用户密码安全，可以写死在代码里面。
            密钥前面可以增加keyName，形成keyName$keyValue，用于向服务端指示所使用的密钥标识，方便未来更换密钥。
            </remarks>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Action">
            <summary>申请令牌动作名，默认 OAuth/Token</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Token">
            <summary>令牌信息</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.Expire">
            <summary>令牌有效期</summary>
        </member>
        <member name="P:NewLife.Http.TokenHttpFilter.ErrorCodes">
            <summary>清空令牌的错误码。默认401和403</summary>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.OnRequest(System.Net.Http.HttpClient,System.Net.Http.HttpRequestMessage,System.Object)">
            <summary>请求前</summary>
            <param name="client">客户端</param>
            <param name="request">请求消息</param>
            <param name="state">状态数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.EncodePassword(System.String,System.String)">
            <summary>编码密码，在传输中保护安全，一般使用RSA加密</summary>
            <param name="username"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.OnResponse(System.Net.Http.HttpClient,System.Net.Http.HttpResponseMessage,System.Object)">
            <summary>获取响应后</summary>
            <param name="client">客户端</param>
            <param name="response">响应消息</param>
            <param name="state">状态数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TokenHttpFilter.OnError(System.Net.Http.HttpClient,System.Exception,System.Object)">
            <summary>发生错误时</summary>
            <param name="client">客户端</param>
            <param name="exception">异常</param>
            <param name="state">状态数据</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.WebSocketDelegate">
            <summary>WebSocket消息处理</summary>
            <param name="socket"></param>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Http.WebSocket">
            <summary>WebSocket会话管理</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Connected">
            <summary>是否还在连接</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Handler">
            <summary>消息处理器</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.Context">
            <summary>Http上下文</summary>
        </member>
        <member name="P:NewLife.Http.WebSocket.ActiveTime">
            <summary>活跃时间</summary>
        </member>
        <member name="M:NewLife.Http.WebSocket.Handshake(NewLife.Http.IHttpContext)">
            <summary>WebSocket 握手</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.WebSocket.Process(NewLife.Data.Packet)">
            <summary>处理WebSocket数据包，不支持超大数据帧（默认8k）</summary>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.Send(NewLife.Data.Packet,NewLife.Http.WebSocketMessageType)">
            <summary>发送消息</summary>
            <param name="data"></param>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.Send(System.String)">
            <summary>发送文本消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.SendAll(NewLife.Data.Packet,NewLife.Http.WebSocketMessageType,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>向所有连接发送消息</summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.SendAll(System.String,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>想所有连接发送文本消息</summary>
            <param name="message"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:NewLife.Http.WebSocket.Close(System.Int32,System.String)">
            <summary>发送关闭连接</summary>
            <param name="closeStatus"></param>
            <param name="statusDescription"></param>
        </member>
        <member name="T:NewLife.Http.WebSocketHandler">
            <summary>WebSocket处理器</summary>
        </member>
        <member name="M:NewLife.Http.WebSocketHandler.ProcessRequest(NewLife.Http.IHttpContext)">
            <summary>处理请求</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Http.WebSocketHandler.ProcessMessage(NewLife.Http.WebSocket,NewLife.Http.WebSocketMessage)">
            <summary>处理消息</summary>
            <param name="socket"></param>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Http.WebSocketMessageType">
            <summary>WebSocket消息类型</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Data">
            <summary>附加数据</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Text">
            <summary>文本数据</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Binary">
            <summary>二进制数据</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Close">
            <summary>连接关闭</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Ping">
            <summary>心跳</summary>
        </member>
        <member name="F:NewLife.Http.WebSocketMessageType.Pong">
            <summary>心跳响应</summary>
        </member>
        <member name="T:NewLife.Http.WebSocketMessage">
            <summary>WebSocket消息</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.Fin">
            <summary>消息是否结束</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.Type">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.MaskKey">
            <summary>加密数据的掩码</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.CloseStatus">
            <summary>关闭状态。仅用于Close消息</summary>
        </member>
        <member name="P:NewLife.Http.WebSocketMessage.StatusDescription">
            <summary>关闭状态描述。仅用于Close消息</summary>
        </member>
        <member name="M:NewLife.Http.WebSocketMessage.Read(NewLife.Data.Packet)">
            <summary>读取消息</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.WebSocketMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.CsvDb`1">
            <summary>Csv文件轻量级数据库</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/csv_db
            适用于大量数据需要快速存储、快速查找，很少修改和删除的场景。
            在桌面客户端中，关系型数据库SQLite很容易因非法关机而损坏，本数据库能跳过损坏行，自动恢复。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.IO.CsvDb`1.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.IO.CsvDb`1.Encoding">
            <summary>文件编码，默认utf8</summary>
        </member>
        <member name="P:NewLife.IO.CsvDb`1.Comparer">
            <summary>实体比较器</summary>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.#ctor">
            <summary>实例化Csv文件数据库</summary>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary>实例化Csv文件数据库</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Write(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>强行写入数据</summary>
            <param name="models">要写入的数据</param>
            <param name="append">是否附加在尾部</param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Add(`0)">
            <summary>尾部插入数据，性能极好</summary>
            <param name="model"></param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>尾部插入数据，性能极好</summary>
            <param name="models"></param>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Remove(`0)">
            <summary>删除数据，性能很差，全部读取剔除后保存</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>删除数据，性能很差，全部读取剔除后保存</summary>
            <param name="models"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Remove(System.Func{`0,System.Boolean})">
            <summary>删除满足条件的数据，性能很差，全部读取剔除后保存</summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Clear">
            <summary>清空数据。只写头部</summary>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Update(`0)">
            <summary>更新指定数据行，性能很差，全部读取替换后保存</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Set(`0)">
            <summary>设置（添加或更新）指定数据行，性能很差，全部读取替换后保存</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Find(`0)">
            <summary>查找指定数据行</summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.Find(System.Func{`0,System.Boolean})">
            <summary>获取满足条件的第一行数据</summary>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.FindAll">
            <summary>获取所有数据行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.FindAll(System.Func{`0,System.Boolean},System.Int32)">
            <summary>获取满足条件的数据行，性能好，顺序查找</summary>
            <param name="predicate"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvDb`1.FindCount">
            <summary>获取数据行数，性能极好，文件行数（除头部）</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.CsvFile">
            <summary>Csv文件</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/csv_file
            支持整体读写以及增量式读写，目标是读写超大Csv文件
            </remarks>
        </member>
        <member name="P:NewLife.IO.CsvFile.Encoding">
            <summary>文件编码</summary>
        </member>
        <member name="P:NewLife.IO.CsvFile.Separator">
            <summary>分隔符。默认逗号</summary>
        </member>
        <member name="M:NewLife.IO.CsvFile.#ctor(System.IO.Stream)">
            <summary>数据流实例化</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>数据流实例化</summary>
            <param name="stream"></param>
            <param name="leaveOpen">保留打开</param>
        </member>
        <member name="M:NewLife.IO.CsvFile.#ctor(System.String,System.Boolean)">
            <summary>Csv文件实例化</summary>
            <param name="file"></param>
            <param name="write"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.IO.CsvFile.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.ReadLine">
            <summary>读取一行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvFile.ReadAll">
            <summary>读取所有行</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteAll(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Object}})">
            <summary>写入全部</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteLine(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>写入一行</summary>
            <param name="line"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.WriteLineAsync(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>异步写入一行</summary>
            <param name="line"></param>
        </member>
        <member name="M:NewLife.IO.CsvFile.BuildLine(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>构建一行</summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.EncodingHelper">
            <summary>编码助手</summary>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.Detect(System.String)">
            <summary>检测文件编码</summary>
            <param name="filename">文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectEncoding(System.IO.FileInfo)">
            <summary>检测文件编码</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.Detect(System.IO.Stream,System.Int64)">
            <summary>检测数据流编码</summary>
            <param name="stream">数据流</param>
            <param name="sampleSize">BOM检测失败时用于启发式探索的数据大小</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.Detect(System.Byte[])">
            <summary>检测字节数组编码</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectBOM(System.Byte[])">
            <summary>检测BOM字节序</summary>
            <param name="boms"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectASCII(System.Byte[])">
            <summary>检测是否ASCII</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectUnicode(System.Byte[])">
            <summary>启发式探测Unicode编码</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.IsCommonASCII(System.Byte)">
            <summary>是否可见ASCII</summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectSuspiciousUTF8SequenceLength(System.Byte[],System.Int64)">
            <summary>检测可能的UTF8序列长度</summary>
            <param name="buf"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.ExcelReader">
            <summary>轻量级Excel读取器，仅用于导入数据</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/excel_reader
            仅支持xlsx格式，本质上是压缩包，内部xml。
            可根据xml格式扩展读取自己想要的内容。
            </remarks>
        </member>
        <member name="P:NewLife.IO.ExcelReader.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.IO.ExcelReader.Sheets">
            <summary>工作表</summary>
        </member>
        <member name="M:NewLife.IO.ExcelReader.#ctor(System.String)">
            <summary>实例化读取器</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.IO.ExcelReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>实例化读取器</summary>
            <param name="stream"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.IO.ExcelReader.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.IO.ExcelReader.ReadRows(System.String)">
            <summary>逐行读取数据，第一行很可能是表头</summary>
            <param name="sheet">工作表名。一般是sheet1/sheet2/sheet3，默认空，使用第一个数据表</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.FileSource">
            <summary>文件资源</summary>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFile(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>释放文件</summary>
            <param name="asm"></param>
            <param name="fileName"></param>
            <param name="destFile"></param>
            <param name="overWrite"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFolder(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>释放文件夹</summary>
            <param name="asm"></param>
            <param name="prefix"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFolder(System.Reflection.Assembly,System.String,System.String,System.Boolean,System.Func{System.String,System.String})">
            <summary>释放文件夹</summary>
            <param name="asm"></param>
            <param name="prefix"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
            <param name="filenameResolver"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.GetFileResource(System.Reflection.Assembly,System.String)">
            <summary>获取文件资源</summary>
            <param name="asm"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IOHelper">
            <summary>IO工具类</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/io_helper
            </remarks>
        </member>
        <member name="M:NewLife.IOHelper.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.Decompress(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <returns>Deflate算法，如果是ZLIB格式，则前面多两个字节，解压缩之前去掉，RocketMQ中有用到</returns>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.Compress(System.Byte[])">
            <summary>压缩字节数组</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Decompress(System.Byte[])">
            <summary>解压缩字节数组</summary>
            <returns>Deflate算法，如果是ZLIB格式，则前面多两个字节，解压缩之前去掉，RocketMQ中有用到</returns>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.CompressGZip(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.DecompressGZip(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.IO.Stream,System.Byte[])">
            <summary>把一个字节数组写入到一个数据流</summary>
            <param name="des">目的数据流</param>
            <param name="src">源数据流</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.WriteArray(System.IO.Stream,System.Byte[])">
            <summary>写入字节数组，先写入压缩整数表示的长度</summary>
            <param name="des"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadArray(System.IO.Stream)">
            <summary>读取字节数组，先读取压缩整数表示的长度</summary>
            <param name="des"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.WriteDateTime(System.IO.Stream,System.DateTime)">
            <summary>写入Unix格式时间，1970年以来秒数，绝对时间，非UTC</summary>
            <param name="stream"></param>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadDateTime(System.IO.Stream)">
            <summary>读取Unix格式时间，1970年以来秒数，绝对时间，非UTC</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>复制数组</summary>
            <param name="src">源数组</param>
            <param name="offset">起始位置</param>
            <param name="count">复制字节数</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>向字节数组写入一片数据</summary>
            <param name="dst">目标数组</param>
            <param name="dstOffset">目标偏移</param>
            <param name="src">源数组</param>
            <param name="srcOffset">源数组偏移</param>
            <param name="count">数量</param>
            <returns>返回实际写入的字节个数</returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadBytes(System.IO.Stream,System.Int64)">
            <summary>数据流转为字节数组</summary>
            <remarks>
            针对MemoryStream进行优化。内存流的Read实现是一个个字节复制，而ToArray是调用内部内存复制方法
            如果要读完数据，又不支持定位，则采用内存流搬运
            如果指定长度超过数据流长度，就让其报错，因为那是调用者所期望的值
            </remarks>
            <param name="stream">数据流</param>
            <param name="length">长度，0表示读到结束</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToStr(System.IO.Stream,System.Text.Encoding)">
            <summary>流转换为字符串</summary>
            <param name="stream">目标流</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToStr(System.Byte[],System.Text.Encoding,System.Int32,System.Int32)">
            <summary>字节数组转换为字符串</summary>
            <param name="buf">字节数组</param>
            <param name="encoding">编码格式</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="count">字节数组中的查找长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUInt16(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUInt32(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号32位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUInt64(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号64位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.UInt16,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.UInt32,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号32位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.Write(System.Byte[],System.UInt64,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号64位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.UInt16,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Int16,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.UInt32,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Int32,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.UInt64,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.GetBytes(System.Int64,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadEncodedInt(System.IO.Stream)">
            <summary>以压缩格式读取32位整数</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ReadEncodedInt64(System.IO.Stream)">
            <summary>以压缩格式读取32位整数</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.TryReadEncodedInt(System.IO.Stream,System.UInt32@)">
            <summary>尝试读取压缩编码整数</summary>
            <param name="stream"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.WriteEncodedInt(System.IO.Stream,System.Int64)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="stream">数据流</param>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.IOHelper.GetEncodedInt(System.Int64)">
            <summary>获取压缩编码整数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串</summary>
            <param name="data">字节数组</param>
            <param name="offset">偏移</param>
            <param name="count">数量。超过实际数量时，使用实际数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.Byte[],System.String,System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串，带有分隔符和分组功能</summary>
            <param name="data">字节数组</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToHex(System.String,System.Int32,System.Int32)">
            <summary>解密</summary>
            <param name="data">Hex编码的字符串</param>
            <param name="startIndex">起始位置</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToBase64(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>字节数组转为Base64编码</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="lineBreak">是否换行显示</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToUrlBase64(System.Byte[],System.Int32,System.Int32)">
            <summary>字节数组转为Url改进型Base64编码</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.ToBase64(System.String)">
            <summary>Base64字符串转为字节数组</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IOHelper.IndexOf(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>Boyer Moore 字符串搜索算法，比KMP更快，常用于IDE工具的查找</summary>
            <param name="source"></param>
            <param name="pattern"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Json.JsonConfig`1">
            <summary>Json配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Json.JsonConfigFileAttribute"/>特性指定配置文件路径以及自动更新时间。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            
            考虑到自动刷新，不提供LoadFile和SaveFile等方法，可通过扩展方法ToXmlFileEntity和ToXmlFile实现。
            
            用户也可以通过配置实体类的静态构造函数修改基类的<see cref="P:NewLife.Json.JsonConfig`1._.ConfigFile"/>和<see cref="P:NewLife.Json.JsonConfig`1._.ReloadTime"/>来动态配置加载信息。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="T:NewLife.Json.JsonConfig`1._">
            <summary>一些设置。派生类可以在自己的静态构造函数中指定</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.ConfigFile">
            <summary>配置文件路径</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.SaveNew">
            <summary>没有配置文件时是否保存新配置。默认true</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.ConfigFile">
            <summary>配置文件</summary>
        </member>
        <member name="F:NewLife.Json.JsonConfig`1.lastWrite">
            <summary>最后写入时间</summary>
        </member>
        <member name="F:NewLife.Json.JsonConfig`1.expire">
            <summary>过期时间。如果在这个时间之后再次访问，将检查文件修改时间</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.IsUpdated">
            <summary>是否已更新。通过文件写入时间判断</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.SetExpire">
            <summary>设置过期重新加载配置的时间</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Load(System.String)">
            <summary>加载指定配置文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Save(System.String)">
            <summary>保存到配置文件中去</summary>
            <param name="filename"></param>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.OnNew">
            <summary>新创建配置文件时执行</summary>
        </member>
        <member name="T:NewLife.Json.JsonConfigFileAttribute">
            <summary>Json配置文件特性</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfigFileAttribute.FileName">
            <summary>配置文件名</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfigFileAttribute.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfigFileAttribute.#ctor(System.String)">
            <summary>指定配置文件名</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Json.JsonConfigFileAttribute.#ctor(System.String,System.Int32)">
            <summary>指定配置文件名和重新加载时间（毫秒）</summary>
            <param name="fileName"></param>
            <param name="reloadTime"></param>
        </member>
        <member name="T:NewLife.Log.ActionLog">
            <summary>依托于动作的日志类</summary>
        </member>
        <member name="P:NewLife.Log.ActionLog.Method">
            <summary>方法</summary>
        </member>
        <member name="M:NewLife.Log.ActionLog.#ctor(System.Action{System.String,System.Object[]})">
            <summary>使用指定方法否则动作日志</summary>
            <param name="action"></param>
        </member>
        <member name="M:NewLife.Log.ActionLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.ActionLog.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.CodeTimer">
            <summary>代码性能计时器</summary>
            <remarks>参考了老赵（http://www.cnblogs.com/jeffreyzhao/archive/2009/03/10/codetimer.html）和eaglet（http://www.cnblogs.com/eaglet/archive/2009/03/10/1407791.html）两位的作品</remarks>
            <remarks>为了保证性能比较的公平性，采用了多种指标，并使用计时器重写等手段来避免各种不必要的损耗</remarks>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32,System.Action{System.Int32},System.Boolean)">
            <summary>计时</summary>
            <param name="times">次数</param>
            <param name="action">需要计时的委托</param>
            <param name="needTimeOne">是否需要预热</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeLine(System.String,System.Int32,System.Action{System.Int32},System.Boolean)">
            <summary>计时，并用控制台输出行</summary>
            <param name="title">标题</param>
            <param name="times">次数</param>
            <param name="action">需要计时的委托</param>
            <param name="needTimeOne">是否需要预热</param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ShowHeader(System.String)">
            <summary>显示头部</summary>
            <param name="title"></param>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Action">
            <summary>迭代方法，如不指定，则使用Time(int index)</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ShowProgress">
            <summary>是否显示控制台进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Index">
            <summary>进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.CpuCycles">
            <summary>CPU周期</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ThreadTime">
            <summary>线程时间，单位是ms</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Gen">
            <summary>GC代数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Elapsed">
            <summary>执行时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.#ctor">
            <summary>实例化一个代码计时器</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time">
            <summary>计时核心方法，处理进程和线程优先级</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeTrue">
            <summary>真正的计时</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeOne">
            <summary>执行一次迭代，预热所有方法</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Init">
            <summary>迭代前执行，计算时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32)">
            <summary>每一次迭代，计算时间</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Finish">
            <summary>迭代后执行，计算时间</summary>
        </member>
        <member name="F:NewLife.Log.CodeTimer.msBase">
            <summary>基准时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ToString">
            <summary>已重载。输出依次分别是：执行时间、CPU线程时间、时钟周期、GC代数</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.CompositeLog">
            <summary>复合日志提供者，多种方式输出</summary>
        </member>
        <member name="P:NewLife.Log.CompositeLog.Logs">
            <summary>日志提供者集合</summary>
        </member>
        <member name="P:NewLife.Log.CompositeLog.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info，打开NewLife.Debug时默认为最低的Debug</summary>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor(NewLife.Log.ILog)">
            <summary>实例化</summary>
            <param name="log"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor(NewLife.Log.ILog,NewLife.Log.ILog)">
            <summary>实例化</summary>
            <param name="log1"></param>
            <param name="log2"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Add(NewLife.Log.ILog)">
            <summary>添加一个日志提供者</summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Remove(NewLife.Log.ILog)">
            <summary>删除日志提供者</summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Get``1">
            <summary>从复合日志提供者中提取指定类型的日志提供者</summary>
            <typeparam name="TLog"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ConsoleLog">
            <summary>控制台输出日志</summary>
        </member>
        <member name="P:NewLife.Log.ConsoleLog.UseColor">
            <summary>是否使用多种颜色，默认使用</summary>
        </member>
        <member name="M:NewLife.Log.ConsoleLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.ConsoleLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ICounter">
            <summary>性能计数器接口</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Speed">
            <summary>速度</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Cost">
            <summary>平均耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.ICounter.Increment(System.Int64,System.Int64)">
            <summary>增加</summary>
            <param name="value">增加的数量</param>
            <param name="usCost">耗时，单位us</param>
        </member>
        <member name="T:NewLife.Log.CounterHelper">
            <summary>计数器助手</summary>
        </member>
        <member name="M:NewLife.Log.CounterHelper.StartCount(NewLife.Log.ICounter)">
            <summary>开始计时</summary>
            <param name="counter"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CounterHelper.StopCount(NewLife.Log.ICounter,System.Nullable{System.Int64})">
            <summary>结束计时</summary>
            <param name="counter"></param>
            <param name="startTicks"></param>
        </member>
        <member name="T:NewLife.Log.ILog">
            <summary>日志接口</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/log
            </remarks>
        </member>
        <member name="M:NewLife.Log.ILog.Write(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level">日志级别</param>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Debug(System.String,System.Object[])">
            <summary>调试日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Info(System.String,System.Object[])">
            <summary>信息日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Warn(System.String,System.Object[])">
            <summary>警告日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Error(System.String,System.Object[])">
            <summary>错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Fatal(System.String,System.Object[])">
            <summary>严重错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Log(System.String,System.Object[])">
            <summary>
            纯输出
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="P:NewLife.Log.ILog.Enable">
            <summary>是否启用日志</summary>
        </member>
        <member name="P:NewLife.Log.ILog.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info</summary>
        </member>
        <member name="T:NewLife.Log.ISpan">
            <summary>性能跟踪片段。轻量级APM</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Id">
            <summary>唯一标识。随线程上下文、Http、Rpc传递，作为内部片段的父级</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.ParentId">
            <summary>父级片段标识</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.TraceId">
            <summary>跟踪标识。可用于关联多个片段，建立依赖关系，随线程上下文、Http、Rpc传递</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Tag">
            <summary>数据标签。记录一些附加数据</summary>
        </member>
        <member name="P:NewLife.Log.ISpan.Error">
            <summary>错误信息</summary>
        </member>
        <member name="M:NewLife.Log.ISpan.SetError(System.Exception,System.Object)">
            <summary>设置错误信息</summary>
            <param name="ex">异常</param>
            <param name="tag">标签</param>
        </member>
        <member name="T:NewLife.Log.DefaultSpan">
            <summary>性能跟踪片段。轻量级APM</summary>
            <remarks>
            spanId/traceId采用W3C标准，https://www.w3.org/TR/trace-context/
            </remarks>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Builder">
            <summary>构建器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Id">
            <summary>唯一标识。随线程上下文、Http、Rpc传递，作为内部片段的父级</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.ParentId">
            <summary>父级片段标识</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.TraceId">
            <summary>跟踪标识。可用于关联多个片段，建立依赖关系，随线程上下文、Http、Rpc传递</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Tag">
            <summary>数据标签。记录一些附加数据</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.TraceFlag">
            <summary>跟踪标识。强制采样，确保链路采样完整，上下文传递</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Error">
            <summary>错误信息</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpan.Current">
            <summary>当前线程正在使用的上下文</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.#ctor(NewLife.Log.ISpanBuilder)">
            <summary>实例化</summary>
            <param name="builder"></param>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.Start">
            <summary>设置跟踪标识</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.CreateId">
            <summary>创建分片编号</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.CreateTraceId">
            <summary>创建跟踪编号</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.Finish">
            <summary>完成跟踪</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.SetError(System.Exception,System.Object)">
            <summary>设置错误信息</summary>
            <param name="ex">异常</param>
            <param name="tag">标签</param>
        </member>
        <member name="M:NewLife.Log.DefaultSpan.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.SpanExtension">
            <summary>跟踪片段扩展</summary>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Net.Http.HttpRequestMessage)">
            <summary>把片段信息附加到http请求头上</summary>
            <param name="span">片段</param>
            <param name="request">http请求</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Net.WebRequest)">
            <summary>把片段信息附加到http请求头上</summary>
            <param name="span">片段</param>
            <param name="request">http请求</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Attach(NewLife.Log.ISpan,System.Object)">
            <summary>把片段信息附加到api请求头上</summary>
            <param name="span">片段</param>
            <param name="args">api请求参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach(NewLife.Log.ISpan,System.Collections.Specialized.NameValueCollection)">
            <summary>从http请求头释放片段信息</summary>
            <param name="span">片段</param>
            <param name="headers">http请求头</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach(NewLife.Log.ISpan,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>从api请求释放片段信息</summary>
            <param name="span">片段</param>
            <param name="parameters">参数</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach``1(NewLife.Log.ISpan,System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>从api请求释放片段信息</summary>
            <param name="span">片段</param>
            <param name="parameters">参数</param>
        </member>
        <member name="M:NewLife.Log.SpanExtension.Detach(NewLife.Log.ISpan,System.String)">
            <summary>从数据流traceId中释放片段信息</summary>
            <param name="span">片段</param>
            <param name="traceId">W3C标准TraceId</param>
        </member>
        <member name="T:NewLife.Log.ISpanBuilder">
            <summary>跟踪片段构建器</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Tracer">
            <summary>跟踪器</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Name">
            <summary>操作名</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Total">
            <summary>采样总数</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Errors">
            <summary>错误次数</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Cost">
            <summary>总耗时。所有请求耗时累加，单位ms</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.MaxCost">
            <summary>最大耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.MinCost">
            <summary>最小耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.Samples">
            <summary>正常采样</summary>
        </member>
        <member name="P:NewLife.Log.ISpanBuilder.ErrorSamples">
            <summary>异常采样</summary>
        </member>
        <member name="M:NewLife.Log.ISpanBuilder.Start">
            <summary>开始一个Span</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ISpanBuilder.Finish(NewLife.Log.ISpan)">
            <summary>完成Span</summary>
            <param name="span"></param>
        </member>
        <member name="T:NewLife.Log.DefaultSpanBuilder">
            <summary>跟踪片段构建器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Tracer">
            <summary>跟踪器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Name">
            <summary>操作名</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.StartTime">
            <summary>开始时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.EndTime">
            <summary>结束时间。Unix毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Total">
            <summary>采样总数</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Errors">
            <summary>错误次数</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Cost">
            <summary>总耗时。所有请求耗时累加，单位ms</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.MaxCost">
            <summary>最大耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.MinCost">
            <summary>最小耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.Samples">
            <summary>正常采样</summary>
        </member>
        <member name="P:NewLife.Log.DefaultSpanBuilder.ErrorSamples">
            <summary>异常采样</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.#ctor(NewLife.Log.ITracer,System.String)">
            <summary>实例化</summary>
            <param name="tracer"></param>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.Start">
            <summary>开始一个Span</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.Finish(NewLife.Log.ISpan)">
            <summary>完成Span</summary>
            <param name="span"></param>
        </member>
        <member name="M:NewLife.Log.DefaultSpanBuilder.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ITracer">
            <summary>性能跟踪器。轻量级APM</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.Period">
            <summary>采样周期</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.MaxSamples">
            <summary>最大正常采样数。采样周期内，最多只记录指定数量的正常事件，用于绘制依赖关系</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.MaxErrors">
            <summary>最大异常采样数。采样周期内，最多只记录指定数量的异常事件，默认10</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.Timeout">
            <summary>超时时间。超过该时间时强制采样，毫秒</summary>
        </member>
        <member name="P:NewLife.Log.ITracer.AttachParameter">
            <summary>向http/rpc请求注入TraceId的参数名，为空表示不注入，默认W3C标准的traceparent</summary>
        </member>
        <member name="M:NewLife.Log.ITracer.BuildSpan(System.String)">
            <summary>建立Span构建器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ITracer.NewSpan(System.String)">
            <summary>开始一个Span</summary>
            <param name="name">操作名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ITracer.NewSpan(System.String,System.Object)">
            <summary>开始一个Span，指定数据标签</summary>
            <param name="name">操作名</param>
            <param name="tag">数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.ITracer.TakeAll">
            <summary>截断所有Span构建器数据，重置集合</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.DefaultTracer">
            <summary>性能跟踪器。轻量级APM</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Instance">
            <summary>全局实例。可影响X组件各模块的跟踪器</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Period">
            <summary>采样周期。默认15s</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.MaxSamples">
            <summary>最大正常采样数。采样周期内，最多只记录指定数量的正常事件，用于绘制依赖关系</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.MaxErrors">
            <summary>最大异常采样数。采样周期内，最多只记录指定数量的异常事件，默认10</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Timeout">
            <summary>超时时间。超过该时间时强制采样，默认15000毫秒</summary>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.AttachParameter">
            <summary>向http/rpc请求注入TraceId的参数名，为空表示不注入，默认是W3C标准的traceparent</summary>
        </member>
        <member name="F:NewLife.Log.DefaultTracer._builders">
            <summary>Span构建器集合</summary>
        </member>
        <member name="F:NewLife.Log.DefaultTracer._timer">
            <summary>采样定时器</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.ProcessSpans(NewLife.Log.ISpanBuilder[])">
            <summary>处理Span集合。默认输出日志，可重定义输出控制台</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.BuildSpan(System.String)">
            <summary>建立Span构建器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.OnBuildSpan(System.String)">
            <summary>实例化Span构建器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.NewSpan(System.String)">
            <summary>开始一个Span</summary>
            <param name="name">操作名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.NewSpan(System.String,System.Object)">
            <summary>开始一个Span，指定数据标签</summary>
            <param name="name">操作名</param>
            <param name="tag">数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.TakeAll">
            <summary>截断所有Span构建器数据，重置集合</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.DefaultTracer.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Log.DefaultTracer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.TracerExtension">
            <summary>跟踪扩展</summary>
        </member>
        <member name="M:NewLife.Log.TracerExtension.CreateHttpClient(NewLife.Log.ITracer,System.Net.Http.HttpMessageHandler)">
            <summary>创建受跟踪的HttpClient</summary>
            <param name="tracer">跟踪器</param>
            <param name="handler">http处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewSpan(NewLife.Log.ITracer,System.Net.Http.HttpRequestMessage)">
            <summary>为Http请求创建Span</summary>
            <param name="tracer">跟踪器</param>
            <param name="request">Http请求</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TracerExtension.NewSpan(NewLife.Log.ITracer,System.Net.WebRequest)">
            <summary>为Http请求创建Span</summary>
            <param name="tracer">跟踪器</param>
            <param name="request">Http请求</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.LevelLog">
            <summary>等级日志提供者，不同等级分不同日志输出</summary>
        </member>
        <member name="M:NewLife.Log.LevelLog.#ctor(System.String,System.String)">
            <summary>通过指定路径和文件格式来实例化等级日志，每个等级使用自己的日志输出</summary>
            <param name="logPath"></param>
            <param name="fileFormat"></param>
        </member>
        <member name="M:NewLife.Log.LevelLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.LogEventListener">
            <summary>日志事件监听器。用于监听内置事件并写入日志</summary>
        </member>
        <member name="M:NewLife.Log.LogEventListener.#ctor(System.String[])">
            <summary>实例化</summary>
            <param name="sources"></param>
        </member>
        <member name="M:NewLife.Log.LogEventListener.OnEventSourceCreated(System.Diagnostics.Tracing.EventSource)">
            <summary>创建事件源。此时决定要不要跟踪</summary>
            <param name="eventSource"></param>
        </member>
        <member name="M:NewLife.Log.LogEventListener.OnEventWritten(System.Diagnostics.Tracing.EventWrittenEventArgs)">
            <summary>写入事件。监听器拦截，并写入日志</summary>
            <param name="eventData"></param>
        </member>
        <member name="T:NewLife.Log.Logger">
            <summary>日志基类。提供日志的基本实现</summary>
        </member>
        <member name="M:NewLife.Log.Logger.Debug(System.String,System.Object[])">
            <summary>调试日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Info(System.String,System.Object[])">
            <summary>信息日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Warn(System.String,System.Object[])">
            <summary>警告日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Error(System.String,System.Object[])">
            <summary>错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Fatal(System.String,System.Object[])">
            <summary>严重错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Write(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.Logger.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.Logger.Format(System.String,System.Object[])">
            <summary>格式化参数，特殊处理异常和时间</summary>
            <param name="format"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.Logger.Enable">
            <summary>是否启用日志。默认true</summary>
        </member>
        <member name="P:NewLife.Log.Logger.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info</summary>
        </member>
        <member name="P:NewLife.Log.Logger.Null">
            <summary>空日志实现</summary>
        </member>
        <member name="M:NewLife.Log.Logger.GetHead">
            <summary>输出日志头，包含所有环境信息</summary>
        </member>
        <member name="T:NewLife.Log.LogLevel">
            <summary>日志等级</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.All">
            <summary>打开所有日志记录</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Debug">
            <summary>最低调试。细粒度信息事件对调试应用程序非常有帮助</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Info">
            <summary>普通消息。在粗粒度级别上突出强调应用程序的运行过程</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Warn">
            <summary>警告</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Error">
            <summary>错误</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Fatal">
            <summary>严重错误</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Off">
            <summary>关闭所有日志记录</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Log">
            <summary>
            绝对输出
            </summary>
        </member>
        <member name="T:NewLife.Log.NetworkLog">
            <summary>网络日志</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.AppId">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.ClientId">
            <summary>客户端标识</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.#ctor">
            <summary>实例化网络日志。默认广播到514端口</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.#ctor(System.String)">
            <summary>指定日志服务器地址来实例化网络日志</summary>
            <param name="server"></param>
        </member>
        <member name="M:NewLife.Log.NetworkLog.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.PerfCounter">
            <summary>性能计数器。次数、TPS、平均耗时</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Enable">
            <summary>是否启用。默认true</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Times">
            <summary>次数</summary>
        </member>
        <member name="F:NewLife.Log.PerfCounter._TotalCost">
            <summary>耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.PerfCounter.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.PerfCounter.Increment(System.Int64,System.Int64)">
            <summary>增加</summary>
            <param name="value">增加的数量</param>
            <param name="usCost">耗时，单位us</param>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Interval">
            <summary>采样间隔，默认1000毫秒</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Duration">
            <summary>持续采样时间，默认60秒</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Speed">
            <summary>当前速度</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.MaxSpeed">
            <summary>最大速度</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Cost">
            <summary>最后一个采样周期的平均耗时，单位us</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.MaxCost">
            <summary>持续采样时间内的最大平均耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.PerfCounter.DoWork(System.Object)">
            <summary>定期采样，保存最近60组到数组队列里面</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Log.PerfCounter.ToString">
            <summary>已重载。输出统计信息</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.TextFileLog">
            <summary>文本文件日志类。提供向文本文件写日志的能力</summary>
            <remarks>
            两大用法：
            1，Create(path, fileFormat) 指定日志目录和文件名格式
            2，CreateFile(path) 指定文件，一直往里面写
            
            2015-06-01 为了继承TextFileLog，增加了无参构造函数，修改了异步写日志方法为虚方法，可以进行重载
            </remarks>
        </member>
        <member name="P:NewLife.Log.TextFileLog.LogPath">
            <summary>日志目录</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.FileFormat">
            <summary>日志文件格式。默认{0:yyyy_MM_dd}.log</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.MaxBytes">
            <summary>日志文件上限。超过上限后拆分新日志文件，默认10MB，0表示不限制大小</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.Backups">
            <summary>日志文件备份。超过备份数后，最旧的文件将被删除，默认100，0表示不限制个数</summary>
        </member>
        <member name="F:NewLife.Log.TextFileLog._isFirst">
            <summary>是否当前进程的第一次写日志</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.#ctor">
            <summary>该构造函数没有作用，为了继承而设置</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Create(System.String,System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path">日志目录或日志文件路径</param>
            <param name="fileFormat"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.CreateFile(System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path">日志目录或日志文件路径</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.InitLog">
            <summary>初始化日志记录文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.GetLogFile">
            <summary>获取日志文件路径</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteFile">
            <summary>写文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.DoWriteAndClose(System.Object)">
            <summary>关闭文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteAndClose(System.DateTime)">
            <summary>写入队列日志并关闭文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.TimeCost">
            <summary>统计代码的时间消耗</summary>
        </member>
        <member name="P:NewLife.Log.TimeCost.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Log.TimeCost.Max">
            <summary>最大时间。毫秒</summary>
        </member>
        <member name="P:NewLife.Log.TimeCost.Log">
            <summary>日志输出</summary>
        </member>
        <member name="M:NewLife.Log.TimeCost.#ctor(System.String,System.Int32)">
            <summary>指定最大执行时间来构造一个代码时间统计</summary>
            <param name="name"></param>
            <param name="msMax"></param>
        </member>
        <member name="M:NewLife.Log.TimeCost.Dispose(System.Boolean)">
            <summary>析构</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.TimeCost.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Log.TimeCost.Stop">
            <summary>停止</summary>
        </member>
        <member name="T:NewLife.Log.TraceStream">
            <summary>跟踪流。包装一个基础数据流，主要用于重写Read/Write等行为，跟踪程序操作数据流的过程</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.BaseStream">
            <summary>基础流</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.TraceMembers">
            <summary>跟踪的成员</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.IsLittleEndian">
            <summary>是否小端字节序。x86系列则采用Little-Endian方式存储数据；网络协议都是Big-Endian；</summary>
            <remarks>
            网络协议都是Big-Endian；
            Java编译的都是Big-Endian；
            Motorola的PowerPC是Big-Endian；
            x86系列则采用Little-Endian方式存储数据；
            ARM同时支持 big和little，实际应用中通常使用Little-Endian。
            </remarks>
        </member>
        <member name="P:NewLife.Log.TraceStream.ShowPositionStep">
            <summary>显示位置的步长，位移超过此长度后输出位置。默认16，设为0不输出位置</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>写入</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Log.TraceStream.WriteByte(System.Byte)">
            <summary>写入一个字节</summary>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>读取</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.ReadByte">
            <summary>读取一个字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>异步开始读</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>异步开始写</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.EndRead(System.IAsyncResult)">
            <summary>异步读结束</summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.EndWrite(System.IAsyncResult)">
            <summary>异步写结束</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>设置流位置</summary>
            <param name="offset">偏移</param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.Close">
            <summary>关闭数据流</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Flush">
            <summary>刷新缓冲区</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.SetLength(System.Int64)">
            <summary>设置长度</summary>
            <param name="value">数值</param>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanRead">
            <summary>可读</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanSeek">
            <summary>可搜索</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanTimeout">
            <summary>可超时</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanWrite">
            <summary>可写</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.ReadTimeout">
            <summary>可读</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.WriteTimeout">
            <summary>读写超时</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Position">
            <summary>位置</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor">
            <summary>实例化跟踪流</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor(System.IO.Stream)">
            <summary>实例化跟踪流</summary>
            <param name="stream"></param>
        </member>
        <member name="E:NewLife.Log.TraceStream.OnAction">
            <summary>操作时触发</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.UseConsole">
            <summary>是否使用控制台</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Encoding">
            <summary>编码</summary>
        </member>
        <member name="T:NewLife.Log.WriteLogEventArgs">
            <summary>写日志事件参数</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Level">
            <summary>日志等级</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Message">
            <summary>日志信息</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadID">
            <summary>线程编号</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsPool">
            <summary>是否线程池线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsWeb">
            <summary>是否Web线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadName">
            <summary>线程名</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.TaskID">
            <summary>任务编号</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor">
            <summary>实例化一个日志事件参数</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Current">
            <summary>线程专有实例。线程静态，每个线程只用一个，避免GC浪费</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(NewLife.Log.LogLevel)">
            <summary>初始化为新日志</summary>
            <param name="level">日志等级</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(System.String,System.Exception)">
            <summary>初始化为新日志</summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.CurrentThreadName">
            <summary>设置当前线程输出日志时的线程名</summary>
        </member>
        <member name="T:NewLife.Log.XTrace">
            <summary>日志类，包含跟踪调试功能</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/log
            
            该静态类包括写日志、写调用栈和Dump进程内存等调试功能。
            
            默认写日志到文本文件，可通过修改<see cref="P:NewLife.Log.XTrace.Log"/>属性来增加日志输出方式。
            对于控制台工程，可以直接通过UseConsole方法，把日志输出重定向为控制台输出，并且可以为不同线程使用不同颜色。
            </remarks>
        </member>
        <member name="F:NewLife.Log.XTrace._Log">
            <summary>文本文件日志</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.Log">
            <summary>日志提供者，默认使用文本文件日志</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteException(System.Exception)">
            <summary>输出异常日志</summary>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.InitLog">
            <summary>
            2012.11.05 修正初次调用的时候，由于同步BUG，导致Log为空的问题。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.UseConsole(System.Boolean,System.Boolean)">
            <summary>使用控制台输出日志，只能调用一次</summary>
            <param name="useColor">是否使用颜色，默认使用</param>
            <param name="useFileLog">是否同时使用文件日志，默认使用</param>
        </member>
        <member name="P:NewLife.Log.XTrace.Debug">
            <summary>是否调试。</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.LogPath">
            <summary>文本日志目录</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteVersion">
            <summary>输出核心库和启动程序的版本号</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteVersion(System.Reflection.Assembly)">
            <summary>输出程序集版本</summary>
            <param name="asm"></param>
        </member>
        <member name="T:NewLife.Messaging.DefaultMessage">
            <summary>标准消息SRMP</summary>
            <remarks>
            标准协议最大优势是短小，头部定长，没有序列化成本，适用于专业级RPC以及嵌入式通信。
            缺点是可读性差，不能适用于字符串通信场景。
            标准网络封包协议：1 Flag + 1 Sequence + 2 Length + N Payload
            1个字节标识位，标识请求、响应、错误、加密、压缩等；
            1个字节序列号，用于请求响应包配对；
            2个字节数据长度N，小端，指示后续负载数据长度（不包含头部4个字节），解决粘包问题；
            N个字节负载数据，数据内容完全由业务决定，最大长度65535=64k。
            如：
            Open => OK
            01-01-04-00-"Open" => 81-01-02-00-"OK"
            
            
            字符串协议最大优势是可读性极强，适用于物联网模组的AT指令通信。
            缺点是字符串序列化成本很高，且指令比较长。
            字符串封包协议：Length,Sequence[,Flag]:Payload
            字符串表示的负载长度，逗号之后是字符串表示的序列号，然后分号隔开字符串负载。
            负载长度是字节长度；
            标记位根据需要可选；
            如：
            Open => 执行成功
            4,1,1:Open => 12,1,129:执行成功
            简化版：
            4,1:Open => 12,1:执行成功
            
            </remarks>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Flag">
            <summary>标记位</summary>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Sequence">
            <summary>序列号，匹配请求和响应</summary>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.Decode(System.String,System.Text.Encoding)">
            <summary>从字符串中读取字符串消息</summary>
            <param name="encoding">编码</param>
            <param name="value">字符串</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.Decode(NewLife.Data.Packet)">
            <summary>从数据包中读取字符串消息</summary>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.Encode(System.Text.Encoding,System.Boolean)">
            <summary>把消息转为字符串封包</summary>
            <param name="encoding">编码</param>
            <param name="includeFlag">是否包含标识位</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.GetLength(NewLife.Data.Packet)">
            <summary>获取数据包长度</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.ToString">
            <summary>消息摘要</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.IMessage">
            <summary>消息命令</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Error">
            <summary>是否有错</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.OneWay">
            <summary>单向请求</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="M:NewLife.Messaging.IMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.IMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.Message">
            <summary>消息命令基类</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Error">
            <summary>是否有错</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.OneWay">
            <summary>单向请求</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="M:NewLife.Messaging.Message.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.Message.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.MessageEventArgs">
            <summary>收到消息时的事件参数</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Packet">
            <summary>数据包</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Message">
            <summary>消息</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.UserState">
            <summary>用户数据。比如远程地址等</summary>
        </member>
        <member name="T:NewLife.Messaging.PacketCodec">
            <summary>数据包编码器</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Stream">
            <summary>缓存流</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.GetLength">
            <summary>获取长度的委托</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Offset">
            <summary>长度的偏移量，截取数据包时加上，否则将会漏掉长度之间的数据包，如MQTT</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Last">
            <summary>最后一次解包成功，而不是最后一次接收</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Expire">
            <summary>缓存有效期。超过该时间后仍未匹配数据包的缓存数据将被抛弃</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.MaxCache">
            <summary>最大缓存待处理数据。默认0无限制</summary>
        </member>
        <member name="P:NewLife.Messaging.PacketCodec.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Messaging.PacketCodec.Parse(NewLife.Data.Packet)">
            <summary>分析数据流，得到一帧数据</summary>
            <param name="pk">待分析数据包</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.PacketCodec.CheckCache">
            <summary>检查缓存</summary>
        </member>
        <member name="T:NewLife.Model.IActor">
            <summary>无锁并行编程模型</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/actor
            
            独立线程轮询消息队列，简单设计避免影响默认线程池。
            适用于任务颗粒较大的场合，例如IO操作。
            </remarks>
        </member>
        <member name="M:NewLife.Model.IActor.Tell(System.Object,NewLife.Model.IActor)">
            <summary>添加消息，驱动内部处理</summary>
            <param name="message">消息</param>
            <param name="sender">发送者</param>
            <returns>返回待处理消息数</returns>
        </member>
        <member name="T:NewLife.Model.ActorContext">
            <summary>Actor上下文</summary>
        </member>
        <member name="P:NewLife.Model.ActorContext.Sender">
            <summary>发送者</summary>
        </member>
        <member name="P:NewLife.Model.ActorContext.Message">
            <summary>消息</summary>
        </member>
        <member name="T:NewLife.Model.Actor">
            <summary>无锁并行编程模型</summary>
            <remarks>
            独立线程轮询消息队列，简单设计避免影响默认线程池。
            </remarks>
        </member>
        <member name="P:NewLife.Model.Actor.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.Actor.Active">
            <summary>是否启用</summary>
        </member>
        <member name="P:NewLife.Model.Actor.BoundedCapacity">
            <summary>受限容量。最大可堆积的消息数，默认Int32.MaxValue</summary>
        </member>
        <member name="P:NewLife.Model.Actor.BatchSize">
            <summary>批大小。每次处理消息数，默认1，大于1表示启用批量处理模式</summary>
        </member>
        <member name="P:NewLife.Model.Actor.LongRunning">
            <summary>是否长时间运行。长时间运行任务使用独立线程，默认false</summary>
        </member>
        <member name="P:NewLife.Model.Actor.MailBox">
            <summary>存放消息的邮箱。默认FIFO实现，外部可覆盖</summary>
        </member>
        <member name="P:NewLife.Model.Actor.CompletedTask">
            <summary>已完成任务</summary>
        </member>
        <member name="M:NewLife.Model.Actor.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Model.Actor.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Model.Actor.ToString">
            <summary>已重载。显示名称</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Actor.Start">
            <summary>通知开始处理</summary>
            <remarks>
            添加消息时自动触发
            </remarks>
        </member>
        <member name="M:NewLife.Model.Actor.OnStart">
            <summary>开始时，返回执行线程包装任务，默认LongRunning</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Actor.Stop(System.Int32)">
            <summary>通知停止添加消息，并等待处理完成</summary>
            <param name="msTimeout">等待的毫秒数。0表示不等待，-1表示无限等待</param>
        </member>
        <member name="M:NewLife.Model.Actor.Tell(System.Object,NewLife.Model.IActor)">
            <summary>添加消息，驱动内部处理</summary>
            <param name="message">消息</param>
            <param name="sender">发送者</param>
            <returns>返回待处理消息数</returns>
        </member>
        <member name="M:NewLife.Model.Actor.DoActorWork">
            <summary>循环消费消息</summary>
        </member>
        <member name="M:NewLife.Model.Actor.Loop">
            <summary>循环消费消息</summary>
        </member>
        <member name="M:NewLife.Model.Actor.ReceiveAsync(NewLife.Model.ActorContext)">
            <summary>处理消息</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.Actor.ReceiveAsync(NewLife.Model.ActorContext[])">
            <summary>批量处理消息</summary>
            <param name="contexts">上下文集合</param>
        </member>
        <member name="T:NewLife.Model.DeferredQueue">
            <summary>延迟队列。缓冲合并对象，批量处理</summary>
            <remarks>
            借助实体字典，缓冲实体对象，定期给字典换新，实现批量处理。
            
            有可能外部拿到对象后，正在修改，内部恰巧执行批量处理，导致外部的部分修改未能得到处理。
            解决办法是增加一个提交机制，外部用完后提交修改，内部需要处理时，等待一个时间。
            </remarks>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Entities">
            <summary>实体字典</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.TraceCount">
            <summary>跟踪数。达到该值时输出跟踪日志，默认1000</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Period">
            <summary>周期。默认10_000毫秒</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.MaxEntity">
            <summary>最大个数。超过该个数时，进入队列将产生堵塞。默认100_000</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.BatchSize">
            <summary>批大小。默认5_000</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.WaitForBusy">
            <summary>等待借出对象确认修改的时间，默认3000ms</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Speed">
            <summary>保存速度，每秒保存多少个实体</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Async">
            <summary>是否异步处理。默认true表示异步处理，共用DQ定时调度；false表示同步处理，独立线程</summary>
        </member>
        <member name="P:NewLife.Model.DeferredQueue.Times">
            <summary>合并保存的总次数</summary>
        </member>
        <member name="F:NewLife.Model.DeferredQueue.Finish">
            <summary>批次处理成功时</summary>
        </member>
        <member name="F:NewLife.Model.DeferredQueue.Error">
            <summary>批次处理失败时</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Dispose(System.Boolean)">
            <summary>销毁。统计队列销毁时保存数据</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Init">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.OnInit">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.TryAdd(System.String,System.Object)">
            <summary>尝试添加</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.GetOrAdd``1(System.String,System.Func{System.String,``0})">
            <summary>获取 或 添加 实体对象，在外部修改对象值</summary>
            <remarks>
            外部正在修改对象时，内部不允许执行批量处理
            </remarks>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="valueFactory"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Model.DeferredQueue._busy">
            <summary>等待确认修改的借出对象数</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Commit(System.String)">
            <summary>提交对象的修改，外部不再使用该对象</summary>
            <param name="key"></param>
        </member>
        <member name="F:NewLife.Model.DeferredQueue._count">
            <summary>当前缓存个数</summary>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.ProcessAll(System.Collections.Generic.ICollection{System.Object})">
            <summary>定时处理全部数据</summary>
            <param name="list"></param>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.Process(System.Collections.Generic.IList{System.Object})">
            <summary>处理一批</summary>
            <param name="list"></param>
        </member>
        <member name="M:NewLife.Model.DeferredQueue.OnError(System.Collections.Generic.IList{System.Object},System.Exception)">
            <summary>发生错误</summary>
            <param name="list"></param>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.Model.IHostedService">
            <summary>轻量级主机服务</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/host
            </remarks>
        </member>
        <member name="M:NewLife.Model.IHostedService.StartAsync(System.Threading.CancellationToken)">
            <summary>开始服务</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IHostedService.StopAsync(System.Threading.CancellationToken)">
            <summary>停止服务</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IHost">
            <summary>轻量级应用主机</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/host
            </remarks>
        </member>
        <member name="M:NewLife.Model.IHost.Add(NewLife.Model.IHostedService)">
            <summary>添加服务</summary>
            <param name="service"></param>
        </member>
        <member name="M:NewLife.Model.IHost.Add``1">
            <summary>添加服务</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Model.IHost.Run">
            <summary>同步运行，大循环阻塞</summary>
        </member>
        <member name="M:NewLife.Model.IHost.RunAsync">
            <summary>异步允许，大循环阻塞</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.Host">
            <summary>轻量级应用主机</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/host
            </remarks>
        </member>
        <member name="P:NewLife.Model.Host.ServiceProvider">
            <summary>服务提供者</summary>
        </member>
        <member name="P:NewLife.Model.Host.Services">
            <summary>服务集合</summary>
        </member>
        <member name="M:NewLife.Model.Host.#ctor(System.IServiceProvider)">
            <summary>通过制定服务提供者来实例化一个应用主机</summary>
            <param name="serviceProvider"></param>
        </member>
        <member name="M:NewLife.Model.Host.Add``1">
            <summary>添加服务</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Model.Host.Add(NewLife.Model.IHostedService)">
            <summary>添加服务</summary>
            <param name="service"></param>
        </member>
        <member name="M:NewLife.Model.Host.StartAsync(System.Threading.CancellationToken)">
            <summary>开始</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Host.StopAsync(System.Threading.CancellationToken)">
            <summary>停止</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Host.Run">
            <summary>同步运行，大循环阻塞</summary>
        </member>
        <member name="M:NewLife.Model.Host.RunAsync">
            <summary>异步允许，大循环阻塞</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.BackgroundService">
            <summary>后台任务</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/host
            </remarks>
        </member>
        <member name="M:NewLife.Model.BackgroundService.ExecuteAsync(System.Threading.CancellationToken)">
            <summary>执行</summary>
            <param name="stoppingToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.BackgroundService.StartAsync(System.Threading.CancellationToken)">
            <summary>开始</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.BackgroundService.StopAsync(System.Threading.CancellationToken)">
            <summary>停止</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.BackgroundService.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="T:NewLife.Model.IAuthUser">
            <summary>认证用户接口，具有登录验证、注册、在线等基本信息</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="M:NewLife.Model.IAuthUser.Save">
            <summary>保存</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ManageUserHelper">
            <summary>用户接口工具类</summary>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckEqual(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码相等</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckMD5(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码MD5</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckRC4(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码RC4</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.SaveLogin(NewLife.Model.IAuthUser,NewLife.Net.INetSession)">
            <summary>保存登录信息</summary>
            <param name="user"></param>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.SaveRegister(NewLife.Model.IAuthUser,NewLife.Net.INetSession)">
            <summary>保存注册信息</summary>
            <param name="user"></param>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Model.IFactory`1">
            <summary>用于创建对象的工厂接口</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Model.IFactory`1.Create(System.Object)">
            <summary>创建对象实例</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.Factory`1">
            <summary>反射创建对象的工厂</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Model.Factory`1.Create(System.Object)">
            <summary>创建对象实例</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IHandler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Model.IHandler.Prev">
            <summary>上一个处理器</summary>
        </member>
        <member name="P:NewLife.Model.IHandler.Next">
            <summary>下一个处理器</summary>
        </member>
        <member name="M:NewLife.Model.IHandler.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <remarks>
            最终处理器决定如何使用消息。
            处理得到单个消息时，调用一次下一级处理器，返回下级结果给上一级；
            处理得到多个消息时，调用多次下一级处理器，返回null给上一级；
            </remarks>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.IHandler.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Model.Handler.Prev">
            <summary>上一个处理器</summary>
        </member>
        <member name="P:NewLife.Model.Handler.Next">
            <summary>下一个处理器</summary>
        </member>
        <member name="M:NewLife.Model.Handler.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <remarks>
            最终处理器决定如何使用消息。
            处理得到单个消息时，调用一次下一级处理器，返回下级结果给上一级；
            处理得到多个消息时，调用多次下一级处理器，返回null给上一级；
            </remarks>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Handler.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Handler.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.Handler.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.Handler.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.IHandlerContext">
            <summary>处理器上下文</summary>
        </member>
        <member name="P:NewLife.Model.IHandlerContext.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Model.IHandlerContext.Owner">
            <summary>上下文拥有者</summary>
        </member>
        <member name="M:NewLife.Model.IHandlerContext.FireRead(System.Object)">
            <summary>读取管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Model.IHandlerContext.FireWrite(System.Object)">
            <summary>写入管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Model.HandlerContext">
            <summary>处理器上下文</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Owner">
            <summary>上下文拥有者</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Model.HandlerContext.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.HandlerContext.FireRead(System.Object)">
            <summary>读取管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Model.HandlerContext.FireWrite(System.Object)">
            <summary>写入管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Model.IManageUser">
            <summary>用户接口</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.NickName">
            <summary>昵称</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.Enable">
            <summary>启用</summary>
        </member>
        <member name="T:NewLife.Model.IObjectContainer">
            <summary>轻量级对象容器，支持注入</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/object_container
            </remarks>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Register(System.Type,System.Type,System.Object)">
            <summary>注册类型和名称</summary>
            <param name="serviceType">接口类型</param>
            <param name="implementationType">实现类型</param>
            <param name="instance">实例</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Add(NewLife.Model.IObject)">
            <summary>添加</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.TryAdd(NewLife.Model.IObject)">
            <summary>尝试添加</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Resolve(System.Type)">
            <summary>解析类型的实例</summary>
            <param name="serviceType">接口类型</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ObjectLifetime">
            <summary>生命周期</summary>
        </member>
        <member name="F:NewLife.Model.ObjectLifetime.Singleton">
            <summary>单实例</summary>
        </member>
        <member name="F:NewLife.Model.ObjectLifetime.Transient">
            <summary>每次一个实例</summary>
        </member>
        <member name="T:NewLife.Model.IObject">
            <summary>对象映射接口</summary>
        </member>
        <member name="P:NewLife.Model.IObject.ServiceType">
            <summary>服务类型</summary>
        </member>
        <member name="P:NewLife.Model.IObject.ImplementationType">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.IObject.Lifttime">
            <summary>生命周期</summary>
        </member>
        <member name="T:NewLife.Model.IPipeline">
            <summary>管道。进站顺序，出站逆序</summary>
        </member>
        <member name="M:NewLife.Model.IPipeline.Add(NewLife.Model.IHandler)">
            <summary>添加处理器到末尾</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IPipeline.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.IPipeline.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.Pipeline">
            <summary>管道。进站顺序，出站逆序</summary>
        </member>
        <member name="P:NewLife.Model.Pipeline.Handlers">
            <summary>处理器集合</summary>
        </member>
        <member name="M:NewLife.Model.Pipeline.Add(NewLife.Model.IHandler)">
            <summary>添加处理器到末尾</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.Pipeline.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据，顺序过滤消息，返回结果作为下一个处理器消息</summary>
            <remarks>
            最终处理器决定如何使用消息。
            处理得到单个消息时，调用一次下一级处理器，返回下级结果给上一级；
            处理得到多个消息时，调用多次下一级处理器，返回null给上一级；
            </remarks>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据，逆序过滤消息，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Open(NewLife.Model.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Model.Pipeline.Error(NewLife.Model.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Model.IPlugin">
            <summary>通用插件接口</summary>
            <remarks>
            为了方便构建一个简单通用的插件系统，先规定如下：
            1，负责加载插件的宿主，在加载插件后会进行插件实例化，此时可在插件构造函数中做一些事情，但不应该开始业务处理，因为宿主的准备工作可能尚未完成
            2，宿主一切准备就绪后，会顺序调用插件的Init方法，并将宿主标识传入，插件通过标识区分是否自己的目标宿主。插件的Init应尽快完成。
            3，如果插件实现了<see cref="T:System.IDisposable"/>接口，宿主最后会清理资源。
            </remarks>
        </member>
        <member name="M:NewLife.Model.IPlugin.Init(System.String,System.IServiceProvider)">
            <summary>初始化</summary>
            <param name="identity">插件宿主标识</param>
            <param name="provider">服务提供者</param>
            <returns>返回初始化是否成功。如果当前宿主不是所期待的宿主，这里返回false</returns>
        </member>
        <member name="T:NewLife.Model.PluginAttribute">
            <summary>插件特性。用于判断某个插件实现类是否支持某个宿主</summary>
        </member>
        <member name="P:NewLife.Model.PluginAttribute.Identity">
            <summary>插件宿主标识</summary>
        </member>
        <member name="M:NewLife.Model.PluginAttribute.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="identity"></param>
        </member>
        <member name="T:NewLife.Model.PluginManager">
            <summary>插件管理器</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Identity">
            <summary>宿主标识，用于供插件区分不同宿主</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Provider">
            <summary>宿主服务提供者</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Plugins">
            <summary>插件集合</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor">
            <summary>实例化一个插件管理器</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor(System.Object)">
            <summary>使用宿主对象实例化一个插件管理器</summary>
            <param name="host"></param>
        </member>
        <member name="M:NewLife.Model.PluginManager.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.Model.PluginManager.Load">
            <summary>加载插件。此时是加载所有插件，无法识别哪些是需要的</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.Init">
            <summary>开始初始化。初始化之后，不属于当前宿主的插件将会被过滤掉</summary>
        </member>
        <member name="T:NewLife.Model.IServer">
            <summary>服务接口。</summary>
            <remarks>服务代理XAgent可以附加代理实现了IServer接口的服务。</remarks>
        </member>
        <member name="M:NewLife.Model.IServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Model.IServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="T:NewLife.Model.ModelExtension">
            <summary>模型扩展</summary>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetService``1(System.IServiceProvider)">
            <summary>获取指定类型的服务对象</summary>
            <typeparam name="T"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetRequiredService(System.IServiceProvider,System.Type)">
            <summary>获取必要的服务，不存在时抛出异常</summary>
            <param name="provider"></param>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ModelExtension.GetRequiredService``1(System.IServiceProvider)">
            <summary>获取必要的服务，不存在时抛出异常</summary>
            <typeparam name="T"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ObjectContainer">
            <summary>轻量级对象容器，支持注入</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/object_container
            </remarks>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Current">
            <summary>当前容器</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Provider">
            <summary>当前容器提供者</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Count">
            <summary>注册项个数</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Add(NewLife.Model.IObject)">
            <summary>添加</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.TryAdd(NewLife.Model.IObject)">
            <summary>添加</summary>
            <param name="item"></param>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Register(System.Type,System.Type,System.Object)">
            <summary>注册</summary>
            <param name="serviceType">接口类型</param>
            <param name="implementationType">实现类型</param>
            <param name="instance">实例</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Resolve(System.Type)">
            <summary>解析类型的实例</summary>
            <param name="serviceType">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ObjectMap">
            <summary>对象映射</summary>
        </member>
        <member name="P:NewLife.Model.ObjectMap.ServiceType">
            <summary>服务类型</summary>
        </member>
        <member name="P:NewLife.Model.ObjectMap.ImplementationType">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.ObjectMap.Lifttime">
            <summary>生命周期</summary>
        </member>
        <member name="P:NewLife.Model.ObjectMap.Instance">
            <summary>实例</summary>
        </member>
        <member name="P:NewLife.Model.ObjectMap.Factory">
            <summary>对象工厂</summary>
        </member>
        <member name="M:NewLife.Model.ObjectMap.ToString">
            <summary>显示友好名称</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Model.ServiceProvider.Container">
            <summary>容器</summary>
        </member>
        <member name="T:NewLife.Model.ObjectContainerHelper">
            <summary>对象容器助手。扩展方法专用</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加单实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton``2(NewLife.Model.IObjectContainer)">
            <summary>添加单实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加单实例，指定实例工厂</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton``1(NewLife.Model.IObjectContainer,System.Func{System.IServiceProvider,``0})">
            <summary>添加单实例，指定实例工厂</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Object)">
            <summary>添加单实例，指定实例</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddSingleton``1(NewLife.Model.IObjectContainer,``0)">
            <summary>添加单实例，指定实例</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddSingleton(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>尝试添加单实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient``2(NewLife.Model.IObjectContainer)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <typeparam name="TImplementation"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient``1(NewLife.Model.IObjectContainer)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient(NewLife.Model.IObjectContainer,System.Type,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加瞬态实例，指定实现工厂</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.AddTransient``1(NewLife.Model.IObjectContainer,System.Func{System.IServiceProvider,System.Object})">
            <summary>添加瞬态实例，指定实现工厂</summary>
            <typeparam name="TService"></typeparam>
            <param name="container"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.TryAddTransient(NewLife.Model.IObjectContainer,System.Type,System.Type)">
            <summary>添加瞬态实例，指定实现类型</summary>
            <param name="container"></param>
            <param name="serviceType"></param>
            <param name="implementationType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.BuildServiceProvider(NewLife.Model.IObjectContainer)">
            <summary>从对象容器创建服务提供者</summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.BuildHost(NewLife.Model.IObjectContainer)">
            <summary>从对象容器创建应用主机</summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainerHelper.Resolve``1(NewLife.Model.IObjectContainer)">
            <summary>解析类型的实例</summary>
            <typeparam name="TService">接口类型</typeparam>
            <param name="container">对象容器</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.IMatchQueue">
            <summary>消息匹配队列接口。用于把响应数据包配对到请求包</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Add(System.Object,System.Object,System.Int32,System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>加入请求队列</summary>
            <param name="owner">拥有者</param>
            <param name="request">请求消息</param>
            <param name="msTimeout">超时取消时间</param>
            <param name="source">任务源</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Match(System.Object,System.Object,System.Object,System.Func{System.Object,System.Object,System.Boolean})">
            <summary>检查请求队列是否有匹配该响应的请求</summary>
            <param name="owner">拥有者</param>
            <param name="response">响应消息</param>
            <param name="result">任务结果</param>
            <param name="callback">用于检查匹配的回调</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Clear">
            <summary>清空队列</summary>
        </member>
        <member name="T:NewLife.Net.Handlers.DefaultMatchQueue">
            <summary>消息匹配队列。子类可重载以自定义请求响应匹配逻辑</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Add(System.Object,System.Object,System.Int32,System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>加入请求队列</summary>
            <param name="owner">拥有者</param>
            <param name="request">请求的数据</param>
            <param name="msTimeout">超时取消时间</param>
            <param name="source">任务源</param>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Match(System.Object,System.Object,System.Object,System.Func{System.Object,System.Object,System.Boolean})">
            <summary>检查请求队列是否有匹配该响应的请求</summary>
            <param name="owner">拥有者</param>
            <param name="response">响应消息</param>
            <param name="result">任务结果</param>
            <param name="callback">用于检查匹配的回调</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Check(System.Object)">
            <summary>定时检查发送队列，超时未收到响应则重发</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Clear">
            <summary>清空队列</summary>
        </member>
        <member name="T:NewLife.Net.Handlers.LengthFieldCodec">
            <summary>长度字段作为头部</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Offset">
            <summary>长度所在位置</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Size">
            <summary>长度占据字节数，1/2/4个字节，0表示压缩编码整数，默认2</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Expire">
            <summary>过期时间，超过该时间后按废弃数据处理，默认500ms</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Encode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>编码</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.MessageCodec`1">
            <summary>消息封包编码器</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.Queue">
            <summary>消息队列。用于匹配请求响应包</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.Timeout">
            <summary>调用超时时间。默认30_000ms</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.UserPacket">
            <summary>使用数据包，写入时数据包转消息，读取时消息自动解包返回数据负载。默认true</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Encode(NewLife.Model.IHandlerContext,`0)">
            <summary>编码</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.AddToQueue(NewLife.Model.IHandlerContext,`0)">
            <summary>加入队列</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.IsMatch(System.Object,System.Object)">
            <summary>是否匹配响应</summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.GetLength(NewLife.Data.Packet,System.Int32,System.Int32)">
            <summary>从数据流中获取整帧数据长度</summary>
            <param name="pk">数据包</param>
            <param name="offset">长度的偏移量</param>
            <param name="size">长度大小。0变长，1/2/4小端字节，-2/-4大端字节</param>
            <returns>数据帧长度（包含头部长度位）</returns>
        </member>
        <member name="T:NewLife.Net.Handlers.SplitDataCodec">
            <summary>
            按指定分割字节来处理粘包的处理器
            </summary>
            <remarks>
            默认以"0x0D 0x0A"即换行来分割，分割的包包含分割字节本身，使用时请注意。
            默认分割方式：ISocket.Add&lt;SplitDataCodec&gt;()
            自定义分割方式：ISocket.Add(new SplitDataHandler { SplitData = 自定义分割字节数组 })
            自定义最大缓存大小方式：ISocket.Add(new SplitDataHandler { MaxCacheDataLength = 2048 })
            自定义方式：ISocket.Add(new SplitDataHandler { MaxCacheDataLength = 2048, SplitData = 自定义分割字节数组 })
            </remarks>
        </member>
        <member name="P:NewLife.Net.Handlers.SplitDataCodec.SplitData">
            <summary>
            粘包分割字节数据（默认0x0D,0x0A）
            </summary>
        </member>
        <member name="P:NewLife.Net.Handlers.SplitDataCodec.MaxCacheDataLength">
            <summary>
            最大缓存待处理数据（字节）
            </summary>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk">包</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.SplitDataCodec.GetLineLength(NewLife.Data.Packet)">
            <summary>
            获取包含分割字节在内的数据长度
            </summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.StandardCodec">
            <summary>标准网络封包。头部4字节定长</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.AddToQueue(NewLife.Model.IHandlerContext,NewLife.Messaging.IMessage)">
            <summary>加入队列</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Decode(NewLife.Model.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.IsMatch(System.Object,System.Object)">
            <summary>是否匹配响应</summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Close(NewLife.Model.IHandlerContext,System.String)">
            <summary>连接关闭时，清空粘包编码器</summary>
            <param name="context"></param>
            <param name="reason"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.INetSession">
            <summary>网络服务的会话，每个连接一个会话</summary>
            <remarks>
            所有应用服务器以会话<see cref="T:NewLife.Net.INetSession"/>作为业务处理核心。
            应用服务器收到新会话请求后，通过<see cref="M:NewLife.Net.INetSession.Start"/>启动一个会话处理。
            会话进行业务处理的过程中，可以通过多个Send方法向客户端发送数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.INetSession.ID">
            <summary>唯一会话标识</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Host">
            <summary>主服务</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Session">
            <summary>客户端。跟客户端通讯的那个Socket，其实是服务端TcpSession/UdpSession</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Remote">
            <summary>客户端地址</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <param name="data">数据包</param>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.INetSession.SendAsync(System.Object)">
            <summary>异步发送并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.INetSession.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="T:NewLife.Net.NetSessionEventArgs">
            <summary>会话事件参数</summary>
        </member>
        <member name="P:NewLife.Net.NetSessionEventArgs.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Net.ISocket">
            <summary>基础Socket接口</summary>
            <remarks>
            封装所有基础接口的共有特性！
            
            核心设计理念：事件驱动，接口统一，简单易用！
            异常处理理念：确保主流程简单易用，特殊情况的异常通过事件处理！
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocket.Name">
            <summary>名称。主要用于日志输出</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Client">
            <summary>基础Socket对象</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocket.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.ISocket.WriteLog(System.String,System.Object[])">
            <summary>已重载。日志加上前缀</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="E:NewLife.Net.ISocket.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="T:NewLife.Net.ISocketRemote">
            <summary>远程通信Socket，仅具有收发功能</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.ID">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.LastTime">
            <summary>最后一次通信时间，主要表示会话活跃时间，包括收发</summary>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Send(NewLife.Data.Packet)">
            <summary>发送原始数据包</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.ISocketRemote.Remote"/>决定
            </remarks>
            <param name="data">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Receive">
            <summary>接收数据。阻塞当前线程等待返回</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.ISocketRemote.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessageAsync(System.Object)">
            <summary>异步发送消息并等待响应</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessage(System.Object)">
            <summary>发送消息，不等待响应</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Process(NewLife.Data.IData)">
            <summary>处理消息数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="T:NewLife.Net.SocketRemoteHelper">
            <summary>远程通信Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Send(NewLife.Net.ISocketRemote,System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="session">会话</param>
            <param name="stream">数据流</param>
            <returns>返回是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Send(NewLife.Net.ISocketRemote,System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="session">会话</param>
            <param name="msg">要发送的字符串</param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.ReceiveString(NewLife.Net.ISocketRemote,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="session">会话</param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Add``1(NewLife.Net.ISocket)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="session">会话</param>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Add(NewLife.Net.ISocket,NewLife.Model.IHandler)">
            <summary>添加处理器</summary>
            <param name="session">会话</param>
            <param name="handler">处理器</param>
        </member>
        <member name="T:NewLife.Net.ISocketClient">
            <summary>Socket客户端</summary>
            <remarks>
            具备打开关闭
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketClient.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.ISocketClient.Active">
            <summary>是否活动</summary>
        </member>
        <member name="M:NewLife.Net.ISocketClient.Open">
            <summary>打开连接</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.ISocketClient.Close(System.String)">
            <summary>关闭连接</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="E:NewLife.Net.ISocketClient.Opened">
            <summary>打开后触发。</summary>
        </member>
        <member name="E:NewLife.Net.ISocketClient.Closed">
            <summary>关闭后触发。可实现掉线重连</summary>
        </member>
        <member name="T:NewLife.Net.ISocketServer">
            <summary>Socket服务器接口</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.SessionTimeout">
            <summary>会话超时时间。默认20*60秒</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="E:NewLife.Net.ISocketServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="T:NewLife.Net.ISocketSession">
            <summary>用于与对方进行通讯的Socket会话，仅具有收发功能，也专用于上层应用收发数据</summary>
            <remarks>
            Socket会话发送数据不需要指定远程地址，因为内部已经具有。
            接收数据时，Tcp接收全部数据，而Udp只接受来自所属远方的数据。
            
            Socket会话不具有连接和断开的能力，所以需要外部连接好之后再创建Socket会话。
            但是会话可以销毁，来代替断开。
            对于Udp额外创建的会话来说，仅仅销毁会话而已。
            
            所以，它必须具有收发数据的能力。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketSession.Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="T:NewLife.Net.SessionEventArgs">
            <summary>会话事件参数</summary>
        </member>
        <member name="P:NewLife.Net.SessionEventArgs.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Net.ITransport">
            <summary>帧数据传输接口</summary>
            <remarks>实现者确保数据以包的形式传输，屏蔽数据的粘包和拆包</remarks>
        </member>
        <member name="P:NewLife.Net.ITransport.Timeout">
            <summary>超时</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Close">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Send(NewLife.Data.Packet)">
            <summary>写入数据</summary>
            <param name="data">数据包</param>
        </member>
        <member name="M:NewLife.Net.ITransport.Receive">
            <summary>读取数据</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.ITransport.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="T:NewLife.Net.NetException">
            <summary>网络异常</summary>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:NewLife.Net.NetHandlerContext">
            <summary>网络处理器上下文</summary>
        </member>
        <member name="P:NewLife.Net.NetHandlerContext.Session">
            <summary>远程连接</summary>
        </member>
        <member name="P:NewLife.Net.NetHandlerContext.Data">
            <summary>数据帧</summary>
        </member>
        <member name="M:NewLife.Net.NetHandlerContext.FireRead(System.Object)">
            <summary>读取管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Net.NetHandlerContext.FireWrite(System.Object)">
            <summary>写入管道过滤后最终处理消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Net.NetServer">
            <summary>网络服务器。可同时支持多个Socket服务器，同时支持IPv4和IPv6，同时支持Tcp和Udp</summary>
            <remarks>
            网络服务器模型，所有网络应用服务器可以通过继承该类实现。
            该类仅实现了业务应用对网络流的操作，与具体网络协议无关。
            
            收到请求<see cref="M:NewLife.Net.NetServer.Server_NewSession(System.Object,NewLife.Net.SessionEventArgs)"/>后，会建立<see cref="M:NewLife.Net.NetServer.CreateSession(NewLife.Net.ISocketSession)"/>会话，并加入到会话集合<see cref="P:NewLife.Net.NetServer.Sessions"/>中，然后启动<see cref="M:NewLife.Net.NetServer.Start"/>会话处理；
            
            标准用法：
            指定端口后直接<see cref="M:NewLife.Net.NetServer.Start"/>，NetServer将同时监听Tcp/Udp和IPv4/IPv6（会检查是否支持）四个端口。
            
            高级用法：
            重载方法<see cref="M:NewLife.Net.NetServer.EnsureCreateServer"/>来创建一个SocketServer并赋值给<see cref="P:NewLife.Net.NetServer.Server"/>属性，<see cref="M:NewLife.Net.NetServer.EnsureCreateServer"/>将会在<see cref="M:NewLife.Net.NetServer.OnStart"/>时首先被调用。
            
            超级用法：
            使用<see cref="M:NewLife.Net.NetServer.AttachServer(NewLife.Net.ISocketServer)"/>方法向网络服务器添加Socket服务，其中第一个将作为默认Socket服务<see cref="P:NewLife.Net.NetServer.Server"/>。
            如果Socket服务集合<see cref="P:NewLife.Net.NetServer.Servers"/>为空，将依据地址<see cref="P:NewLife.Net.NetServer.Local"/>、端口<see cref="P:NewLife.Net.NetServer.Port"/>、地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>、协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>创建默认Socket服务。
            如果地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>指定为IPv4和IPv6以外的值，将同时创建IPv4和IPv6两个Socket服务；
            如果协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>指定为Tcp和Udp以外的值，将同时创建Tcp和Udp两个Socket服务；
            默认情况下，地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>和协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>都是其它值，所以一共将会创建四个Socket服务（Tcp、Tcpv6、Udp、Udpv6）。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Name">
            <summary>服务名</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Local">
            <summary>本地结点</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.ProtocolType">
            <summary>协议类型</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.AddressFamily">
            <summary>寻址方案</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Servers">
            <summary>服务器集合</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Server">
            <summary>服务器。返回服务器集合中的第一个服务器</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionTimeout">
            <summary>会话超时时间。默认0秒，使用SocketServer默认值</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.UseSession">
            <summary>使用会话集合，允许遍历会话。默认true</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SslProtocol">
            <summary>SSL协议。默认None，服务端Default，客户端不启用</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Certificate">
            <summary>SSL证书。服务端使用</summary>
            <remarks>var cert = new X509Certificate2("file", "pass");</remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.StatPeriod">
            <summary>显示统计信息的周期。默认600秒，0表示不显示统计信息</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor">
            <summary>实例化一个网络服务器</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Int32)">
            <summary>通过指定监听地址和端口实例化一个网络服务器</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>通过指定监听地址和端口实例化一个网络服务器</summary>
            <param name="address"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Net.IPAddress,System.Int32,NewLife.Net.NetType)">
            <summary>通过指定监听地址和端口，还有协议，实例化一个网络服务器，默认支持Tcp协议和Udp协议</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocolType"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.Dispose(System.Boolean)">
            <summary>已重载。释放会话集合等资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.AttachServer(NewLife.Net.ISocketServer)">
            <summary>添加Socket服务器</summary>
            <param name="server"></param>
            <returns>添加是否成功</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.AddServer(System.Net.IPAddress,System.Int32,NewLife.Net.NetType,System.Net.Sockets.AddressFamily)">
            <summary>同时添加指定端口的IPv4和IPv6服务器，如果协议不是指定的Tcp或Udp，则同时添加Tcp和Udp服务器</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocol"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.EnsureCreateServer">
            <summary>确保建立服务器</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Add``1">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
        </member>
        <member name="M:NewLife.Net.NetServer.Add(NewLife.Model.IHandler)">
            <summary>添加处理器</summary>
            <param name="handler">处理器</param>
        </member>
        <member name="M:NewLife.Net.NetServer.Start">
            <summary>开始服务</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.OnStart">
            <summary>开始时调用的方法</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Stop(System.String)">
            <summary>停止服务</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnStop">
            <summary>停止时调用的方法</summary>
        </member>
        <member name="E:NewLife.Net.NetServer.NewSession">
            <summary>新会话，对于TCP是新连接，对于UDP是新客户端</summary>
        </member>
        <member name="E:NewLife.Net.NetServer.Received">
            <summary>某个会话的数据到达。sender是INetSession</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Server_NewSession(System.Object,NewLife.Net.SessionEventArgs)">
            <summary>接受连接时，对于Udp是收到数据时（同时触发OnReceived）。</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnNewSession(NewLife.Net.ISocketSession)">
            <summary>收到连接时，建立会话，并挂接数据接收和错误处理事件</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceived(System.Object,NewLife.Net.ReceivedEventArgs)">
            <summary>收到数据时</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>收到数据时，最原始的数据处理，但不影响会话内部的数据处理</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="E:NewLife.Net.NetServer.Error">
            <summary>错误发生/断开连接时。sender是ISocketSession</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>触发异常</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:NewLife.Net.NetServer.Sessions">
            <summary>会话集合。用自增的数字ID作为标识，业务应用自己维持ID与业务主键的对应关系。</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionCount">
            <summary>会话数</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.MaxSessionCount">
            <summary>最高会话数</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.AddSession(NewLife.Net.INetSession)">
            <summary>添加会话。子类可以在添加会话前对会话进行一些处理</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.GetSession(System.Int32)">
            <summary>根据会话ID查找会话</summary>
            <param name="sessionid"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.SendAllAsync(NewLife.Data.Packet)">
            <summary>异步群发数据给所有客户端</summary>
            <param name="data"></param>
            <returns>已群发客户端总数</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.SendAllAsync(NewLife.Data.Packet,System.Func{NewLife.Net.INetSession,System.Boolean})">
            <summary>异步群发数据给所有客户端</summary>
            <param name="data"></param>
            <param name="predicate"></param>
            <returns>已群发客户端总数</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateServer(System.Net.IPAddress,System.Int32,NewLife.Net.NetType,System.Net.Sockets.AddressFamily)">
            <summary>创建Tcp/Udp、IPv4/IPv6服务</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocol"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.GetStat">
            <summary>获取统计信息</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.NetServer.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SocketLog">
            <summary>用于内部Socket服务器的日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionLog">
            <summary>用于网络会话的日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.WriteError(System.String,System.Object[])">
            <summary>输出错误日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetServer`1">
            <summary>网络服务器</summary>
            <typeparam name="TSession"></typeparam>
        </member>
        <member name="M:NewLife.Net.NetServer`1.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer`1.GetSession(System.Int32)">
            <summary>获取指定标识的会话</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetSession`1">
            <summary>网络服务的会话，每个连接一个会话</summary>
            <typeparam name="TServer">网络服务类型</typeparam>
        </member>
        <member name="P:NewLife.Net.NetSession`1.Host">
            <summary>主服务</summary>
        </member>
        <member name="T:NewLife.Net.NetSession">
            <summary>网络服务的会话，每个连接一个会话</summary>
            <remarks>
            实际应用可通过重载OnReceive实现收到数据时的业务逻辑。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetSession.ID">
            <summary>唯一会话标识</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.NewLife#Net#INetSession#Host">
            <summary>主服务</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Session">
            <summary>客户端。跟客户端通讯的那个Socket，其实是服务端TcpSession/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Remote">
            <summary>客户端地址</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.NetSession.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Net.NetSession.OnConnected">
            <summary>新的客户端连接</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.OnDisconnected">
            <summary>客户端连接已断开</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>错误发生，可能是连接断开</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <param name="data">数据包</param>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.SendAsync(System.Object)">
            <summary>异步发送并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.NetSession.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.LogSession">
            <summary>是否记录会话日志</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.WriteError(System.String,System.Object[])">
            <summary>输出错误日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetType">
            <summary>协议类型</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Unknown">
            <summary>未知协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Tcp">
            <summary>传输控制协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Udp">
            <summary>用户数据报协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Http">
            <summary>Http协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Https">
            <summary>Https协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.WebSocket">
            <summary>WebSocket协议</summary>
        </member>
        <member name="T:NewLife.Net.NetUri">
            <summary>网络资源标识，指定协议、地址、端口、地址族（IPv4/IPv6）</summary>
            <remarks>
            仅序列化<see cref="P:NewLife.Net.NetUri.Type"/>和<see cref="P:NewLife.Net.NetUri.EndPoint"/>，其它均是配角！
            有可能<see cref="P:NewLife.Net.NetUri.Host"/>代表主机域名，而<see cref="P:NewLife.Net.NetUri.Address"/>指定主机IP地址。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetUri.Type">
            <summary>协议类型</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.EndPoint">
            <summary>终结点</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.IsTcp">
            <summary>是否Tcp协议</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.IsUdp">
            <summary>是否Udp协议</summary>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.Net.IPEndPoint)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="endpoint"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.Net.IPAddress,System.Int32)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="address"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.String,System.Int32)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.Parse(System.String)">
            <summary>分析</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.GetAddresses">
            <summary>获取该域名下所有IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.ParseAddress(System.String)">
            <summary>分析地址</summary>
            <param name="hostname">主机地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.op_Implicit(System.String)~NewLife.Net.NetUri">
            <summary>重载类型转换，字符串直接转为NetUri对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.ReceivedEventArgs">
            <summary>收到数据时的事件参数</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Packet">
            <summary>原始数据包</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Message">
            <summary>解码后的消息</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.UserState">
            <summary>用户自定义数据</summary>
        </member>
        <member name="T:NewLife.Net.SessionBase">
            <summary>会话基类</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.ID">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Local">
            <summary>本地绑定信息</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Remote">
            <summary>远程结点地址</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LastTime">
            <summary>最后一次通信时间，主要表示活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.MaxAsync">
            <summary>最大并行接收数。Tcp默认1，Udp默认CPU*1.6，0关闭异步接收使用同步接收</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.BufferSize">
            <summary>缓冲区大小。默认8k</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.#ctor">
            <summary>构造函数，初始化默认名称</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Open">
            <summary>打开</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnOpen">
            <summary>打开</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnClose(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.SessionBase.Opened">
            <summary>打开后触发。</summary>
        </member>
        <member name="E:NewLife.Net.SessionBase.Closed">
            <summary>关闭后触发。可实现掉线重连</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.Send(NewLife.Data.Packet)">
            <summary>直接发送数据包 Byte[]/Packet</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="data">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="data">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="F:NewLife.Net.SessionBase._RecvCount">
            <summary>当前异步接收个数</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReceiveAsync">
            <summary>开始异步接收</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReleaseRecv(System.Net.Sockets.SocketAsyncEventArgs,System.String)">
            <summary>释放一个事件参数</summary>
            <param name="se"></param>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.StartReceive(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)">
            <summary>用一个事件参数来开始异步接收</summary>
            <param name="se">事件参数</param>
            <param name="ioThread">是否在线程池调用</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ProcessEvent(System.Net.Sockets.SocketAsyncEventArgs,System.Int32,System.Boolean)">
            <summary>同步或异步收到数据</summary>
            <remarks>
            ioThread:
            如果在StartReceive的时候线程池调用ProcessEvent，则处于worker线程；
            如果在IOCP的时候调用ProcessEvent，则处于completionPort线程。
            </remarks>
            <param name="se"></param>
            <param name="bytes"></param>
            <param name="ioThread">是否在IO线程池里面</param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ProcessReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>接收预处理，粘包拆包</summary>
            <param name="pk"></param>
            <param name="remote"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnPreReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据。默认匹配同步接收委托</summary>
            <param name="e">接收事件参数</param>
            <returns>是否已处理，已处理的数据不再向下传递</returns>
        </member>
        <member name="E:NewLife.Net.SessionBase.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.RaiseReceive(System.Object,NewLife.Net.ReceivedEventArgs)">
            <summary>触发数据到达事件</summary>
            <param name="sender"></param>
            <param name="e">接收事件参数</param>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnReceiveError(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>收到异常时如何处理。默认关闭会话</summary>
            <param name="se"></param>
            <returns>是否当作异常处理并结束会话</returns>
        </member>
        <member name="P:NewLife.Net.SessionBase.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="M:NewLife.Net.SessionBase.CreateContext(NewLife.Net.ISocketRemote)">
            <summary>创建上下文</summary>
            <param name="session">远程会话</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessage(System.Object)">
            <summary>通过管道发送消息，不等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessageAsync(System.Object)">
            <summary>通过管道发送消息并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.NewLife#Net#ISocketRemote#Process(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="E:NewLife.Net.SessionBase.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="P:NewLife.Net.SessionBase.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Log">
            <summary>日志对象。禁止设为空对象</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.SessionCollection">
            <summary>会话集合。带有自动清理不活动会话的功能</summary>
        </member>
        <member name="P:NewLife.Net.SessionCollection.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Net.SessionCollection.ClearPeriod">
            <summary>清理周期。单位毫秒，默认10秒。</summary>
        </member>
        <member name="F:NewLife.Net.SessionCollection.clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Net.SessionCollection.Add(NewLife.Net.ISocketSession)">
            <summary>添加新会话，并设置会话编号</summary>
            <param name="session"></param>
            <returns>返回添加新会话是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionCollection.Get(System.String)">
            <summary>获取会话，加锁</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionCollection.CloseAll">
            <summary>关闭所有</summary>
        </member>
        <member name="M:NewLife.Net.SessionCollection.RemoveNotAlive(System.Object)">
            <summary>移除不活动的会话</summary>
        </member>
        <member name="T:NewLife.Net.Setting">
            <summary>网络设置</summary>
        </member>
        <member name="P:NewLife.Net.Setting.Debug">
            <summary>网络调试</summary>
        </member>
        <member name="P:NewLife.Net.Setting.SessionTimeout">
            <summary>会话超时时间。默认20*60秒</summary>
        </member>
        <member name="P:NewLife.Net.Setting.BufferSize">
            <summary>缓冲区大小。默认8k</summary>
        </member>
        <member name="M:NewLife.Net.Setting.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SocketHelper">
            <summary>Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketHelper.SendAsync(System.Net.Sockets.Socket,System.Byte[])">
            <summary>异步发送数据</summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.SendToAsync(System.Net.Sockets.Socket,System.Byte[],System.Net.IPEndPoint)">
            <summary>异步发送数据</summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.IO.Stream,System.Net.IPEndPoint)">
            <summary>发送数据流</summary>
            <param name="socket"></param>
            <param name="stream"></param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.Byte[],System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="socket"></param>
            <param name="buffer">缓冲区</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.String,System.Text.Encoding,System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="socket"></param>
            <param name="message"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Broadcast(System.Net.Sockets.Socket,System.Byte[],System.Int32)">
            <summary>广播数据包</summary>
            <param name="socket"></param>
            <param name="buffer">缓冲区</param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Broadcast(System.Net.Sockets.Socket,System.String,System.Int32)">
            <summary>广播字符串</summary>
            <param name="socket"></param>
            <param name="message"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.SocketHelper.ReceiveString(System.Net.Sockets.Socket,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="socket"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.CheckBroadcast(System.Net.Sockets.Socket,System.Net.IPAddress)">
            <summary>检查并开启广播</summary>
            <param name="socket"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Shutdown(System.Net.Sockets.Socket,System.Boolean)">
            <summary>关闭连接</summary>
            <param name="socket"></param>
            <param name="reuseAddress"></param>
        </member>
        <member name="P:NewLife.Net.SocketHelper.mSafeHandle">
            <summary>SafeHandle字段</summary>
        </member>
        <member name="M:NewLife.Net.SocketHelper.IsNotClosed(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>Socket是否未被关闭</summary>
            <param name="se"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.GetException(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>根据异步事件获取可输出异常，屏蔽常见异常</summary>
            <param name="se"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpServer">
            <summary>TCP服务器</summary>
            <remarks>
            核心工作：启动服务<see cref="M:NewLife.Net.TcpServer.Start"/>时，监听端口，并启用多个（逻辑处理器数的10倍）异步接受操作<see cref="M:NewLife.Net.TcpServer.StartAccept(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)"/>。
            
            服务器完全处于异步工作状态，任何操作都不可能被阻塞。
            
            注意：服务器接受连接请求后，不会开始处理数据，而是由<see cref="E:NewLife.Net.TcpServer.NewSession"/>事件订阅者决定何时开始处理数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Local">
            <summary>本地绑定信息</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.SessionTimeout">
            <summary>会话超时时间</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.MaxAsync">
            <summary>最大并行接收连接数。默认CPU*1.6</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.NoDelay">
            <summary>不延迟直接发送。Tcp为了合并小包而设计，客户端默认false，服务端默认true</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.EnableHttp">
            <summary>启用Http，数据处理时截去请求响应头，默认false</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.SslProtocol">
            <summary>SSL协议。默认None，服务端Default，客户端不启用</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Certificate">
            <summary>SSL证书。服务端使用</summary>
            <remarks>var cert = new X509Certificate2("file", "pass");</remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.#ctor">
            <summary>构造TCP服务器对象</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.#ctor(System.Int32)">
            <summary>构造TCP服务器对象</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.Dispose(System.Boolean)">
            <summary>已重载。释放会话集合等资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="E:NewLife.Net.TcpServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.StartAccept(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)">
            <summary>开启异步接受新连接</summary>
            <param name="se"></param>
            <param name="io">是否IO线程</param>
            <returns>开启异步是否成功</returns>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnAccept(System.Net.Sockets.Socket)">
            <summary>收到新连接时处理</summary>
            <param name="client"></param>
        </member>
        <member name="P:NewLife.Net.TcpServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.CreateSession(System.Net.Sockets.Socket)">
            <summary>创建会话</summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.TcpServer.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Log">
            <summary>日志对象</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpSession">
            <summary>增强TCP客户端</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.RemoteAddress">
            <summary>实际使用的远程地址。Remote配置域名时，可能有多个IP地址</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.DisconnectWhenEmptyData">
            <summary>收到空数据时抛出异常并断开连接。默认true</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.NewLife#Net#ISocketSession#Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer。该属性决定本会话是客户端会话还是服务的会话</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.AutoReconnect">
            <summary>自动重连次数，默认3。发生异常断开连接时，自动重连服务端。</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.NoDelay">
            <summary>不延迟直接发送。Tcp为了合并小包而设计，客户端默认false，服务端默认true</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.SslProtocol">
            <summary>SSL协议。默认None，服务端Default，客户端不启用</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.Certificate">
            <summary>SSL证书。服务端使用</summary>
            <remarks>var cert = new X509Certificate2("file", "pass");</remarks>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor">
            <summary>实例化增强TCP</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor(System.Int32)">
            <summary>使用监听口初始化</summary>
            <param name="listenPort"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor(System.Net.Sockets.Socket)">
            <summary>用TCP客户端初始化</summary>
            <param name="client"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnOpen">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnClose(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnEndRead(System.IAsyncResult)">
            <summary>异步读取数据流，仅用于SSL</summary>
            <param name="ar"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnPreReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e">接收事件参数</param>
        </member>
        <member name="F:NewLife.Net.TcpSession._Reconnect">
            <summary>重连次数</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpServer">
            <summary>增强的UDP</summary>
            <remarks>
            如果已经打开异步接收，还要使用同步接收，则同步Receive内部不再调用底层Socket，而是等待截走异步数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpServer.SessionTimeout">
            <summary>会话超时时间</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpServer.Loopback">
            <summary>是否接收来自自己广播的环回数据。默认false</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.#ctor">
            <summary>实例化增强UDP</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.#ctor(System.Int32)">
            <summary>使用监听口初始化</summary>
            <param name="listenPort"></param>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnOpen">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnClose(System.String)">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.SendMessageAsync(System.Object)">
            <summary>发送消息并等待响应。必须调用会话的发送，否则配对会失败</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnPreReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e">接收事件参数</param>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnReceiveError(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>收到异常时如何处理。Tcp/Udp客户端默认关闭会话，但是Udp服务端不能关闭服务器，仅关闭会话</summary>
            <param name="se"></param>
            <returns>是否当作异常处理并结束会话</returns>
        </member>
        <member name="E:NewLife.Net.UdpServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="P:NewLife.Net.UdpServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.CreateSession(System.Net.IPEndPoint)">
            <summary>创建会话</summary>
            <param name="remoteEP"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpHelper">
            <summary>Udp扩展</summary>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.IO.Stream,System.Net.IPEndPoint)">
            <summary>发送数据流</summary>
            <param name="udp"></param>
            <param name="stream"></param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.Byte[],System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="udp"></param>
            <param name="buffer">缓冲区</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.String,System.Text.Encoding,System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="udp"></param>
            <param name="message"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Broadcast(System.Net.Sockets.UdpClient,System.Byte[],System.Int32)">
            <summary>广播数据包</summary>
            <param name="udp"></param>
            <param name="buffer">缓冲区</param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Broadcast(System.Net.Sockets.UdpClient,System.String,System.Int32)">
            <summary>广播字符串</summary>
            <param name="udp"></param>
            <param name="message"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.UdpHelper.ReceiveString(System.Net.Sockets.UdpClient,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="udp"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpSession">
            <summary>Udp会话。仅用于服务端与某一固定远程地址通信</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.ID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Server">
            <summary>服务器</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.NewLife#Net#ISocket#Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器，进行协议编码解码</summary>
            <remarks>
            1，接收数据解码时，从前向后通过管道处理器；
            2，发送数据编码时，从后向前通过管道处理器；
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpSession.NewLife#Net#ISocketSession#Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LastTime">
            <summary>最后一次通信时间，主要表示活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Tracer">
            <summary>APM性能追踪器</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessage(System.Object)">
            <summary>发送消息，不等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessageAsync(System.Object)">
            <summary>发送消息并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.NewLife#Net#ISocketRemote#Process(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="E:NewLife.Net.UdpSession.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:NewLife.Net.UdpSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.UdpSession.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.UdpSession.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.UdpSession.WriteDebugLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Upgrade">
            <summary>升级更新</summary>
            <remarks>
            优先比较版本Version，再比较时间Time。
            自动更新的难点在于覆盖正在使用的exe/dll文件，通过改名可以解决。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Upgrade.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Server">
            <summary>服务器地址</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Time">
            <summary>本地编译时间</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.UpdatePath">
            <summary>更新目录</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.DestinationPath">
            <summary>目标目录</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Link">
            <summary>超链接信息</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.SourceFile">
            <summary>更新源文件</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.#ctor">
            <summary>实例化一个升级对象实例，获取当前应用信息</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Check">
            <summary>获取版本信息，检查是否需要更新</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Upgrade.Download">
            <summary>开始更新</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Download(System.String,System.String)">
            <summary>开始更新</summary>
            <param name="url">下载源</param>
            <param name="fileName">文件名</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.Update">
            <summary>检查并执行更新操作</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Run">
            <summary>启动当前应用的新进程。当前进程退出</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.DeleteBuckup(System.String)">
            <summary>删除备份文件</summary>
            <param name="dest">目标目录</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.DeleteBackup(System.String)">
            <summary>删除备份文件</summary>
            <param name="dest">目标目录</param>
        </member>
        <member name="M:NewLife.Net.Upgrade.CopyAndReplace(System.String,System.String)">
            <summary>拷贝并替换。正在使用锁定的文件不可删除，但可以改名</summary>
            <param name="source">源目录</param>
            <param name="dest">目标目录</param>
        </member>
        <member name="P:NewLife.Net.Upgrade.Log">
            <summary>日志对象</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Application.ChargenServer">
            <summary>Chargen服务器。不停的向连接者发送数据</summary>
        </member>
        <member name="M:NewLife.Net.Application.ChargenServer.#ctor">
            <summary>实例化一个Chargen服务</summary>
        </member>
        <member name="M:NewLife.Net.Application.ChargenServer.OnNewSession(NewLife.Net.ISocketSession)">
            <summary>已重载。</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.Application.ChargenServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>已重载。</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Net.Application.ChargenServer.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>触发异常</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:NewLife.Net.Application.DaytimeServer">
            <summary>Daytime服务器。返回服务端的时间日期</summary>
        </member>
        <member name="M:NewLife.Net.Application.DaytimeServer.#ctor">
            <summary>实例化一个Daytime服务</summary>
        </member>
        <member name="M:NewLife.Net.Application.DaytimeServer.OnNewSession(NewLife.Net.ISocketSession)">
            <summary>已重载。</summary>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Net.Application.DiscardServer">
            <summary>Discard服务器。抛弃所有收到的数据包，不做任何响应</summary>
        </member>
        <member name="M:NewLife.Net.Application.DiscardServer.#ctor">
            <summary>实例化一个Discard服务</summary>
        </member>
        <member name="M:NewLife.Net.Application.DiscardServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>已重载。</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="T:NewLife.Net.Application.EchoHandler">
            <summary>回声处理器</summary>
        </member>
        <member name="M:NewLife.Net.Application.EchoHandler.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>读取</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Application.EchoServer">
            <summary>Echo服务。把客户端发来的数据原样返回。</summary>
        </member>
        <member name="M:NewLife.Net.Application.EchoServer.#ctor">
            <summary>实例化一个Echo服务</summary>
        </member>
        <member name="M:NewLife.Net.Application.EchoServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>已重载。</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="T:NewLife.Net.Application.LogServer">
            <summary>日志服务</summary>
        </member>
        <member name="M:NewLife.Net.Application.LogServer.#ctor">
            <summary>实例化一个日志服务</summary>
        </member>
        <member name="T:NewLife.Net.Application.LogServer.LogSession">
            <summary>日志会话</summary>
        </member>
        <member name="M:NewLife.Net.Application.LogServer.LogSession.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.Application.LogServer.LogSession.Start">
            <summary>开始会话</summary>
        </member>
        <member name="M:NewLife.Net.Application.LogServer.LogSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>已重载。</summary>
            <param name="e"></param>
        </member>
        <member name="T:NewLife.Net.Application.TimeServer">
            <summary>Time服务器</summary>
        </member>
        <member name="M:NewLife.Net.Application.TimeServer.#ctor">
            <summary>实例化一个Time服务。向请求者返回1970年1月1日以来的所有秒数</summary>
        </member>
        <member name="M:NewLife.Net.Application.TimeServer.OnNewSession(NewLife.Net.ISocketSession)">
            <summary>已重载。</summary>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Net.Common.BufferPool">
            <summary>缓冲池</summary>
            <remarks>
            频繁的分配小块内存，很容易形成内存碎片，并可能倒置GC无法回收而最后内存不足。
            缓冲池采用一开始就分配一大块空间的策略，谁要使用内存再从池里申请，用完后自动归还。
            这样整个缓冲池的生命周期内GC不来干涉。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Common.BufferPool.Count">
            <summary>内存块数</summary>
        </member>
        <member name="P:NewLife.Net.Common.BufferPool.Size">
            <summary>内存分块大小</summary>
        </member>
        <member name="F:NewLife.Net.Common.BufferPool._Buffer">
            <summary>一大块预先申请的内存区域</summary>
        </member>
        <member name="F:NewLife.Net.Common.BufferPool._Index">
            <summary>下一次可用的内存块偏移量</summary>
        </member>
        <member name="F:NewLife.Net.Common.BufferPool._TotalBytes">
            <summary>总内存大小</summary>
        </member>
        <member name="F:NewLife.Net.Common.BufferPool._Free">
            <summary>用过后归还的内存块索引，优先从这里借用</summary>
        </member>
        <member name="P:NewLife.Net.Common.BufferPool.Available">
            <summary>可用内存块数</summary>
        </member>
        <member name="M:NewLife.Net.Common.BufferPool.#ctor(System.Int32,System.Int32)">
            <summary>通过指定内存块数量和大小实例化一个内存池</summary>
            <param name="count">内存块数量</param>
            <param name="size">内存块大小</param>
        </member>
        <member name="M:NewLife.Net.Common.BufferPool.Pop(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>借出内存区域</summary>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.Common.BufferPool.Push(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>归还内存块</summary>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Common.IStatistics">
            <summary>统计接口。
            <see cref="M:NewLife.Net.Common.IStatistics.Increment(System.Int32)"/>后更新<see cref="P:NewLife.Net.Common.IStatistics.First"/>、<see cref="P:NewLife.Net.Common.IStatistics.Last"/>、<see cref="P:NewLife.Net.Common.IStatistics.Total"/>，
            但并不会马上更新统计数据，除非<see cref="P:NewLife.Net.Common.IStatistics.Enable"/>为true。</summary>
            <example>
            <code>
            private IStatistics _Statistics;
            /// &lt;summary&gt;统计信息，默认关闭，通过&lt;see cref="IStatistics.Enable"/&gt;打开。&lt;/summary&gt;
            public IStatistics Statistics { get { return _Statistics ?? (_Statistics = NetService.Resolve&lt;IStatistics&gt;()); } }
            </code>
            </example>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.Enable">
            <summary>是否启用统计。</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.First">
            <summary>首次统计时间</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.Last">
            <summary>最后统计时间</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.Total">
            <summary>每分钟最大值</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.TotalPerMinute">
            <summary>每分钟总操作</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.TotalPerHour">
            <summary>每小时总操作</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.MaxPerMinute">
            <summary>每分钟最大值</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.AveragePerSecond">
            <summary>每秒平均</summary>
        </member>
        <member name="P:NewLife.Net.Common.IStatistics.AveragePerMinute">
            <summary>每分钟平均</summary>
        </member>
        <member name="M:NewLife.Net.Common.IStatistics.Increment(System.Int32)">
            <summary>增加计数</summary>
            <param name="n"></param>
        </member>
        <member name="T:NewLife.Net.Common.Pool`1">
            <summary>
            对象池
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Net.Common.Pool`1.Stock">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Net.Common.Pool`1.Max">
            <summary>最大缓存数</summary>
        </member>
        <member name="P:NewLife.Net.Common.Pool`1.StockCount">
            <summary>在库</summary>
        </member>
        <member name="P:NewLife.Net.Common.Pool`1.NotStockCount">
            <summary>不在库</summary>
        </member>
        <member name="P:NewLife.Net.Common.Pool`1.CreateCount">
            <summary>创建数</summary>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Push(`0)">
            <summary>
            归还
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Pop">
            <summary>
            借出
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Create">
            <summary>
            创建实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Clear">
            <summary>
            清空
            </summary>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="P:NewLife.Net.Common.Pool`1.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Dispose(System.Boolean)">
            <summary>
            释放资源，参数表示是否由Dispose调用。该方法保证OnDispose只被调用一次！
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.OnDispose(System.Boolean)">
            <summary>
            子类重载实现资源释放逻辑
            </summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Net.Common.Pool`1.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="T:NewLife.Net.Common.Statistics">
            <summary>统计</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.Enable">
            <summary>是否启用统计</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.First">
            <summary>首次统计时间</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.Last">
            <summary>最后统计时间</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.Total">
            <summary>每分钟最大值</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.TotalPerMinute">
            <summary>每分钟总操作</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.TotalPerHour">
            <summary>每小时总操作</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.MaxPerMinute">
            <summary>每分钟最大值</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.AveragePerSecond">
            <summary>每秒平均</summary>
        </member>
        <member name="P:NewLife.Net.Common.Statistics.AveragePerMinute">
            <summary>每分钟平均</summary>
        </member>
        <member name="M:NewLife.Net.Common.Statistics.Increment(System.Int32)">
            <summary>增加计数</summary>
            <param name="n"></param>
        </member>
        <member name="T:NewLife.Net.Common.WeakReference`1">
            <summary>
            弱引用
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Net.Common.WeakReference`1.#ctor">
            <summary>
            实例化
            </summary>
        </member>
        <member name="M:NewLife.Net.Common.WeakReference`1.#ctor(`0)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:NewLife.Net.Common.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>
            实例化
            </summary>
            <param name="target"></param>
            <param name="trackResurrection"></param>
        </member>
        <member name="P:NewLife.Net.Common.WeakReference`1.Target">
            <summary>
            目标引用对象
            </summary>
        </member>
        <member name="M:NewLife.Net.Common.WeakReference`1.op_Implicit(NewLife.Net.Common.WeakReference{`0})~`0">
            <summary>
            类型转换
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Common.WeakReference`1.op_Implicit(`0)~NewLife.Net.Common.WeakReference{`0}">
            <summary>
            类型转换
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DICOM.DicomServer">
            <summary>DICOM服务端。管理所有网络会话</summary>
        </member>
        <member name="M:NewLife.Net.DICOM.DicomServer.#ctor">
            <summary>实例化服务端</summary>
        </member>
        <member name="T:NewLife.Net.DICOM.DicomSession">
            <summary>DICOM会话。每一个远程连接唯一对应一个网络会话，再次重复收发信息</summary>
        </member>
        <member name="M:NewLife.Net.DICOM.DicomSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端数据</summary>
            <param name="e"></param>
        </member>
        <member name="T:NewLife.Net.DNS.BinaryDNS">
            <summary>DNS的二进制序列化</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSClient">
            <summary>DNS客户端</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSClient.Server">
            <summary>DNS服务器</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSClient.Client">
            <summary>网络客户端</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSClient.Total">
            <summary>总次数</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSClient.Success">
            <summary>成功数</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSClient.Percent">
            <summary>成功率</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.#ctor">
            <summary>使用本地DNS配置创建DNS客户端</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.#ctor(NewLife.Net.NetUri)">
            <summary>使用指定目标服务器创建DNS客户端</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.Open">
            <summary>打开客户端</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.Close(System.String)">
            <summary>关闭客户端</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.OnReceive(NewLife.Net.DNS.DNSEntity)">
            <summary>收到响应</summary>
            <param name="dns"></param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.QueryAsync(NewLife.Net.DNS.DNSEntity)">
            <summary>异步查询解析</summary>
            <param name="dns"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSClient.QueryAll(System.Collections.Generic.IEnumerable{NewLife.Net.DNS.DNSClient},NewLife.Net.DNS.DNSEntity,System.Int32)">
            <summary>使用一批DNS客户端发起请求</summary>
            <param name="clients"></param>
            <param name="dns"></param>
            <param name="msTimeout"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DNS.DNSEntity">
            <summary>DNS实体类基类</summary>
            <remarks>
            参考博客园 @看那边的人 <a target="_blank" href="http://www.cnblogs.com/topdog/archive/2011/11/15/2250185.html">DIY一个DNS查询器：了解DNS协议</a> 
            <a target="_blank" href="http://www.cnblogs.com/topdog/archive/2011/11/21/2257597.html">DIY一个DNS查询器：程序实现</a>
            </remarks>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEntity.Header">
            <summary>头部</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEntity.Questions">
            <summary>请求段</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEntity.Answers">
            <summary>回答段</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEntity.Authoritis">
            <summary>授权段</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEntity.Additionals">
            <summary>附加段</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.GetAnswer(System.Boolean)">
            <summary>获取响应</summary>
            <param name="create"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.Read(System.IO.Stream,System.Object)">
            <summary>从数据流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.Write(System.IO.Stream,System.Object)">
            <summary>把消息写入到数据流中</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.Write(System.IO.Stream,System.Boolean)">
            <summary>把当前对象写入到数据流中去</summary>
            <param name="stream"></param>
            <param name="forTcp">是否是Tcp，Tcp需要增加整个流长度</param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.GetStream(System.Boolean)">
            <summary>获取当前对象的数据流</summary>
            <param name="forTcp">是否是Tcp，Tcp需要增加整个流长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.Read(System.Byte[],System.Boolean)">
            <summary>从数据中读取对象</summary>
            <param name="data"></param>
            <param name="forTcp">是否是Tcp，Tcp需要增加整个流长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.Read(System.IO.Stream,System.Boolean)">
            <summary>从数据流中读取对象，返回<see cref="T:NewLife.Net.DNS.DNS_A"/>、<see cref="T:NewLife.Net.DNS.DNS_PTR"/>等真实对象</summary>
            <param name="stream"></param>
            <param name="forTcp">是否是Tcp，Tcp需要增加整个流长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.CreateRecord(NewLife.Net.DNS.DNSQueryType)">
            <summary>创建指定类型的记录</summary>
            <param name="qt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.CloneFrom(NewLife.Net.DNS.DNSEntity)">
            <summary>复制</summary>
            <param name="entity"></param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSEntity.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DNS.DNSHeader">
            <summary>DNS头部</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSHeader.gid">
            <summary>全局编号，不断累加</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.ID">
            <summary>长度为16位，是一个用户发送查询的时候定义的随机数，当服务器返回结果的时候，返回包的ID与用户发送的一致。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSHeader._D1">
            <summary>默认RecursionDesired</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Response">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Opcode">
            <summary>长度4位，值0是标准查询，1是反向查询，2是服务器状态查询。</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.AuthoritativeAnswer">
            <summary>长度1位，授权应答(Authoritative Answer) - 这个比特位在应答的时候才有意义，指出给出应答的服务器是查询域名的授权解析服务器。</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.TrunCation">
            <summary>长度1位，截断(TrunCation) - 用来指出报文比允许的长度还要长，导致被截断。</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.RecursionDesired">
            <summary>长度1位，期望递归(Recursion Desired) - 这个比特位被请求设置，应答的时候使用的相同的值返回。如果设置了RD，就建议域名服务器进行递归解析，递归查询的支持是可选的。</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.RecursionAvailable">
            <summary>长度1位，支持递归(Recursion Available) - 这个比特位在应答中设置或取消，用来代表服务器是否支持递归查询。</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Broadcast">
            <summary>Broadcast Flag</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.ResponseCode">
            <summary>长度4位，应答码，类似http的stateCode一样，值0没有错误、1格式错误、2服务器错误、3名字错误、4服务器不支持、5拒绝。</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Questions">
            <summary>报文请求段中的问题记录数</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Answers">
            <summary>报文回答段中的回答记录数</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Authoritis">
            <summary>报文授权段中的授权记录数</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSHeader.Additionals">
            <summary>报文附加段中的附加记录数</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSHeader.#ctor">
            <summary>实例化一个DNS头部</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSNameAccessor">
            <summary>DNS名称访问器</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSNameAccessor.Keys">
            <summary>键</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSNameAccessor.Values">
            <summary>值</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSNameAccessor.#ctor">
            <summary>实例化DNS名称访问器</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSNameAccessor.Read(System.IO.Stream,System.Int64)">
            <summary>从流中读取字符串</summary>
            <param name="stream">数据流</param>
            <param name="offset">数据流相对于真正数据的位移</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DNS.DNSOpcodeType">
            <summary>
            The Query Types (OPCODE) that specifies kind of query in a message.
            (RFC 1035 4.1.1 and 1002 4.2.1.1)
            </summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Query">
            <summary>A standard query (QUERY); used for NetBIOS, too</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.InverseQuery">
            <summary>An inverse query (IQUERY)</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Status">
            <summary>A server status request (STATUS)</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd3">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd4">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Registration">
            <summary>NetBIOS registration</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Release">
            <summary>NetBIOS release</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.WACK">
            <summary>NetBIOS WACK</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Refresh">
            <summary>NetBIOS refresh</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd9">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd10">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd11">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd12">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd13">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd14">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSOpcodeType.Reserverd15">
            <summary>Reserved for future use</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSQueryType">
            <summary>查询的资源记录类型</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.A">
            <summary>指定计算机 IP 地址。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.NS">
            <summary>指定用于命名区域的 DNS 名称服务器。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MD">
            <summary>指定邮件接收站（此类型已经过时了，使用MX代替）</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MF">
            <summary>指定邮件中转站（此类型已经过时了，使用MX代替）</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.CNAME">
            <summary>指定用于别名的规范名称。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.SOA">
            <summary>指定用于 DNS 区域的“起始授权机构”。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MB">
            <summary>指定邮箱域名。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MG">
            <summary>指定邮件组成员。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MR">
            <summary>指定邮件重命名域名。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.NULL">
            <summary>指定空的资源记录</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.WKS">
            <summary>描述已知服务。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.PTR">
            <summary>如果查询是 IP 地址，则指定计算机名；否则指定指向其它信息的指针。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.HINFO">
            <summary>指定计算机 CPU 以及操作系统类型。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MINFO">
            <summary>指定邮箱或邮件列表信息。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.MX">
            <summary>指定邮件交换器。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.TXT">
            <summary>指定文本信息。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.NB">
            <summary>NetBIOS general Name Service Resource Record</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.NBSTAT">
            <summary>NetBIOS NODE STATUS Resource Record</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.AAAA">
            <summary>IPv6地址</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.Root">
            <summary>根</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.UINFO">
            <summary>指定用户信息。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.UID">
            <summary>指定用户标识符。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.GID">
            <summary>指定组名的组标识符。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryType.ANY">
            <summary>指定所有数据类型。</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSQueryClass">
            <summary>指定信息的协议组</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryClass.IN">
            <summary>指定 Internet 类别。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryClass.CSNET">
            <summary>指定 CSNET 类别。（已过时）</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryClass.CHAOS">
            <summary>指定 Chaos 类别。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryClass.HESIOD">
            <summary>指定 MIT Athena Hesiod 类别。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSQueryClass.ANY">
            <summary>指定任何以前列出的通配符。</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSRcodeType">
            <summary>These are the return codes (RCODE) the server can send back. (RFC 1035 4.1.1)</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Success">
            <summary>No error condition</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.FormatError">
            <summary>The name server was unable to interpret the query.</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.ServerFailure">
            <summary>
            The name server was unable to process this query due to a problem 
            with the name server.
            </summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.NameError">
            <summary>
            Meaningful only for responses from an authoritative name server, 
            this code signifies that the domain name referenced in the query 
            does not exist.
            </summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.NotImplemented">
            <summary>The name server does not support the requested kind of query.</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Refused">
            <summary>
            The name server refuses to perform the specified operation for 
            policy reasons.  For example, a name server may not wish to provide 
            the information to the particular requester, or a name server may 
            not wish to perform a particular operation (e.g., zone transfer) 
            for particular data.
            </summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd6">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd7">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd8">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd9">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd10">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd11">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd12">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd13">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd14">
            <summary>Reserved for future use</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRcodeType.Reserverd15">
            <summary>Reserved for future use</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSQuery">
            <summary>DNS查询记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSQuery.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSQuery.Type">
            <summary>查询类型</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSQuery.Class">
            <summary>协议组</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSQuery.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DNS.DNSRecord">
            <summary>DNS记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSRecord.TTL">
            <summary>生存时间。4字节，指示RDATA中的资源记录在缓存的生存时间。</summary>
        </member>
        <member name="F:NewLife.Net.DNS.DNSRecord._Length">
            <summary>长度</summary>
            <remarks>后面应该是一个数据区域，留给派生类</remarks>
        </member>
        <member name="P:NewLife.Net.DNS.DNSRecord.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSRecord.CloneFrom(NewLife.Net.DNS.DNSRecord)">
            <summary>克隆</summary>
            <param name="dr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSRecord.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DNS.DNSServer">
            <summary>DNS服务器</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSServer.DomainName">
            <summary>域名</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSServer.Parents">
            <summary>上级DNS地址</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.#ctor">
            <summary>实例化一个DNS服务器</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.GetLocalDNS">
            <summary>获取本机DNS列表</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.SetParents(System.String)">
            <summary>设置父级DNS</summary>
            <param name="parents"></param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.OnStart">
            <summary>启动服务</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.OnStop">
            <summary>停止服务</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>接收处理</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.Request(NewLife.Net.INetSession,NewLife.Net.DNS.DNSEntity)">
            <summary>处理请求</summary>
            <param name="session"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.RequestPTR(NewLife.Net.DNS.DNSEntity)">
            <summary>处理PTR请求</summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.DNSServer.Response(NewLife.Net.INetSession,NewLife.Net.DNS.DNSEntity,NewLife.Net.DNS.DNSEntity)">
            <summary>处理响应</summary>
            <param name="session"></param>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="E:NewLife.Net.DNS.DNSServer.OnRequest">
            <summary>请求时触发。</summary>
        </member>
        <member name="E:NewLife.Net.DNS.DNSServer.OnResponse">
            <summary>响应时触发。</summary>
        </member>
        <member name="E:NewLife.Net.DNS.DNSServer.OnNew">
            <summary>取得新DNS时触发。</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNSEventArgs">
            <summary>DNS事件参数</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEventArgs.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEventArgs.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNSEventArgs.Session">
            <summary>网络会话</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_A">
            <summary>A记录</summary>
            <remarks>
            查询的时候只需要设置Question.Name，返回的数据里面，Address和DNSRecord.TTL最有价值。
            </remarks>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_A.Address">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_A.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_A.#ctor">
            <summary>构造一个A记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_AAAA">
            <summary>A记录</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_AAAA.#ctor">
            <summary>构造一个AAAA记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_CNAME">
            <summary>CNAME记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_CNAME.PrimaryName">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_CNAME.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_CNAME.#ctor">
            <summary>构造一个CNAME记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_MX">
            <summary>MX记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_MX.Preference">
            <summary>引用</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_MX.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_MX.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_MX.#ctor">
            <summary>构造一个MX记录实例</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_MX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_NB">
            <summary>NetBIOS记录</summary>
            <remarks>
            查询的时候只需要设置Question.Name。
            </remarks>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_NB.G">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_NB.ONT">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_NB.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_NB.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_NB.#ctor">
            <summary>构造一个NetBIOS记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_NS">
            <summary>NS记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_NS.NameServer">
            <summary>命名服务器</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_NS.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_NS.#ctor">
            <summary>构造一个NS记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_PTR">
            <summary>PTR记录</summary>
            <remarks>
            查询的时候只需要设置<see cref="P:NewLife.Net.DNS.DNS_PTR.Address"/>，返回的数据里面，<see cref="P:NewLife.Net.DNS.DNS_PTR.DomainName"/>最有价值。
            </remarks>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_PTR.Address">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_PTR.DomainName">
            <summary>域名</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_PTR.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_PTR.#ctor">
            <summary>构造一个A记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_SOA">
            <summary>SOA记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.PrimaryNameServer">
            <summary>主要名称服务器</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.ResponsibleAuthorityMail">
            <summary>认证邮箱</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.SerialNumber">
            <summary>序列号</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.RefreshInterval">
            <summary>刷新间隔</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.RetryInterval">
            <summary>重试间隔</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.ExpirationLimit">
            <summary>过期限制</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.MinimumTTL">
            <summary>最小TTL</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_SOA.Text">
            <summary>文本信息</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_SOA.#ctor">
            <summary>构造一个SOA记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.DNS_TXT">
            <summary>TXT记录</summary>
        </member>
        <member name="P:NewLife.Net.DNS.DNS_TXT.Text">
            <summary>文本</summary>
        </member>
        <member name="M:NewLife.Net.DNS.DNS_TXT.#ctor">
            <summary>构造一个TXT记录实例</summary>
        </member>
        <member name="T:NewLife.Net.DNS.NetBIOS">
            <summary>NetBIOS名称</summary>
        </member>
        <member name="M:NewLife.Net.DNS.NetBIOS.QueryName(System.String)">
            <summary>查询名称</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.DNS.NetBIOS.Register(System.String,System.Net.IPAddress)">
            <summary>注册</summary>
            <param name="name">名称</param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.SandBoxServer">
            <summary>安全沙箱</summary>
        </member>
        <member name="P:NewLife.Net.SandBoxServer.Policy">
            <summary>安全策略文件内容</summary>
        </member>
        <member name="M:NewLife.Net.SandBoxServer.#ctor">
            <summary>实例化一个安全沙箱服务器</summary>
        </member>
        <member name="M:NewLife.Net.SandBoxServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>数据返回</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="T:NewLife.Net.Http.HttpCache">
            <summary>Http缓存。以Url作为缓存键</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpCache.Expriod">
            <summary>过期时间。单位是秒，默认0秒，表示永不过期</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpCache.Items">
            <summary>缓存项</summary>
        </member>
        <member name="T:NewLife.Net.Http.HttpCacheItem">
            <summary>Http缓存项。</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpCacheItem.Url">
            <summary>网址</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpCacheItem.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpCacheItem.Response">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpCacheItem.Stream">
            <summary>数据流</summary>
        </member>
        <member name="T:NewLife.Net.Http.HttpHeader">
            <summary>Http头部</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.IsResponse">
            <summary>是否响应。以Method是否为空作为依据。</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Method">
            <summary>请求方法</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Url">
            <summary>请求文档</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Version">
            <summary>协议版本</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.StatusCode">
            <summary>状态码</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.StatusDescription">
            <summary>状态描述</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Headers">
            <summary>头部</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.IsFinish">
            <summary>是否完整Http头。是否双换行结束</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpHeader._last">
            <summary>未完成分析时剩下部分</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Host">
            <summary>主机头</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Referer">
            <summary>引用页</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Location">
            <summary>重定向地址</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.Connection">
            <summary>是否保持连接</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.KeepAlive">
            <summary>是否保持连接</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.ProxyConnection">
            <summary>是否保持代理连接</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.ProxyKeepAlive">
            <summary>是否保持代理连接</summary>
        </member>
        <member name="P:NewLife.Net.Http.HttpHeader.RawUrl">
            <summary>原始地址。直接代理会包括全路径</summary>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.Read(System.IO.Stream,NewLife.Net.Http.HttpHeaderReadMode)">
            <summary>从流中读取Http头部对象。如果不是Http头部，指针要回到原来位置</summary>
            <param name="stream"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.ReadFirst(System.IO.Stream)">
            <summary>仅读取第一行。如果不是Http头部，指针要回到原来位置</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.ReadHeaders(System.IO.Stream)">
            <summary>读取头部键值</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.Write(System.IO.Stream)">
            <summary>往流中写入Http头</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.GetStream">
            <summary>获取Http头的数据流</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.ToString">
            <summary>已重载。以文本形式呈现整个头部</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Http.HttpHeader.ToText">
            <summary>文本形式</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Http.HttpHeaderReadMode">
            <summary>读取模式</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpHeaderReadMode.RequestOrResponse">
            <summary>请求或响应</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpHeaderReadMode.Request">
            <summary>请求</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpHeaderReadMode.Response">
            <summary>响应</summary>
        </member>
        <member name="T:NewLife.Net.Http.HttpVerb">
            <summary>Http谓语</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.Unparsed">
            <summary>未解析</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.Unknown">
            <summary>未知</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.GET">
            <summary>获取</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.PUT">
            <summary>推送</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.HEAD">
            <summary>跟GET一样，只不过响应包只包括头部而没有内容</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.POST">
            <summary>提交</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.DEBUG">
            <summary>调试</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.TRACE">
            <summary>跟踪</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.CONNECT">
            <summary>连接</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.OPTIONS">
            <summary>选项</summary>
        </member>
        <member name="F:NewLife.Net.Http.HttpVerb.DELETE">
            <summary>删除</summary>
        </member>
        <member name="T:NewLife.Net.IO.FileClient">
            <summary>文件客户端</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileClient.Client">
            <summary>客户端连接</summary>
        </member>
        <member name="M:NewLife.Net.IO.FileClient.Dispose(System.Boolean)">
            <summary>销毁客户端</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileClient.Connect(System.String,System.Int32)">
            <summary>连接文件服务器</summary>
            <param name="hostname"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileClient.SendFile(System.String)">
            <summary>发送文件</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileClient.SendDirectory(System.String)">
            <summary>发送目录</summary>
            <param name="directoryName"></param>
        </member>
        <member name="P:NewLife.Net.IO.FileClient.Log">
            <summary>日志对象</summary>
        </member>
        <member name="M:NewLife.Net.IO.FileClient.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.IO.FileFormat">
            <summary>文件格式</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileFormat.Name">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileFormat.Length">
            <summary>文件大小</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileFormat.Checksum">
            <summary>头部检验和</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileFormat.Crc">
            <summary>计算出来的32位头部检验码</summary>
        </member>
        <member name="M:NewLife.Net.IO.FileFormat.#ctor">
            <summary>初始化一个实例</summary>
        </member>
        <member name="M:NewLife.Net.IO.FileFormat.#ctor(System.String,System.String)">
            <summary>使用文件路径和根路径初始化一个文件格式对象</summary>
            <param name="fileName"></param>
            <param name="root"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileFormat.Read(System.IO.Stream)">
            <summary>读取</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileFormat.Write(System.IO.Stream)">
            <summary>写入</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileFormat.GetHeader">
            <summary>获取头部数据流</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.IO.FileServer">
            <summary>文件服务端</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileServer.SavedPath">
            <summary>保存路径</summary>
        </member>
        <member name="M:NewLife.Net.IO.FileServer.#ctor">
            <summary>实例化一个文件服务</summary>
        </member>
        <member name="T:NewLife.Net.IO.FileSession">
            <summary>文件服务会话</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileSession.Inf">
            <summary>文件信息</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileSession.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileSession.Stream">
            <summary>文件流</summary>
        </member>
        <member name="P:NewLife.Net.IO.FileSession.StartTime">
            <summary>开始时间</summary>
        </member>
        <member name="M:NewLife.Net.IO.FileSession.Dispose(System.Boolean)">
            <summary>销毁会话</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.IO.FileSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e"></param>
        </member>
        <member name="T:NewLife.Net.Modbus.DataStore">
            <summary>默认数据存储</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.DataStore.Inputs">
            <summary>离散量输入</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.DataStore.Coils">
            <summary>线圈</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.DataStore.InputRegisters">
            <summary>输入寄存器</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.DataStore.HoldingRegisters">
            <summary>保持寄存器</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.DataStore.#ctor">
            <summary>默认初始化</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.DataStore.#ctor(NewLife.Net.Modbus.IBitStore,NewLife.Net.Modbus.IWordStore)">
            <summary>使用两个存储器初始化，两两共用</summary>
            <param name="bit"></param>
            <param name="word"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.DataStore.#ctor(NewLife.Net.Modbus.IBitStore,NewLife.Net.Modbus.IBitStore,NewLife.Net.Modbus.IWordStore,NewLife.Net.Modbus.IWordStore)">
            <summary>使用四个存储器初始化</summary>
            <param name="bitInputs"></param>
            <param name="bitCoils"></param>
            <param name="wordInput"></param>
            <param name="holding"></param>
        </member>
        <member name="T:NewLife.Net.Modbus.BitStore">
            <summary>默认位存储</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.BitStore.Count">
            <summary>数量</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Modbus.BitStore.Item(System.Int32)">
            <summary>索引器</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.BitStore.Read(System.Int32)">
            <summary>读取状态</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.BitStore.Write(System.Int32,System.Boolean)">
            <summary>写入状态</summary>
            <param name="i"></param>
            <param name="flag"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.BitStore.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.BitStore.#ctor(System.Int32)">
            <summary>初始化指定个数存储位</summary>
            <param name="n"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.BitStore.ToArray">
            <summary>数组形式</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.WordStore">
            <summary>默认字存储</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.WordStore.Count">
            <summary>数量</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Modbus.WordStore.Item(System.Int32)">
            <summary>索引器</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.WordStore.Read(System.Int32)">
            <summary>读取</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.WordStore.Write(System.Int32,System.UInt16)">
            <summary>写入</summary>
            <param name="i"></param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Net.Modbus.WordStore.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.WordStore.#ctor(System.Int32)">
            <summary>初始化指定个数存储位</summary>
            <param name="n"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.WordStore.ToArray">
            <summary>数组形式</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.Errors">
            <summary>错误代码</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.FunctionCode">
            <summary>错误的功能代码</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.Address">
            <summary>错误的数据地址</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.Value">
            <summary>错误的数据值</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.Count">
            <summary>错误的个数</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.ProcessError">
            <summary>处理出错</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.MessageLength">
            <summary>错误的数据长度</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.Errors.CrcError">
            <summary>Crc校验错误</summary>
        </member>
        <member name="T:NewLife.Net.Modbus.IDataStore">
            <summary>数据存储接口</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.IDataStore.Inputs">
            <summary>离散量输入</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.IDataStore.Coils">
            <summary>线圈</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.IDataStore.InputRegisters">
            <summary>输入寄存器</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.IDataStore.HoldingRegisters">
            <summary>保持寄存器</summary>
        </member>
        <member name="T:NewLife.Net.Modbus.IBitStore">
            <summary>位存储接口</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.IBitStore.Count">
            <summary>数量</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Modbus.IBitStore.Item(System.Int32)">
            <summary>索引器</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IBitStore.Read(System.Int32)">
            <summary>读取状态</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IBitStore.Write(System.Int32,System.Boolean)">
            <summary>写入状态</summary>
            <param name="i"></param>
            <param name="flag"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.IBitStore.ToArray">
            <summary>数组形式</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.IWordStore">
            <summary>字存储接口</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.IWordStore.Count">
            <summary>寄存器数</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Modbus.IWordStore.Item(System.Int32)">
            <summary>索引器</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IWordStore.Read(System.Int32)">
            <summary>读取</summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IWordStore.Write(System.Int32,System.UInt16)">
            <summary>写入</summary>
            <param name="i"></param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Net.Modbus.IWordStore.ToArray">
            <summary>数组形式</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.StoreHelper">
            <summary>存储类助手</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.StoreHelper.ReadUInt32(NewLife.Net.Modbus.IWordStore,System.Int32)">
            <summary>读取整个UInt32</summary>
            <param name="store"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.StoreHelper.WriteUInt32(NewLife.Net.Modbus.IWordStore,System.Int32,System.UInt32)">
            <summary>写入整个UInt32</summary>
            <param name="store"></param>
            <param name="i"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.IOHelper">
            <summary>IO操作助手</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.IOHelper.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>从字节数组中读取一段数据</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IOHelper.ReadUInt16(System.Byte[],System.Int32)">
            <summary>从字节数据指定位置读取一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IOHelper.WriteUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>向字节数组的指定位置写入一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IOHelper.Write(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>向字节数组写入一片数据</summary>
            <param name="data"></param>
            <param name="srcOffset"></param>
            <param name="buf"></param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.IOHelper.Crc(System.Byte[],System.Int32,System.Int32)">
            <summary>Crc校验</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.MBFunction">
            <summary>Modbus功能码</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.ReadCoils">
            <summary>读取线圈状态。取得一组逻辑线圈的当前状态（ON/OFF) </summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.ReadInputs">
            <summary>读取离散量输入状态。取得一组开关输入的当前状态（ON/OFF) </summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.ReadHoldingRegisters">
            <summary>读取保持寄存器。在一个或多个保持寄存器中取得当前的二进制值 </summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.ReadInputRegisters">
            <summary>读取输入寄存器。在一个或多个输入寄存器中取得当前的二进制值</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.WriteSingleCoil">
            <summary>强置单线圈。强置一个逻辑线圈的通断状态</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.WriteSingleRegister">
            <summary>预置单寄存器。把具体二进值装入一个保持寄存器</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.Diagnostics">
            <summary>回送诊断校验。把诊断校验报文送从机，以对通信处理进行评鉴</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.WriteMultipleCoils">
            <summary>强置多线圈。强置一串连续逻辑线圈的通断</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.WriteMultipleRegisters">
            <summary>预置多寄存器。把具体的二进制值装入一串连续的保持寄存器</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.MBFunction.ReportIdentity">
            <summary>报告从机标识。可使主机判断编址从机的类型及该从机运行指示灯的状态</summary>
        </member>
        <member name="T:NewLife.Net.Modbus.ModbusEntity">
            <summary>Modbus实体</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.ModbusEntity.HEAD_OFFSET">
            <summary>头部位移，RS232=0，RS485=1</summary>
        </member>
        <member name="F:NewLife.Net.Modbus.ModbusEntity.NO_DATA_LENGTH">
            <summary>不包含数据部分的固定长度。地址、功能码、校验码</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusEntity.Host">
            <summary>主机地址。用于485编码</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusEntity.Function">
            <summary>功能码</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusEntity.IsException">
            <summary>是否异常</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusEntity.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusEntity.Crc">
            <summary>校验数据</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusEntity.Parse(System.Byte[],System.Int32,System.Int32)">
            <summary>分析字节数组</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusEntity.ToArray">
            <summary>转为字节数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusEntity.SetError(NewLife.Net.Modbus.Errors)">
            <summary>设置错误码</summary>
            <param name="errorCode"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusEntity.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.ModbusException">
            <summary>Modbus异常</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusException.Error">
            <summary>错误代码</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusException.#ctor(NewLife.Net.Modbus.Errors)">
            <summary>初始化</summary>
            <param name="error"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusException.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Modbus.ModbusMaster">
            <summary>Modbus主站</summary>
            <example>
            <code>
            var master = new ModbusMaster();
            master.Transport = new UdpTransport("127.0.0.1", 502);
            
            Assert.IsTrue(master.Diagnostics(), "诊断错误");
            
            var ids = master.ReportIdentity();
            Assert.IsNotNull(ids, "标识不能为空");
            </code>
            </example>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusMaster.Transport">
            <summary>传输接口</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusMaster.Host">
            <summary>主机地址。用于485编码</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusMaster.Delay">
            <summary>发送数据后接收数据前的延迟时间，默认0毫秒</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.Process(NewLife.Net.Modbus.ModbusEntity,System.Int32)">
            <summary>处理指令</summary>
            <param name="entity">指令实体</param>
            <param name="expect">预期返回数据长度</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReadCoil(System.Int32)">
            <summary>读取线圈状态</summary>
            <remarks>
            请求：0x01|2字节起始地址|2字节线圈数量(1~2000)
            响应：0x01|1字节字节计数|n字节线圈状态（n=输出数量/8，如果余数不为0，n=n+1）
            </remarks>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReadCoils(System.Int32,System.UInt16)">
            <summary>读取线圈状态</summary>
            <remarks>
            请求：0x01|2字节起始地址|2字节线圈数量(1~2000)
            响应：0x01|1字节字节计数|n字节线圈状态（n=输出数量/8，如果余数不为0，n=n+1）
            </remarks>
            <param name="addr"></param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReadInputs(System.Int32,System.UInt16)">
            <summary>读取离散量输入</summary>
            <remarks>
            请求：0x02|2字节起始地址|2字节输入数量(1~2000)
            响应：0x02|1字节字节计数|n字节输入状态（n=输入数量/8，如果余数不为0，n=n+1）
            </remarks>
            <param name="addr"></param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.WriteSingleCoil(System.Int32,System.Boolean)">
            <summary>写单个线圈</summary>
            <remarks>
            请求：0x05|2字节输出地址|2字节输出值（0x0000/0xFF00）
            响应：0x05|2字节输出地址|2字节输出值（0x0000/0xFF00）
            </remarks>
            <param name="addr"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.WriteMultipleCoils(System.Int32,System.Boolean[])">
            <summary>写多个线圈</summary>
            <remarks>
            请求：0x0F|2字节起始地址|2字节输出数量（1~1698）|1字节字节计数|n字节输出值（n=输出数量/8，如果余数不为0，n=n+1）
            响应：0x0F|2字节起始地址|2字节输出数量
            </remarks>
            <param name="addr"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReadHoldingRegister(System.Int32)">
            <summary>读取保持寄存器</summary>
            <remarks>
            请求：0x03|2字节起始地址|2字节寄存器数量（1~2000）
            响应：0x03|1字节字节数|n*2字节寄存器值
            </remarks>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReadHoldingRegisters(System.Int32,System.UInt16)">
            <summary>读取保持寄存器</summary>
            <remarks>
            请求：0x03|2字节起始地址|2字节寄存器数量（1~2000）
            响应：0x03|1字节字节数|n*2字节寄存器值
            </remarks>
            <param name="addr"></param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReadInputRegisters(System.Int32,System.UInt16)">
            <summary>读取输入寄存器</summary>
            <remarks>
            请求：0x04|2字节起始地址|2字节输入寄存器数量（1~2000）
            响应：0x04|1字节字节数|n*2字节输入寄存器
            </remarks>
            <param name="addr"></param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.WriteSingleRegister(System.Int32,System.UInt16)">
            <summary>写单个寄存器</summary>
            <remarks>
            请求：0x06|2字节寄存器地址|2字节寄存器值
            响应：0x06|2字节寄存器地址|2字节寄存器值
            </remarks>
            <param name="addr"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.WriteMultipleRegisters(System.Int32,System.UInt16[])">
            <summary>写多个寄存器</summary>
            <remarks>
            请求：0x10|2字节起始地址|2字节寄存器数量（1~123）|1字节字节计数|n*2寄存器值
            响应：0x10|2字节起始地址|2字节寄存器数量
            </remarks>
            <param name="addr"></param>
            <param name="vals"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.Diagnostics">
            <summary>诊断</summary>
            <remarks>
            01080000801A
            请求：0x08|2字节子功能|n*2字节数据
            响应：0x08|2字节子功能|n*2字节数据
            </remarks>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.ReportIdentity">
            <summary>返回标识</summary>
            <remarks>
            0111C02C
            </remarks>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusMaster.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusMaster.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Modbus.ModbusSlave">
            <summary>Modbus从站</summary>
            <example>
            <code>
            var slave = new ModbusSlave();
            slave.Transport = new UdpTransport(502);
            slave.Listen();
            </code>
            </example>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusSlave.Host">
            <summary>主站ID</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusSlave.DataStore">
            <summary>数据存储</summary>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusSlave.Transports">
            <summary>传输口</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.Listen(NewLife.Net.ITransport)">
            <summary>开始监听</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.Process(NewLife.Data.Packet)">
            <summary>处理Modbus消息</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.Process(NewLife.Net.Modbus.ModbusEntity)">
            <summary>处理Modbus消息</summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.ReadCoils(NewLife.Net.Modbus.ModbusEntity)">
            <summary>读状态 离散量输入/线圈</summary>
            <remarks>
            线圈
            请求：0x01|2字节起始地址|2字节线圈数量(1~2000)
            响应：0x01|1字节字节计数|n字节线圈状态（n=输出数量/8，如果余数不为0，n=n+1）
            
            离散量输入
            请求：0x02|2字节起始地址|2字节输入数量(1~2000)
            响应：0x02|1字节字节计数|n字节输入状态（n=输入数量/8，如果余数不为0，n=n+1）
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.WriteSingleCoil(NewLife.Net.Modbus.ModbusEntity)">
            <summary>写单个线圈</summary>
            <remarks>
            请求：0x05|2字节输出地址|2字节输出值（0x0000/0xFF00）
            响应：0x05|2字节输出地址|2字节输出值（0x0000/0xFF00）
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.WriteMultipleCoils(NewLife.Net.Modbus.ModbusEntity)">
            <summary>写多个线圈</summary>
            <remarks>
            请求：0x0F|2字节起始地址|2字节输出数量（1~1698）|1字节字节计数|n字节输出值（n=输出数量/8，如果余数不为0，n=n+1）
            响应：0x0F|2字节起始地址|2字节输出数量
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.Modbus.ModbusSlave.OnReadCoil">
            <summary>读取线圈前触发</summary>
        </member>
        <member name="E:NewLife.Net.Modbus.ModbusSlave.OnWriteCoil">
            <summary>写入线圈后触发</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.ReadRegisters(NewLife.Net.Modbus.ModbusEntity)">
            <summary>读取寄存器 输入寄存器/保持寄存器</summary>
            <remarks>
            保持寄存器
            请求：0x03|2字节起始地址|2字节寄存器数量（1~2000）
            响应：0x03|1字节字节数|n*2字节寄存器值
            
            输入寄存器
            请求：0x04|2字节起始地址|2字节输入寄存器数量（1~2000）
            响应：0x04|1字节字节数|n*2字节输入寄存器
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.WriteSingleRegister(NewLife.Net.Modbus.ModbusEntity)">
            <summary>写单个寄存器</summary>
            <remarks>
            请求：0x06|2字节寄存器地址|2字节寄存器值
            响应：0x06|2字节寄存器地址|2字节寄存器值
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.WriteMultipleRegisters(NewLife.Net.Modbus.ModbusEntity)">
            <summary>写多个寄存器</summary>
            <remarks>
            请求：0x10|2字节起始地址|2字节寄存器数量（1~123）|1字节字节计数|n*2寄存器值
            响应：0x10|2字节起始地址|2字节寄存器数量
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.Modbus.ModbusSlave.OnReadRegister">
            <summary>读取寄存器前触发</summary>
        </member>
        <member name="E:NewLife.Net.Modbus.ModbusSlave.OnWriteRegister">
            <summary>写入寄存器后触发</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.Diagnostics(NewLife.Net.Modbus.ModbusEntity)">
            <summary>诊断</summary>
            <remarks>
            请求：0x08|2字节子功能|n*2字节数据
            响应：0x08|2字节子功能|n*2字节数据
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.ReportIdentity(NewLife.Net.Modbus.ModbusEntity)">
            <summary>报告从站ID</summary>
            <remarks>
            请求：0x11
            响应：0x11|1字节字节计数|从站ID|运行指示状态（0x00=OFF,0xFF=ON）|附加数据
            </remarks>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Modbus.ModbusSlave.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Net.Modbus.ModbusSlave.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Modbus.ModbusHandler">
            <summary>事件委托</summary>
            <param name="entity"></param>
            <param name="index"></param>
            <param name="count"></param>
        </member>
        <member name="T:NewLife.Net.Model.DataEventArgs">
            <summary>数据接收事件参数</summary>
        </member>
        <member name="P:NewLife.Net.Model.DataEventArgs.Buffer">
            <summary>缓冲区</summary>
        </member>
        <member name="P:NewLife.Net.Model.DataEventArgs.Offset">
            <summary>偏移</summary>
        </member>
        <member name="P:NewLife.Net.Model.DataEventArgs.Count">
            <summary>字节数</summary>
        </member>
        <member name="M:NewLife.Net.Model.DataEventArgs.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>实例化</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
        </member>
        <member name="T:NewLife.Net.NTP.NTP">
            <summary>Network Time Protocol（NTP）是用来使计算机时间同步化的一种协议</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.LeapIndicator">
            <summary>跳跃指示器，警告在当月最后一天的最终时刻插入的迫近闺秒（闺秒）。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.VersionNumber">
            <summary>版本号。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.Mode">
            <summary>工作模式。该字段包括以下值：0－预留；1－对称行为；3－客户机；4－服务器；5－广播；6－NTP控制信息。NTP协议具有3种工作模式，分别为主/被动对称模式、客户/服务器模式、广播模式。在主/被动对称模式中，有一对一的连接，双方均可同步对方或被对方同步，先发出申请建立连接的一方工作在主动模式下，另一方工作在被动模式下；客户/服务器模式与主/被动模式基本相同，惟一区别在于客户方可被服务器同步，但服务器不能被客户同步；在广播模式中，有一对多的连接，服务器不论客户工作在何种模式下，都会主动发出时间信息，客户根据此信息调整自己的时间。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.Stratum">
            <summary>对本地时钟级别的整体识别。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.PollInterval">
            <summary>有符号整数表示连续信息间的最大间隔。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.Precision">
            <summary>有符号整数表示本地时钟精确度。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.RootDelay">
            <summary>表示到达主参考源的一次往复的总延迟，它是有15～16位小数部分的符号定点小数。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.RootDispersion">
            <summary>表示一次到达主参考源的标准误差，它是有15～16位小数部分的无符号定点小数。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.ReferenceID">
            <summary>识别特殊参考源。</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.ReferenceTimestamp">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.OriginateTimestamp">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.ReceiveTimestamp">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.TransmitTimestamp">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.KeyID">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.NTP.NTP.MessageDigest">
            <summary>消息签名</summary>
        </member>
        <member name="T:NewLife.Net.NTP.NTPLeapIndicator">
            <summary>Leap indicator</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPLeapIndicator.NoWarning">
            <summary>0 - No warning</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPLeapIndicator.LastMinute61">
            <summary>1 - Last minute has 61 seconds</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPLeapIndicator.LastMinute59">
            <summary>2 - Last minute has 59 seconds</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPLeapIndicator.Alarm">
            <summary>3 - Alarm condition (clock not synchronized)</summary>
        </member>
        <member name="T:NewLife.Net.NTP.NTPMode">
            <summary>Mode</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.Reserved">
            <summary>未知</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.SymmetricActive">
            <summary>1 - Symmetric active</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.SymmetricPassive">
            <summary>2 - Symmetric pasive</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.Client">
            <summary>3 - Client</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.Server">
            <summary>4 - Server</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.Broadcast">
            <summary>5 - Broadcast</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.ReservedForNTPControlMessage">
            <summary>6 - reserved for NTP control message</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPMode.ReservedForPrivateUse">
            <summary>7 - reserved for private use</summary>
        </member>
        <member name="T:NewLife.Net.NTP.NTPStratum">
            <summary>Stratum</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPStratum.Unspecified">
            <summary>0 - unspecified or unavailable</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPStratum.PrimaryReference">
            <summary>1 - primary reference (e.g. radio-clock)</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPStratum.SecondaryReference">
            <summary>2-15 - secondary reference (via NTP or SNTP)</summary>
        </member>
        <member name="F:NewLife.Net.NTP.NTPStratum.Reserved">
            <summary>16-255 - reserved</summary>
        </member>
        <member name="T:NewLife.Net.P2P.HoleServer">
            <summary>打洞服务器</summary>
            <remarks>
            Tcp打洞流程（A想连接B）：
            1，客户端A通过路由器NAT-A连接打洞服务器S
            2，A向S发送标识，异步等待响应
            3，S记录A的标识和会话<see cref="T:NewLife.Net.ISocketClient"/>
            3，客户端B，从业务通道拿到标识
            4，B通过路由器NAT-B连接打洞服务器S，异步等待响应
            5，B向S发送标识
            6，S找到匹配标识，同时向AB会话响应对方的外网地址，会话结束
            7，AB收到响应，B先连接A，A暂停一会后连接B
            </remarks>
        </member>
        <member name="P:NewLife.Net.P2P.HoleServer.Clients">
            <summary>客户端集合</summary>
        </member>
        <member name="M:NewLife.Net.P2P.HoleServer.OnReceive(NewLife.Net.INetSession,NewLife.Data.Packet)">
            <summary>收到数据时</summary>
            <param name="session"></param>
            <param name="pk"></param>
        </member>
        <member name="T:NewLife.Net.P2P.P2PClient">
            <summary>P2P客户端</summary>
            <remarks>
            Tcp打洞流程（A想连接B）：
            1，客户端A通过路由器NAT-A连接打洞服务器S
            2，A向S发送标识，异步等待响应
            3，S记录A的标识和会话<see cref="T:NewLife.Net.ISocketClient"/>
            3，客户端B，从业务通道拿到标识
            4，B通过路由器NAT-B连接打洞服务器S，异步等待响应
            5，B向S发送标识
            6，S找到匹配标识，同时向AB会话响应对方的外网地址，会话结束
            7，AB收到响应，B先连接A，A暂停一会后连接B
            
            经鉴定，我认为网络上所有关于TCP穿透的文章，全部都是在胡扯
            不外乎几种可能：
            1，双方都在同一个内网
            2，通过服务器中转所有数据
            3，臆断，认为那样子就可行。包括许多论文也是这个说法，我中的这招，不经过NAT会成功，经过最流行的TP-LINK就无法成功
            </remarks>
        </member>
        <member name="P:NewLife.Net.P2P.P2PClient.Server">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Net.P2P.P2PClient.HoleServer">
            <summary>打洞服务器地址</summary>
        </member>
        <member name="P:NewLife.Net.P2P.P2PClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Net.P2P.P2PClient.ProtocolType">
            <summary>协议</summary>
        </member>
        <member name="P:NewLife.Net.P2P.P2PClient.ParterAddress">
            <summary>目标伙伴地址</summary>
        </member>
        <member name="P:NewLife.Net.P2P.P2PClient.Success">
            <summary>是否成功</summary>
        </member>
        <member name="M:NewLife.Net.P2P.P2PClient.EnsureServer">
            <summary></summary>
        </member>
        <member name="M:NewLife.Net.P2P.P2PClient.Start(System.String)">
            <summary>开始处理</summary>
            <param name="name">名称</param>
        </member>
        <member name="T:NewLife.Net.P2P.P2PTest">
            <summary>P2P测试</summary>
        </member>
        <member name="M:NewLife.Net.P2P.P2PTest.StartHole(System.Int32)">
            <summary>开始</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.P2P.P2PTest.StartClient(System.String,System.String,System.Int32,System.Boolean)">
            <summary>开始客户端</summary>
            <param name="name">名称</param>
            <param name="server"></param>
            <param name="serverport"></param>
            <param name="isTcp"></param>
        </member>
        <member name="T:NewLife.Net.Proxy.HttpProxy">
            <summary>Http代理。可用于代理各种Http通讯请求。</summary>
            <remarks>Http代理请求与普通请求唯一的不同就是Uri，Http代理请求收到的是可能包括主机名的完整Uri</remarks>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="E:NewLife.Net.Proxy.HttpProxy.OnRequest">
            <summary>收到请求时发生。</summary>
        </member>
        <member name="E:NewLife.Net.Proxy.HttpProxy.OnResponse">
            <summary>收到响应时发生。</summary>
        </member>
        <member name="E:NewLife.Net.Proxy.HttpProxy.OnRequestBody">
            <summary>收到请求主体时发生。</summary>
        </member>
        <member name="E:NewLife.Net.Proxy.HttpProxy.OnResponseBody">
            <summary>收到响应主体时发生。</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.RaiseEvent(NewLife.Net.Proxy.HttpProxy.Session,NewLife.Net.Proxy.HttpProxy.EventKind,NewLife.Net.Proxy.HttpProxyEventArgs)">
            <summary>触发事件</summary>
            <param name="session"></param>
            <param name="kind"></param>
            <param name="he"></param>
            <returns>返回是否取消操作</returns>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpProxy.EnableCache">
            <summary>激活缓存</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpProxy.Cache">
            <summary>Http缓存</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Proxy.HttpProxy.Session">
            <summary>Http反向代理会话</summary>
        </member>
        <member name="F:NewLife.Net.Proxy.HttpProxy.Session.UnFinishedRequest">
            <summary>当前正在处理的请求。一个连接同时只能处理一个请求，除非是Http 1.2</summary>
        </member>
        <member name="F:NewLife.Net.Proxy.HttpProxy.Session.Request">
            <summary>已完成处理，正在转发数据的请求头</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.Session.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据。子类可通过重载该方法来修改数据</summary>
            <remarks>
            如果数据包包括头部和主体，可以分开处理。
            最麻烦的就是数据包不是一个完整的头部，还落了一部分在后面的包上。
            </remarks>
            <param name="e"></param>
        </member>
        <member name="F:NewLife.Net.Proxy.HttpProxy.Session.KeepAlive">
            <summary>是否保持连接</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.Session.OnRequest(NewLife.Net.Http.HttpHeader,NewLife.Net.ReceivedEventArgs)">
            <summary>收到请求时</summary>
            <param name="entity"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.Session.GetCache(NewLife.Net.Http.HttpHeader,NewLife.Net.ReceivedEventArgs)">
            <summary>检查是否存在缓存，如果存在，则直接返回缓存</summary>
            <param name="entity"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.Session.OnReceiveRemote(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据。子类可通过重载该方法来修改数据</summary>
            <param name="e"></param>
            <returns>修改后的数据</returns>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.Session.SetCache(NewLife.Net.Http.HttpHeader,NewLife.Net.ReceivedEventArgs)">
            <summary>如果符合缓存条件，则设置缓存</summary>
            <param name="entity"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxy.Session.OnRemoteDispose(NewLife.Net.ISocketClient)">
            <summary>远程连接断开时触发。默认销毁整个会话，子类可根据业务情况决定客户端与代理的链接是否重用。</summary>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Net.Proxy.HttpProxyEventArgs">
            <summary>Http代理事件参数</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpProxyEventArgs.Header">
            <summary>头部</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpProxyEventArgs.Stream">
            <summary>主体数据流。外部可以更改，如果只是读取，请一定注意保持指针在原来的位置</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpProxyEventArgs.Cancel">
            <summary>是否取消操作</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxyEventArgs.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpProxyEventArgs.#ctor(NewLife.Net.Http.HttpHeader,System.IO.Stream)">
            <summary>实例化</summary>
            <param name="header"></param>
            <param name="stream"></param>
        </member>
        <member name="T:NewLife.Net.Proxy.HttpReverseProxy">
            <summary>Http反向代理。把所有收到的Http请求转发到目标服务器。</summary>
            <remarks>
            主要是修改Http请求头为正确的主机，还有可能修改Http响应。
            
            经典用途：
            1，缓存。代理缓存某些静态资源的请求结果，减少对服务器的请求压力
            2，拦截。禁止访问某些资源，返回空白页或者连接重置
            3，修改请求或响应。更多的可能是修改响应的页面内容
            4，记录统计。记录并统计请求的网址。
            
            修改Http响应的一般做法：
            1，反向映射888端口到目标abc.com
            2，abc.com页面响应时，所有http://abc.com/的连接都修改为http://IP:888
            3，注意在内网的反向代理需要使用公网IP，而不是本机IP
            4，子域名也可以修改，比如http://pic.abc.com/修改为http://IP:888/http_pic.abc.com/
            </remarks>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpReverseProxy.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpReverseProxy.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Proxy.HttpReverseProxy.Session">
            <summary>Http反向代理会话</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpReverseProxy.Session.Request">
            <summary>请求头部</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpReverseProxy.Session.RemoteHost">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.HttpReverseProxy.Session.RawHost">
            <summary>原始主机</summary>
        </member>
        <member name="E:NewLife.Net.Proxy.HttpReverseProxy.Session.OnRequest">
            <summary>请求时触发。</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpReverseProxy.Session.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据。子类可通过重载该方法来修改数据</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.HttpReverseProxy.Session.WriteDebugLog(System.String,System.IO.Stream)">
            <summary>写调试版日志</summary>
            <param name="action"></param>
            <param name="stream"></param>
        </member>
        <member name="T:NewLife.Net.Proxy.NATProxy">
            <summary>通用NAT代理。所有收到的数据，都转发到指定目标</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.NATProxy.RemoteServer">
            <summary>远程服务器地址</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.NATProxy.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.NATProxy.#ctor(System.String,System.Int32)">
            <summary>实例化</summary>
            <param name="hostname">目标服务器地址</param>
            <param name="port">目标服务器端口</param>
        </member>
        <member name="M:NewLife.Net.Proxy.NATProxy.#ctor(System.String,System.Int32,NewLife.Net.NetType)">
            <summary>实例化</summary>
            <param name="hostname">目标服务器地址</param>
            <param name="port">目标服务器端口</param>
            <param name="protocol">协议</param>
        </member>
        <member name="M:NewLife.Net.Proxy.NATProxy.OnStart">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.NATProxy.AddSession(NewLife.Net.INetSession)">
            <summary>添加会话。子类可以在添加会话前对会话进行一些处理</summary>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Net.Proxy.ProxyBase">
            <summary>网络数据转发代理基类</summary>
            <remarks>
            网络代理分为本地服务器、客户端、远程服务器三种角色，本地服务器负责监听并转发客户端和远程服务器之间的所有数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Proxy.ProxyBase.ConnectRemoteOnStart">
            <summary>开始会话时连接远程会话。默认true</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxyBase.#ctor">
            <summary></summary>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxyBase.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxyBase.AddSession(NewLife.Net.INetSession)">
            <summary>添加会话</summary>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Net.Proxy.ProxySession">
            <summary>代理会话。客户端的一次转发请求（或者Tcp连接），就是一个会话。转发的全部操作都在会话中完成。</summary>
            <remarks>
            一个会话应该包含两端，两个Socket，服务端和客户端
            客户端<see cref="P:NewLife.Net.INetSession.Session"/>发来的数据，在这里经过一系列过滤器后，转发给服务端<see cref="P:NewLife.Net.Proxy.ProxySession.RemoteServer"/>；
            服务端<see cref="P:NewLife.Net.Proxy.ProxySession.RemoteServer"/>返回的数据，在这里经过过滤器后，转发给客户端<see cref="P:NewLife.Net.INetSession.Session"/>。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Proxy.ProxySession.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.ProxySession.RemoteServer">
            <summary>远程服务端。跟目标服务端通讯的那个Socket，其实是客户端TcpSession/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.ProxySession.RemoteServerUri">
            <summary>服务端地址</summary>
        </member>
        <member name="P:NewLife.Net.Proxy.ProxySession.ExchangeEmptyData">
            <summary>是否中转空数据包。默认true</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.#ctor">
            <summary>实例化一个代理会话</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.Dispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.StartRemote(NewLife.Net.ReceivedEventArgs)">
            <summary>开始远程连接</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.CreateRemote(NewLife.Net.ReceivedEventArgs)">
            <summary>为会话创建与远程服务器通讯的Socket。可以使用Socket池达到重用的目的。</summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.OnRemoteDispose(NewLife.Net.ISocketClient)">
            <summary>远程连接断开时触发。默认销毁整个会话，子类可根据业务情况决定客户端与代理的链接是否重用。</summary>
            <param name="client"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.OnReceiveRemote(NewLife.Net.ReceivedEventArgs)">
            <summary>收到远程服务器返回的数据</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.SendRemote(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <param name="pk">缓冲区</param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.SendRemote(System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.SendRemote(System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary></summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:NewLife.Net.Proxy.ProxySession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.WriteDebugLog(System.String,System.Object[])">
            <summary>写调试版日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.WriteDebugLog(System.String,System.IO.Stream)">
            <summary>写调试版日志</summary>
            <param name="action"></param>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Net.Proxy.ProxySession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Sdp.SdpAttribute">
            <summary>SDP 属性</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpAttribute.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpAttribute.Value">
            <summary>值</summary>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpAttribute.Parse(System.String)">
            <summary>分析</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpAttribute.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Sdp.SdpConnection">
            <summary>SDP Connection</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpConnection.NetType">
            <summary>网络类型</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpConnection.AddressType">
            <summary>地址类型</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpConnection.Address">
            <summary>地址</summary>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpConnection.Parse(System.String)">
            <summary>分析</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpConnection.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Sdp.SdpMediaDescription">
            <summary>SDP 媒体描述</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.MediaType">
            <summary>媒体类型</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.NumberOfPorts">
            <summary>端口数</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Protocol">
            <summary>协议。UDP;RTP/AVP;RTP/SAVP.</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.MediaFormats">
            <summary>媒体格式</summary>
            <remarks>
            <code>
            ; Media Formats: 
            ; If the Transport Protocol is "RTP/AVP" or "RTP/SAVP" the &lt;fmt&gt; 
            ; sub-fields contain RTP payload type numbers, for example: 
            ; - for Audio: 0: PCMU, 4: G723, 8: PCMA, 18: G729 
            ; - for Video: 31: H261, 32: MPV 
            ; If the Transport Protocol is "udp" the &lt;fmt&gt; sub-fields 
            ; must reference a MIME type 
            </code>
            </remarks>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Information">
            <summary>信息</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Connection">
            <summary>连接</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Bandwidth">
            <summary>带宽</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Attributes">
            <summary>属性集合</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMediaDescription.Tags">
            <summary>标签集合</summary>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpMediaDescription.Parse(System.String)">
            <summary>分析</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpMediaDescription.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Sdp.SdpMessage">
            <summary>会话描述协议</summary>
            <remarks>
            <a target="_blank" href="http://baike.baidu.com/view/875414.htm">会话描述协议</a>
            
            为会话通知、会话邀请和其它形式的多媒体会话初始化等目的提供了多媒体会话描述。
            </remarks>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.Origin">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.SessionName">
            <summary>会话名</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.SessionDescription">
            <summary>会话描述</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.Uri">
            <summary>资源标识</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.Connection">
            <summary>连接</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.Times">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.RepeatTimes">
            <summary>会话重复次数</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.Attributes">
            <summary>属性集合</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpMessage.MediaDescriptions">
            <summary>媒体描述集合</summary>
        </member>
        <member name="T:NewLife.Net.Sdp.SdpOrigin">
            <summary>SDP Origin。RFC 4566 5.2</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpOrigin.UserName">
            <summary>用户名</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpOrigin.SessionID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpOrigin.SessionVersion">
            <summary>会话版本。每次会话数据被修改时都递增该值</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpOrigin.NetType">
            <summary>网络类型。IN</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpOrigin.AddressType">
            <summary>地址类型。IP4，IP6</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpOrigin.UnicastAddress">
            <summary>地址</summary>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpOrigin.Parse(System.String)">
            <summary>分析</summary>
            <param name="value">Origin value.</param>
            <returns>Returns parsed SDP Origin.</returns>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpOrigin.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Sdp.SdpTime">
            <summary>SDP 时间</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpTime.StartTime">
            <summary>开始时间。1900年以来的秒数</summary>
        </member>
        <member name="P:NewLife.Net.Sdp.SdpTime.StopTime">
            <summary>停止时间。1900年以来的秒数</summary>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpTime.Parse(System.String)">
            <summary>分析</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Sdp.SdpTime.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPBind">
            <summary>Bind操作由Bind命令和Bind_Resp应答组成。客户端首先发送Bind命令，服务器端收到Bind命令后，对命令发送方进行验证，然后返回Bind_Resp应答。</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPBind.LoginType">
            <summary>登录类型</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPBind.LoginName">
            <summary>登录名</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPBind.LoginPassowrd">
            <summary>登录密码</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPBind.Reserve">
            <summary>保留</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPBind.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.LoginTypes">
            <summary>Bind操作，登录类型。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.SpToSmg">
            <summary>1：SP向SMG建立的连接，用于发送命令</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.SmgToSp">
            <summary>2：SMG向SP建立的连接，用于发送命令</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.SmgToSmg">
            <summary>3：SMG之间建立的连接，用于转发命令</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.SmgToGns">
            <summary>4：SMG向GNS建立的连接，用于路由表的检索和维护</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.GnsToSmg">
            <summary>5：GNS向SMG建立的连接，用于路由表的更新</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.GnsToGns">
            <summary>6：主备GNS之间建立的连接，用于主备路由表的一致性</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.Test">
            <summary>11：SP与SMG以及SMG之间建立的测试连接，用于跟踪测试</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.LoginTypes.Unknown">
            <summary>其它：保留</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPClient">
            <summary>SGIP客户端</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.Client">
            <summary>TCP客户端</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.IP">
            <summary>IP地址</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.SrcNodeSequence">
            <summary>源节点</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.SystemID">
            <summary>帐号名</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.Logined">
            <summary>是否已登录</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.SPNumber">
            <summary>SP的接入号码。</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.CorpID">
            <summary>企业代码。取值范围：0～99999。</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPClient.ServiceType">
            <summary>业务代码</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.Login">
            <summary>登录。发送Bind指令，接收Bind_Resp响应</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.SendMessage(System.String,System.String)">
            <summary>发信息</summary>
            <param name="target">目标对象</param>
            <param name="content"></param>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.DeliverMessage(System.String,System.String)">
            <summary>传递信息</summary>
            <param name="target">目标对象</param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.Logout">
            <summary>退出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.Send(NewLife.Net.SGIP.SGIPEntity)">
            <summary>发送指令，返回响应</summary>
            <param name="command">指令</param>
            <returns>响应</returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.Read">
            <summary>读命令</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPClient.Write(NewLife.Net.SGIP.SGIPEntity)">
            <summary>写命令</summary>
            <param name="cmd"></param>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPDeliver">
            <summary>MO指令</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.UserNumber">
            <summary>发送短消息的用户手机号，手机号码前加“86”国别标志</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.SPNumber">
            <summary>SP的接入号码</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.TP_pid">
            <summary>GSM协议类型。详细解释请参考GSM03.40中的9.2.3.9</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.TP_udhi">
            <summary>GSM协议类型。详细解释请参考GSM03.40中的9.2.3.23,仅使用1位，右对齐</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.MessageCoding">
            <summary>短消息的编码格式。</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.MessageLength">
            <summary>短消息的长度</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.MessageContent">
            <summary>短消息的内容</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPDeliver.Reserve">
            <summary>保留，扩展用</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPDeliver.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPMessageCodings">
            <summary>短消息的编码格式。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPMessageCodings.Ascii">
            <summary>0：纯ASCII字符串</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPMessageCodings.WriteCard">
            <summary>3：写卡操作</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPMessageCodings.Binary">
            <summary>4：二进制编码</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPMessageCodings.Ucs2">
            <summary>8：UCS2编码</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPMessageCodings.Gbk">
            <summary>15: GBK编码</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPMessageCodings.Others">
            <summary>其它参见GSM3.38第4节：SMS Data Coding Scheme</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPEntity">
            <summary>SGIP命令实体基类</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPEntity.Command">
            <summary>命令</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPEntity.SrcNodeSequence">
            <summary>序列号</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPEntity.DateSequence">
            <summary>序列号</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPEntity.MsgSequence">
            <summary>序列号</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPEntity.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPEntity.#ctor(NewLife.Net.SGIP.SGIPCommands)">
            <summary>实例化</summary>
            <param name="command"></param>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPEntity.Read(System.IO.Stream)">
            <summary>从流中读取对象</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPEntity.Write(System.IO.Stream)">
            <summary>把对象写入流中</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPEntity.GetStream">
            <summary>获取数据流</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPResponse">
            <summary>响应</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPResponse.Result">
            <summary>结果</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPResponse.Reserve">
            <summary>保留</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPCommands">
            <summary>指令枚举</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Bind">
            <summary>绑定</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Bind_Resp">
            <summary>绑定响应</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Unbind">
            <summary>取消绑定</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Unbind_Resp">
            <summary>取消绑定响应</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Submit">
            <summary>提交</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Submit_Resp">
            <summary>提交响应</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Deliver">
            <summary>分发</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Deliver_Resp">
            <summary>分发响应</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Report">
            <summary>报告</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPCommands.Report_Resp">
            <summary>报告响应</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPErrorCodes">
            <summary>错误代码</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.Success">
            <summary>无错误，命令正确接收</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.LoginError">
            <summary>非法登录，如登录名、口令出错、登录名与口令不符等。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.Relogon">
            <summary>重复登录，如在同一TCP/IP连接中连续两次以上请求登录。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.ConnectionFull">
            <summary>连接过多，指单个节点要求同时建立的连接数过多。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.ErrorLoginType">
            <summary>登录类型错，指bind命令中的logintype字段出错。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.ParameterError">
            <summary>参数格式错，指命令中参数值与参数类型不符或与协议规定的范围不符。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.TelnumberError">
            <summary>非法手机号码，协议中所有手机号码字段出现非86130号码或手机号码前未加“86”时都应报错。</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.MsgIDError">
            <summary>消息ID错</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.PackageLengthError">
            <summary>信息长度错</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.SequenceError">
            <summary>非法序列号，包括序列号重复、序列号格式错误等</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.GnsOperationError">
            <summary>非法操作GNS</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.NodeBusy">
            <summary>节点忙，指本节点存储队列满或其他原因，暂时不能提供服务的情况</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.NodeCanNotReachable">
            <summary>目的地址不可达，指路由表存在路由且消息路由正确但被路由的节点暂时不能提供服务的情况</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.RouteError">
            <summary>路由错，指路由表存在路由但消息路由出错的情况，如转错SMG等</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.RoutNodeNotExisted">
            <summary>路由不存在，指消息路由的节点在路由表中不存在</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.FeeNumberError">
            <summary>计费号码无效，鉴权不成功时反馈的错误信息</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.UserCanNotReachable">
            <summary>用户不能通信（如不在服务区、未开机等情况）</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.HandsetFull">
            <summary>手机内存不足</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.HandsetCanNotRecvSms">
            <summary>手机不支持短消息</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.HandsetReturnError">
            <summary>手机接收短消息出现错误</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.UnknownUser">
            <summary>不知道的用户</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.NoDevice">
            <summary>不提供此功能</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.InvalidateDevice">
            <summary>非法设备</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.SystemError">
            <summary>系统失败（一般指系统消息队列满）</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.FullSequence">
            <summary>超过流量限制，指发送方在一秒内的流量已经达到限制，拒绝发送</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPErrorCodes.OtherError">
            <summary>未知错误</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPReport">
            <summary>Report命令用于向SP发送一条先前的Submit命令的当前状态，或者用于向前转SMG发送一条先前的Deliver命令的当前状态。Report命令的接收方需要向发送方返回Report_Resp命令</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.SubmitSequenceNumber1">
            <summary>该命令所涉及的Submit或deliver命令的序列号</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.SubmitSequenceNumber2">
            <summary>该命令所涉及的Submit或deliver命令的序列号</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.SubmitSequenceNumber3">
            <summary>该命令所涉及的Submit或deliver命令的序列号</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.ReportType">
            <summary>Report命令类型</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.UserNumber">
            <summary>接收短消息的手机号，手机号码前加“86”国别标志</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.State">
            <summary>该命令所涉及的短消息的当前执行状态</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.ErrorCode">
            <summary>当State=2时为错误码值，否则为0</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPReport.Reserve">
            <summary>保留，扩展用</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPReport.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPReportTypes">
            <summary>Report命令类型</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPReportTypes.Submit">
            <summary>0：对先前一条Submit命令的状态报告</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPReportTypes.Deliver">
            <summary>1：对先前一条前转Deliver命令的状态报告</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPReportStates">
            <summary>该命令所涉及的短消息的当前执行状态</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPReportStates.Success">
            <summary>0：发送成功</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPReportStates.Accepted">
            <summary>1：等待发送</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SGIPReportStates.Error">
            <summary>2：发送失败</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPServer">
            <summary>SGIP服务器</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPServer.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPSubmit">
            <summary>
            在SP和SMG的通信中，SP用Submit命令向SMG提交MT短消息，发送到用户的手机中。SMG接收到Submit命令，会返回Submit_Resp应答。SMG根据Submit命令中的付费号码，判断出该命令是否应从本地SMSC发送，如果属于本地发送，则直接发送到相应的SMSC，否则路由至相应的SMG。
            在SMG和SMG的通信中，Submit命令用于SMG客户端向服务器端路由从SP收到的MT短消息。服务器端接收到Submit命令后，再发送到与之相连的目的SMSC。
            </summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.SPNumber">
            <summary>SP的接入号码</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.ChargeNumber">
            <summary>付费号码，手机号码前加“86”国别标志；当且仅当群发且对用户收费时为空；如果为空，则该条短消息产生的费用由UserNumber代表的用户支付；如果为全零字符串“000000000000000000000”，表示该条短消息产生的费用由SP支付。</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.UserCount">
            <summary>接收短消息的手机数量，取值范围1至100</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.UserNumber">
            <summary>接收该短消息的手机号，该字段重复UserCount指定的次数，手机号码前加“86”国别标志</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.CorpId">
            <summary>企业代码，取值范围0-99999</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.ServiceType">
            <summary>业务代码，由SP定义</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.FeeType">
            <summary>计费类型</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.FeeValue">
            <summary>取值范围0-99999，该条短消息的收费值，单位为分，由SP定义 对于包月制收费的用户，该值为月租费的值</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.GivenValue">
            <summary>取值范围0-99999，赠送用户的话费，单位为分，由SP定义，特指由SP向用户发送广告时的赠送话费</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.AgentFlag">
            <summary>代收费标志，0：应收；1：实收</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.MorelatetoMTFlag">
            <summary>引起MT消息的原因0-MO点播引起的第一条MT消息；1-MO点播引起的非第一条MT消息；2-非MO点播引起的MT消息；3-系统反馈引起的MT消息。</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.Priority">
            <summary>优先级0-9从低到高，默认为0</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.ExpireTime">
            <summary>短消息寿命的终止时间，如果为空，表示使用短消息中心的缺省值。时间内容为16个字符，格式为”yymmddhhmmsstnnp” ，其中“tnnp”取固定值“032+”，即默认系统为北京时间</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.ScheduleTime">
            <summary>短消息定时发送的时间，如果为空，表示立刻发送该短消息。时间内容为16个字符，格式为“yymmddhhmmsstnnp” ，其中“tnnp”取固定值“032+”，即默认系统为北京时间</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.ReportFlag">
            <summary>状态报告标记0-该条消息只有最后出错时要返回状态报告1-该条消息无论最后是否成功都要返回状态报告2-该条消息不需要返回状态报告3-该条消息仅携带包月计费信息，不下发给用户，要返回状态报告其它-保留缺省设置为0</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.TP_pid">
            <summary>GSM协议类型。详细解释请参考GSM03.40中的9.2.3.9</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.TP_udhi">
            <summary>GSM协议类型。详细解释请参考GSM03.40中的9.2.3.23,仅使用1位，右对齐</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.MessageCoding">
            <summary>短消息的编码格式。0：纯ASCII字符串3：写卡操作4：二进制编码8：UCS2编码15: GBK编码其它参见GSM3.38第4节：SMS Data Coding Scheme</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.MessageType">
            <summary>信息类型：0-短消息信息其它：待定</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.MessageLength">
            <summary>短消息的长度</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.MessageContent">
            <summary>短消息的内容</summary>
        </member>
        <member name="P:NewLife.Net.SGIP.SGIPSubmit.Reserve">
            <summary>保留，扩展用</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPSubmit.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SubmitAgentFlags">
            <summary>代收费标志，0：应收；1：实收</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitAgentFlags.SouldIncome">
            <summary>0：应收</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitAgentFlags.RealIncome">
            <summary>1：实收</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SubmitReportFlags">
            <summary>状态报告标记</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitReportFlags.ErrorReport">
            <summary>0-该条消息只有最后出错时要返回状态报告</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitReportFlags.Always">
            <summary>1-该条消息无论最后是否成功都要返回状态报告</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitReportFlags.NoReport">
            <summary>2-该条消息不需要返回状态报告</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitReportFlags.MonthReport">
            <summary>3-该条消息仅携带包月计费信息，不下发给用户，要返回状态报告</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SubmitMorelatetoMTFlags">
            <summary>引起MT消息的原因</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitMorelatetoMTFlags.VoteFirst">
            <summary>0-MO点播引起的第一条MT消息；</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitMorelatetoMTFlags.VoteNonFirst">
            <summary>1-MO点播引起的非第一条MT消息；</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitMorelatetoMTFlags.NormalFirst">
            <summary>2-非MO点播引起的MT消息；</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.SubmitMorelatetoMTFlags.NormalNonFirst">
            <summary>3-系统反馈引起的MT消息。</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.FeeTypes">
            <summary>计费类别定义</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.FeeTypes.FreeSend">
            <summary>0	“短消息类型”为“发送”，对“计费用户号码”不计信息费，此类话单仅用于核减SP对称的信道费</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.FeeTypes.Free">
            <summary>1	对“计费用户号码”免费</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.FeeTypes.RowNumFee">
            <summary>2	对“计费用户号码”按条计信息费</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.FeeTypes.MonthFee">
            <summary>3	对“计费用户号码”按包月收取信息费</summary>
        </member>
        <member name="F:NewLife.Net.SGIP.FeeTypes.SpFee">
            <summary>4	对“计费用户号码”的收费是由SP实现</summary>
        </member>
        <member name="T:NewLife.Net.SGIP.SGIPUnbind">
            <summary>Unbind操作由Unbind命令和Unbind_Resp应答组成。通信连接建立以后，客户端如果要停止通信，需要发送Unbind命令；服务器端收到Unbind命令后，向客户端发送Unbind_Resp相应，然后双方断开连接</summary>
        </member>
        <member name="M:NewLife.Net.SGIP.SGIPUnbind.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.Sip">
            <summary></summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipACValue">
            <summary>ac-value</summary>
            <remarks>
            <code>
            RFC 3841 Syntax:
                ac-value       = "*" *(SEMI ac-params)
                ac-params      = feature-param / req-param / explicit-param / generic-param
                                 ;;feature param from RFC 3840
                                 ;;generic-param from RFC 3261
                req-param      = "require"
                explicit-param = "explicit"
            </code>
            </remarks>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipACValue.Require">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipACValue.Explicit">
            <summary>属性说明</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipAddressParam">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipAddressParam.Address">
            <summary>地址</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipAlertParam">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipAlertParam.Uri">
            <summary>标识</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipContactParam">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipContactParam.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipContactParam.IsStarContact">
            <summary>是否*联系人</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipContactParam.QValue">
            <summary>qvalue</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipContactParam.Expires">
            <summary>expires</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipContentDisposition">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipContentDisposition.DispositionType">
            <summary>DispositionType</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipContentDisposition.Handling">
            <summary>handling</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipEncoding">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipEncoding.ContentEncoding">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipEncoding.QValue">
            <summary>qvalue</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipErrorUri">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipErrorUri.Uri">
            <summary>属性说明</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipEvent">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipEvent.EventType">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipEvent.ID">
            <summary>id</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipFrom">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipFrom.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipFrom.Tag">
            <summary>tag</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipHiEntry">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipHiEntry.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipHiEntry.Index">
            <summary>index</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipIdentityInfo">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipIdentityInfo.Uri">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipIdentityInfo.Alg">
            <summary>alg</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipInfo">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipInfo.Uri">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipInfo.Purpose">
            <summary>属性说明</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipJoin">
            <summary></summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipNameAddress">
            <summary></summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipNameAddress.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipNameAddress.Uri">
            <summary>唯一标识</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipValue">
            <summary>Sip实体基类</summary>
        </member>
        <member name="T:NewLife.Net.Sip.Message.SipValueWithParams">
            <summary>带参数Sip实体基类</summary>
        </member>
        <member name="P:NewLife.Net.Sip.Message.SipValueWithParams.Parameters">
            <summary>参数集合</summary>
        </member>
        <member name="T:NewLife.Net.Sockets.Netbase">
            <summary>网络基类，提供资源释放和日志输出的统一处理</summary>
        </member>
        <member name="M:NewLife.Net.Sockets.Netbase.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="P:NewLife.Net.Sockets.Netbase.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Net.Sockets.Netbase.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.Sockets.Netbase.WriteDebugLog(System.String,System.Object[])">
            <summary>写调试日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Stress.TcpStress">
            <summary>Tcp压力测试</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.Config">
            <summary>配置</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.Connections">
            <summary>连接数</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.Messages">
            <summary>消息数</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.Bytes">
            <summary>字节数</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.MessagesPerSecond">
            <summary>每秒消息数</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.BytesPerSecond">
            <summary>每秒字节数</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.MaxMessages">
            <summary>最大消息速度</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStress.MaxBytes">
            <summary>最大字节速度</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStress.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStress.Main">
            <summary>入口方法</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStress.Init">
            <summary>初始化工作</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStress.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStress.Stop">
            <summary>停止</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressClient.EndPoint">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressClient.Buffer">
            <summary>数据缓冲区</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressClient.Interval">
            <summary>发送间隔</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressClient.Times">
            <summary>发送次数</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStressClient.StartSend">
            <summary>开始发送</summary>
        </member>
        <member name="T:NewLife.Net.Stress.TcpStressConfig">
            <summary>Tcp压力测试配置文件</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.Address">
            <summary>测试地址</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.Port">
            <summary>测试端口</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.Connections">
            <summary>连接数</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.Interval">
            <summary>连接间隔，单位毫秒</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.Data">
            <summary>发送的数据，十六进制数据使用0x开头</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.UseLength">
            <summary>使用前缀长度</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.SendInterval">
            <summary>发送数据间隔，单位毫秒</summary>
        </member>
        <member name="P:NewLife.Net.Stress.TcpStressConfig.Times">
            <summary>每个连接发送数据次数</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStressConfig.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStressConfig.OnNew">
            <summary>新建配置</summary>
        </member>
        <member name="M:NewLife.Net.Stress.TcpStressConfig.Show">
            <summary>显示参数</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunAttribute.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunAttribute.Length">
            <summary>属性说明</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunAttribute.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunAttribute.EndPoint">
            <summary>网络节点</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunAttribute.Str">
            <summary>字符串</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunAttribute.Int">
            <summary>整型</summary>
        </member>
        <member name="T:NewLife.Net.Stun.AttributeType">
            <summary>属性类型</summary>
        </member>
        <member name="T:NewLife.Net.Stun.StunClient">
            <summary>Stun客户端。Simple Traversal of UDP over NATs，NAT 的UDP简单穿越。RFC 3489</summary>
            <remarks>
            <a target="_blank" href="http://baike.baidu.com/view/884586.htm">STUN</a>
            
            国内STUN服务器：220.181.126.73、220.181.126.74，位于北京电信，但不清楚是哪家公司
            </remarks>
            <example>
            <code>
            var result = new StunClient().Query();
            if(result.Type != StunNetType.UdpBlocked){
                
            }
            else{
                var publicEP = result.Public;
            }
            </code>
            </example>
        </member>
        <member name="P:NewLife.Net.Stun.StunClient.Servers">
            <summary>Stun服务器</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunClient.Socket">
            <summary>套接字</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunClient.Socket2">
            <summary>用于测试更换本地套接字的第二套接字</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunClient.ProtocolType">
            <summary>协议，默认Udp</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunClient.Port">
            <summary>本地端口</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunClient.Timeout">
            <summary>超时时间，默认2000ms</summary>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.#ctor(NewLife.Net.NetType)">
            <summary>在指定协议上执行查询</summary>
            <param name="protocol"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.#ctor(NewLife.Net.NetType,System.Int32)">
            <summary>在指定协议和本地端口上执行查询</summary>
            <param name="protocol"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.#ctor(NewLife.Net.ISocket)">
            <summary>在指定套接字上执行查询</summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.Query">
            <summary>按服务器列表执行查询</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.QueryWithServer(System.Net.IPAddress,System.Int32)">
            <summary>在指定服务器上执行查询</summary>
            <param name="address"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.GetPublic">
            <summary>获取公网地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunClient.Query(NewLife.Net.Stun.StunMessage,System.Net.IPEndPoint)">
            <summary>查询</summary>
            <param name="request"></param>
            <param name="remoteEndPoint"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Stun.StunMessage">
            <summary>Stun消息</summary>
            <remarks>未测试，可能没有考虑字节序</remarks>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.Type">
            <summary>消息类型</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.Length">
            <summary>消息长度</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.TransactionID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.Atts">
            <summary>属性集合</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.MappedAddress">
            <summary>映射地址</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ResponseAddress">
            <summary>响应地址</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ChangeIP">
            <summary>请求改变</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ChangePort">
            <summary>请求改变</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.SourceAddress">
            <summary>源地址</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ChangedAddress">
            <summary>改变后的地址</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.UserName">
            <summary>用户名</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ErrCode">
            <summary>错误</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ErrReason">
            <summary>错误</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ReflectedFrom">
            <summary>服务端从客户端拿到的地址</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunMessage.ServerName">
            <summary>服务器名称</summary>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.#ctor">
            <summary>实例化一个Stun消息</summary>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.ResetTransactionID">
            <summary>重置会话ID</summary>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.Read(System.IO.Stream)">
            <summary>从流中读取消息</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.Write(System.IO.Stream)">
            <summary>把消息写入流中</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.GetStream">
            <summary>获取消息的数据流</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.ToArray">
            <summary>获取消息的字节码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Stun.StunMessage.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Stun.StunMessageType">
            <summary>STUN消息类型</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunMessageType.BindingRequest">
            <summary>绑定请求</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunMessageType.BindingResponse">
            <summary>绑定响应</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunMessageType.BindingErrorResponse">
            <summary>错误响应</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunMessageType.SharedSecretRequest">
            <summary>安全请求</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunMessageType.SharedSecretResponse">
            <summary>安全响应</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunMessageType.SharedSecretErrorResponse">
            <summary>安全错误响应</summary>
        </member>
        <member name="T:NewLife.Net.Stun.StunNetType">
            <summary>UDP网络类型</summary>
            <remarks>
            <a target="_blank" href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换【维基百科】</a>
            </remarks>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.Blocked">
            <summary>被禁止，或无法连接STUN服务器</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.OpenInternet">
            <summary>公网地址，没有NAT和防火墙</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.SymmetricUdpFirewall">
            <summary>公网地址，没有NAT，对称UDP防火墙</summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.FullCone">
            <summary>
            一对一完全圆锥NAT。IP和端口均可变。
            一旦一个内部地址(iAddr:port1)映射到外部地址(eAddr:port2),所有发自iAddr:port1的包都经由eAddr:port2向外发送.
            任意外部主机都能通过给eAddr:port2发包到达iAddr:port1
            </summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.AddressRestrictedCone">
            <summary>
            地址受限圆锥NAT。IP必须固定，端口可变。
            一旦一个内部地址(iAddr:port1)映射到外部地址(eAddr:port2),所有发自iAddr:port1的包都经由eAddr:port2向外发送.
            任意外部主机(hostAddr:any)都能通过给eAddr:port2发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:any. 
            "any"也就是说端口不受限制
            </summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.PortRestrictedCone">
            <summary>
            端口受限圆锥NAT。对方IP和端口都必须固定
            一旦一个内部地址(iAddr:port1)映射到外部地址(eAddr:port2),所有发自iAddr:port1的包都经由eAddr:port2向外发送.
            一个外部主机(hostAddr:port3)能够发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:port3.
            </summary>
        </member>
        <member name="F:NewLife.Net.Stun.StunNetType.Symmetric">
            <summary>
            对称NAT。同一内部地址端口，连接不同外网时，映射的公网地址和端口均不同。
            每一个来自相同内部IP与port的请求到一个特定目的地的IP地址和端口，映射到一个独特的外部来源的IP地址和端口。
            同一个内部主机发出一个信息包到不同的目的端，不同的映射使用
            只有曾经收到过内部主机封包的外部主机，才能够把封包发回来
            </summary>
        </member>
        <member name="T:NewLife.Net.Stun.StunResult">
            <summary>Stun结果</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunResult.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Net.Stun.StunResult.Public">
            <summary>公共地址</summary>
        </member>
        <member name="M:NewLife.Net.Stun.StunResult.#ctor(NewLife.Net.Stun.StunNetType,System.Net.IPEndPoint)">
            <summary>实例化Stun结果</summary>
            <param name="type">类型</param>
            <param name="ep"></param>
        </member>
        <member name="M:NewLife.Net.Stun.StunResult.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.TDP.TDPClient.Udp">
            <summary>UDP客户端</summary>
        </member>
        <member name="T:NewLife.Net.TDP.TDPFlags">
            <summary>TDP标记</summary>
        </member>
        <member name="F:NewLife.Net.TDP.TDPFlags.FIN">
            <summary>发端完成发送任务。</summary>
        </member>
        <member name="F:NewLife.Net.TDP.TDPFlags.SYN">
            <summary>同步序号用来发起一个连接。</summary>
        </member>
        <member name="F:NewLife.Net.TDP.TDPFlags.RST">
            <summary>重建连接。</summary>
        </member>
        <member name="F:NewLife.Net.TDP.TDPFlags.PSH">
            <summary>接收方应该尽快将这个报文段交给应用层。</summary>
        </member>
        <member name="F:NewLife.Net.TDP.TDPFlags.ACK">
            <summary>确认序号有效。</summary>
        </member>
        <member name="F:NewLife.Net.TDP.TDPFlags.LIV">
            <summary>连接保活标志，用于表示TDP 连接通路存活状态。</summary>
        </member>
        <member name="T:NewLife.Net.TDP.TDPPacket">
            <summary>TDP协议包</summary>
            <remarks>
            TDP，在UDP上实现TCP。
            </remarks>
        </member>
        <member name="F:NewLife.Net.TDP.TDPPacket._Data">
            <summary>包括4位首部长度，保留6位，还有6位标志位</summary>
        </member>
        <member name="P:NewLife.Net.TDP.TDPPacket.Length">
            <summary>头部长度</summary>
        </member>
        <member name="P:NewLife.Net.TDP.TDPPacket.Flag">
            <summary>标记</summary>
        </member>
        <member name="P:NewLife.Net.TDP.TDPPacket.WindowSize">
            <summary>16位窗口大小</summary>
        </member>
        <member name="P:NewLife.Net.TDP.TDPPacket.SequenceNumber">
            <summary>序列号</summary>
        </member>
        <member name="P:NewLife.Net.TDP.TDPPacket.AckNumber">
            <summary>确认序列号</summary>
        </member>
        <member name="T:NewLife.Net.UPnP.Device">
            <summary>设备</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.deviceType">
            <summary>设备类型</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.presentationURL">
            <summary>管理网址</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.friendlyName">
            <summary>对于用户的简短描述</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.manufacturer">
            <summary>生产厂家</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.manufacturerURL">
            <summary>制造商的网址</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.modelDescription">
            <summary>描述</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.modelName">
            <summary>产品名称</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.modelNumber">
            <summary>产品型号</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.UDN">
            <summary>唯一设备名称</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.UPC">
            <summary>通用产品编码缩写</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.serviceList">
            <summary>服务项目</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Device.deviceList">
            <summary>设备 仅当根设备带有嵌入式设备时要求</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.Device.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.Device.GetService(System.String)">
            <summary>获取指定设备指定类型的服务</summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.Device.GetWANIPService">
            <summary>取得广域网IP连接设备</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.Envelope">
            <summary>端口映射结构</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Envelope.Body">
            <summary>属性说明</summary>
        </member>
        <member name="T:NewLife.Net.UPnP.Envelope.EnvelopeBody">
            <summary>信封主体</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Envelope.EnvelopeBody.Xml">
            <summary>Xml文档</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Envelope.EnvelopeBody.Fault">
            <summary>失败</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.Envelope.EnvelopeBody.GetSchema">
            <summary>获取架构</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.Envelope.EnvelopeBody.ReadXml(System.Xml.XmlReader)">
            <summary>读取Xml</summary>
            <param name="reader"></param>
        </member>
        <member name="M:NewLife.Net.UPnP.Envelope.EnvelopeBody.WriteXml(System.Xml.XmlWriter)">
            <summary>写入Xml</summary>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.Net.UPnP.Envelope.EnvelopeBody.ThrowException">
            <summary>抛出异常</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.InternetGatewayDevice">
            <summary>因特网网关设备</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.InternetGatewayDevice.specVersion">
            <summary>UPnP 设备架构版本</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.InternetGatewayDevice.URLBase">
            <summary>URL</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.InternetGatewayDevice.device">
            <summary>设备</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.InternetGatewayDevice.ServerHost">
            <summary>UPNP设备IP</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.InternetGatewayDevice.ServerPort">
            <summary>UPNP设备端口</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.GetHOSTAndPort">
            <summary>分析URLBase 并赋值HOST和Port</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.Add(System.String,System.Int32,System.String,System.Int32,System.String,System.Int32,System.String,System.Int32)">
            <summary>添加映射端口</summary>
            <param name="remoteHost">远程主机</param>
            <param name="externalPort">外部端口</param>
            <param name="protocol">TCP或UDP</param>
            <param name="internalPort">内部端口</param>
            <param name="internalClient">本地IP地址</param>
            <param name="enabled">是否启用[0,1]</param>
            <param name="description">端口映射的描述</param>
            <param name="duration">映射的持续时间，用0表示永久</param>
            <returns>bool</returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.Add(System.String,System.Int32,System.String,System.String)">
            <summary>添加映射端口</summary>
            <param name="host">本地主机</param>
            <param name="port">端口（内外一致）</param>
            <param name="protocol">协议</param>
            <param name="description">描述</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.Delete(System.String,System.Int32,System.String)">
            <summary>删除端口映射</summary>
            <param name="remoteHost">远程主机</param>
            <param name="externalPort">外部端口</param>
            <param name="protocol">TCP或UDP</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.GetMapByPortAndProtocol(System.String,System.Int32,System.String)">
            <summary>获取指定设备的端口映射信息</summary>
            <param name="remoteHost">远程主机</param>
            <param name="externalPort">外部端口</param>
            <param name="protocol">TCP/UDP</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.GetMapByIndex(System.Int32)">
            <summary>获取指定设备的端口映射信息</summary>
            <param name="index">索引</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.GetMapByIndexAll">
            <summary>获取指定设备的所有端口映射信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.Request``1(NewLife.Net.UPnP.UPnPAction)">
            <summary>向设备发送指令</summary>
            <typeparam name="TResponse"></typeparam>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Net.UPnP.InternetGatewayDevice.SOAP_HEADER">
            <summary>SOAP头部</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.InternetGatewayDevice.SOAPRequest(System.Uri,System.String,System.String)">
            <summary>发送SOAP请求，发送xml，返回xml</summary>
            <param name="uri"></param>
            <param name="action"></param>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.PortMappingEntryRequest">
            <summary>端口映射实体</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntryRequest.NewPortMappingIndex">
            <summary>索引</summary>
        </member>
        <member name="T:NewLife.Net.UPnP.PortMappingEntry">
            <summary>端口映射实体</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.RemoteHost">
            <summary>远程主机</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.ExternalPort">
            <summary>外部端口</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.Protocol">
            <summary>TCP/UDP</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.InternalPort">
            <summary>内部端口</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.InternalClient">
            <summary>主机IP</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.Enabled">
            <summary>是否启用</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.Description">
            <summary>描述</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.PortMappingEntry.LeaseDuration">
            <summary>有效期</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.PortMappingEntry.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.Service">
            <summary>服务项</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Service.serviceType">
            <summary>UPnP 服务类型。不得包含散列符</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Service.serviceId">
            <summary>服务标识符</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Service.controlURL">
            <summary>控制网址</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Service.eventSubURL">
            <summary>事件的URL</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.Service.SCPDURL">
            <summary>服务描述的URL</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.Service.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.SpecVersion">
            <summary>SpecVersion</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.SpecVersion.major">
            <summary>UPnP 设备架构主版本</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.SpecVersion.minor">
            <summary>UPnP 设备架构副版本</summary>
        </member>
        <member name="T:NewLife.Net.UPnP.UPnPAction`1">
            <summary>UPnP操作</summary>
            <typeparam name="TEntity"></typeparam>
        </member>
        <member name="M:NewLife.Net.UPnP.UPnPAction`1.FromXml(System.String)">
            <summary>XML反序列化为实体</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.UPnPAction">
            <summary>UPnP操作</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.UPnPAction.Name">
            <summary>名称</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.UPnPAction.ToXml(System.String)">
            <summary>序列化实体为Xml</summary>
            <param name="xmlns"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UPnP.UPnPAction.ToSoap(System.String)">
            <summary>序列化实体为Soap</summary>
            <param name="xmlns"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UPnP.UPnPClient">
            <summary>通用即插即用协议客户端</summary>
            <remarks>
            UPnP 是各种各样的智能设备、无线设备和个人电脑等实现遍布全球的对等网络连接（P2P）的结构。UPnP 是一种分布式的，开放的网络架构。UPnP 是独立的媒介。
            
            <a target="_blank" href="http://baike.baidu.com/view/27925.htm">UPnP</a>
            </remarks>
            <example>
            <code>
            UPnPClient client = new UPnPClient();
            client.OnNewDevice += new EventHandler&lt;NewLife.EventArgs&lt;InternetGatewayDevice, bool&gt;&gt;(client_OnNewDevice);
            client.StartDiscover();
            
            static void client_OnNewDevice(object sender, EventArgs&lt;InternetGatewayDevice, bool&gt; e)
            {
                Console.WriteLine("{0}{1}", e.Arg1, e.Arg2 ? " [缓存]" : "");
                if (e.Arg2) return;
            
                foreach (var item in e.Arg1.GetMapByIndexAll())
                {
                    Console.WriteLine(item);
                }
            }
            </code>
            </example>
        </member>
        <member name="P:NewLife.Net.UPnP.UPnPClient.Udp">
            <summary>Udp客户端，用于发现网关设备</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.UPnPClient.Gateways">
            <summary>网关设备</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.UPnPClient.Dispose(System.Boolean)">
            <summary>释放资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.UPnP.UPnPClient.StartDiscover">
            <summary>开始</summary>
        </member>
        <member name="E:NewLife.Net.UPnP.UPnPClient.OnNewDevice">
            <summary>发现新设备时触发。参数（设备，是否来自缓存）</summary>
        </member>
        <member name="M:NewLife.Net.UPnP.UPnPClient.CheckCacheGateway">
            <summary>检查缓存的网关</summary>
        </member>
        <member name="P:NewLife.Net.UPnP.UPnPClient.CacheGateway">
            <summary>是否缓存网关。缓存网关可以加速UPnP的发现过程</summary>
        </member>
        <member name="T:NewLife.NetHelper">
            <summary>网络工具类</summary>
        </member>
        <member name="M:NewLife.NetHelper.SetTcpKeepAlive(System.Net.Sockets.Socket,System.Boolean,System.Int32,System.Int32)">
            <summary>设置超时检测时间和检测间隔</summary>
            <param name="socket">要设置的Socket对象</param>
            <param name="iskeepalive">是否启用Keep-Alive</param>
            <param name="starttime">多长时间后开始第一次探测（单位：毫秒）</param>
            <param name="interval">探测时间间隔（单位：毫秒）</param>
        </member>
        <member name="M:NewLife.NetHelper.ParseAddress(System.String)">
            <summary>分析地址，根据IP或者域名得到IP地址，缓存60秒，异步更新</summary>
            <param name="hostname"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.ParseEndPoint(System.String,System.Int32)">
            <summary>分析网络终结点</summary>
            <param name="address">地址，可以不带端口</param>
            <param name="defaultPort">地址不带端口时指定的默认端口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetRightAny(System.Net.IPAddress,System.Net.Sockets.AddressFamily)">
            <summary>针对IPv4和IPv6获取合适的Any地址</summary>
            <remarks>除了Any地址以为，其它地址不具备等效性</remarks>
            <param name="address"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsAny(System.Net.IPAddress)">
            <summary>是否Any地址，同时处理IPv4和IPv6</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsAny(System.Net.EndPoint)">
            <summary>是否Any结点</summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsIPv4(System.Net.IPAddress)">
            <summary>是否IPv4地址</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IsLocal(System.Net.IPAddress)">
            <summary>是否本地地址</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetRelativeAddress(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>获取相对于指定远程地址的本地地址</summary>
            <param name="address"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetRelativeEndPoint(System.Net.IPEndPoint,System.Net.IPAddress)">
            <summary>获取相对于指定远程地址的本地地址</summary>
            <param name="local"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CheckPort(System.Net.IPAddress,NewLife.Net.NetType,System.Int32)">
            <summary>指定地址的指定端口是否已被使用，似乎没办法判断IPv6地址</summary>
            <param name="protocol"></param>
            <param name="address"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CheckPort(NewLife.Net.NetUri)">
            <summary>检查该协议的地址端口是否已经呗使用</summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetActiveInterfaces">
            <summary>获取活动的接口信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetDhcps">
            <summary>获取可用的DHCP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetDns">
            <summary>获取可用的DNS地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetGateways">
            <summary>获取可用的网关地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetIPs">
            <summary>获取可用的IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetIPsWithCache">
            <summary>获取本机可用IP地址，缓存60秒，异步更新</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetMulticasts">
            <summary>获取可用的多播地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetMacs">
            <summary>获取所有物理网卡MAC地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.GetMac">
            <summary>获取网卡MAC地址（网关所在网卡）</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.MyIP">
            <summary>获取本地第一个IPv4地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.MyIPv6">
            <summary>获取本地第一个IPv6地址</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.Wake(System.String[])">
            <summary>唤醒指定MAC地址的计算机</summary>
            <param name="macs"></param>
        </member>
        <member name="M:NewLife.NetHelper.GetMac(System.Net.IPAddress)">
            <summary>根据IP地址获取MAC地址</summary>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.NetHelper.IpProvider">
            <summary>IP地址提供者</summary>
        </member>
        <member name="M:NewLife.NetHelper.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址的物理地址位置</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.IPToAddress(System.String)">
            <summary>根据字符串形式IP地址转为物理地址</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.NetHelper.IPProvider">
            <summary>IP地址提供者</summary>
        </member>
        <member name="M:NewLife.NetHelper.IPProvider.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址的物理地址位置</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CreateClient(NewLife.Net.NetUri)">
            <summary>根据本地网络标识创建客户端</summary>
            <param name="local"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.NetHelper.CreateRemote(NewLife.Net.NetUri)">
            <summary>根据远程网络标识创建客户端</summary>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.AssemblyX">
            <summary>程序集辅助类。使用Create创建，保证每个程序集只有一个辅助类</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Asm">
            <summary>程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Version">
            <summary>程序集版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Title">
            <summary>程序集标题</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.FileVersion">
            <summary>文件版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Compile">
            <summary>编译时间</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.CompileVersion">
            <summary>编译版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Company">
            <summary>公司名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Location">
            <summary>获取包含清单的已加载文件的路径或 UNC 位置。</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Create(System.Reflection.Assembly)">
            <summary>创建程序集辅助对象</summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Types">
            <summary>类型集合，当前程序集的所有类型，包括私有和内嵌，非内嵌请直接调用Asm.GetTypes()</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.IsSystemAssembly">
            <summary>是否系统程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Entry">
            <summary>入口程序集</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String)">
            <summary>从程序集中查找指定名称的类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetTypeInternal(System.String)">
            <summary>在程序集中查找类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies(System.AppDomain)">
            <summary>获取指定程序域所有程序集</summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.AssemblyPaths">
            <summary>程序集目录集合</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyGetAssemblies">
            <summary>获取当前程序域所有只反射程序集的辅助类</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoad(System.String)">
            <summary>只反射加载指定路径的所有程序集</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoadFrom(System.String,System.Version)">
            <summary>只反射加载指定路径的所有程序集</summary>
            <param name="file"></param>
            <param name="ver"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetMyAssemblies">
            <summary>获取当前应用程序的所有程序集，不包括系统程序集，仅限本目录</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.OnResolve(System.String)">
            <summary>在对程序集的解析失败时发生</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetCompileTime(System.String)">
            <summary>根据版本号计算得到编译时间</summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DynamicInternal">
            <summary>包装程序集内部类的动态对象</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
            <summary>类型转换</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>成员取值</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>调用成员</summary>
            <param name="binder"></param>
            <param name="args"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.Wrap(System.Object)">
            <summary>包装</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DynamicXml">
            <summary>动态Xml</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicXml.Node">
            <summary>节点</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor(System.Xml.Linq.XElement)">
            <summary>实例化</summary>
            <param name="node"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>设置</summary>
            <param name="binder"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>获取</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.IIndexAccessor">
            <summary>
            索引器接访问口。
            该接口用于通过名称快速访问对象属性或字段（属性优先）。
            </summary>
        </member>
        <member name="P:NewLife.Reflection.IIndexAccessor.Item(System.String)">
            <summary>获取/设置 指定名称的属性或字段的值</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.IReflect">
            <summary>反射接口</summary>
            <remarks>该接口仅用于扩展，不建议外部使用</remarks>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMethods(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetProperty(System.Type,System.String,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetField(System.Type,System.String,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMember(System.Type,System.String,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetFields(System.Type,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetValue(System.Object,System.Reflection.PropertyInfo)">
            <summary>获取目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetValue(System.Object,System.Reflection.FieldInfo)">
            <summary>获取目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.SetValue(System.Object,System.Reflection.PropertyInfo,System.Object)">
            <summary>设置目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.SetValue(System.Object,System.Reflection.FieldInfo,System.Object)">
            <summary>设置目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.As(System.Type,System.Type)">
            <summary>是否能够转为指定基类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类或接口的所有子类实现</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口，为空时返回所有类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetAllSubclasses(System.Type)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DefaultReflect">
            <summary>默认反射实现</summary>
            <remarks>该接口仅用于扩展，不建议外部使用</remarks>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMethods(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetProperty(System.Type,System.String,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetField(System.Type,System.String,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMember(System.Type,System.String,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetFields(System.Type,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetValue(System.Object,System.Reflection.PropertyInfo)">
            <summary>获取目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetValue(System.Object,System.Reflection.FieldInfo)">
            <summary>获取目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.SetValue(System.Object,System.Reflection.PropertyInfo,System.Object)">
            <summary>设置目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.SetValue(System.Object,System.Reflection.FieldInfo,System.Object)">
            <summary>设置目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.As(System.Type,System.Type)">
            <summary>是否子类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类的子类</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口，为空时返回所有类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetAllSubclasses(System.Type)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Reflect">
            <summary>反射工具类</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/reflect
            </remarks>
        </member>
        <member name="P:NewLife.Reflection.Reflect.Provider">
            <summary>当前反射提供者</summary>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeEx(System.String,System.Boolean)">
            <summary>根据名称获取类型。可搜索当前目录DLL，自动加载</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMethodEx(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMethodsEx(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetPropertyEx(System.Type,System.String,System.Boolean)">
            <summary>获取属性。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetFieldEx(System.Type,System.String,System.Boolean)">
            <summary>获取字段。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMemberEx(System.Type,System.String,System.Boolean)">
            <summary>获取成员。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetFields(System.Type,System.Boolean)">
            <summary>获取用于序列化的字段</summary>
            <remarks>过滤<seealso cref="T:NonSerializedAttribute"/>特性的字段</remarks>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取用于序列化的属性</summary>
            <remarks>过滤<seealso cref="T:XmlIgnoreAttribute"/>特性的属性和索引器</remarks>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Invoke(System.Object,System.String,System.Object[])">
            <summary>反射调用指定对象的方法。target为类型时调用其静态方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="name">方法名</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.TryInvoke(System.Object,System.String,System.Object@,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="name">方法名</param>
            <param name="value">数值</param>
            <param name="parameters">方法参数</param>
            <remarks>反射调用是否成功</remarks>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetValue(System.Object,System.String,System.Boolean)">
            <summary>获取目标对象指定名称的属性/字段值</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="throwOnError">出错时是否抛出异常</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.TryGetValue(System.Object,System.String,System.Object@)">
            <summary>获取目标对象指定名称的属性/字段值</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns>是否成功获取数值</returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetValue(System.Object,System.Reflection.MemberInfo)">
            <summary>获取目标对象的成员值</summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.SetValue(System.Object,System.String,System.Object)">
            <summary>设置目标对象指定名称的属性/字段值，若不存在返回false</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <remarks>反射调用是否成功</remarks>
        </member>
        <member name="M:NewLife.Reflection.Reflect.SetValue(System.Object,System.Reflection.MemberInfo,System.Object)">
            <summary>设置目标对象的成员值</summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetElementTypeEx(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.ChangeType``1(System.Object)">
            <summary>类型转换</summary>
            <typeparam name="TResult"></typeparam>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeArray(System.Object[])">
            <summary>从参数数组中获取类型数组</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMemberType(System.Reflection.MemberInfo)">
            <summary>获取成员的类型，字段和属性是它们的类型，方法是返回类型，类型是自身</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeCode(System.Type)">
            <summary>获取类型代码</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsInt(System.Type)">
            <summary>是否整数</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsList(System.Type)">
            <summary>是否泛型列表</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsDictionary(System.Type)">
            <summary>是否泛型字典</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As(System.Type,System.Type)">
            <summary>是否能够转为指定基类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As``1(System.Type)">
            <summary>是否能够转为指定基类</summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类的子类</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetAllSubclasses(System.Type)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetType(System.Object@)">
            <summary>获取类型，如果target是Type类型，则表示要反射的是静态成员</summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As``1(System.Reflection.MethodInfo,System.Object)">
            <summary>把一个方法转为泛型委托，便于快速反射调用</summary>
            <typeparam name="TFunc"></typeparam>
            <param name="method"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.AttributeX">
            <summary>特性辅助类</summary>
        </member>
        <member name="M:NewLife.AttributeX.GetCustomAttributes``1(System.Reflection.Assembly)">
            <summary>获取自定义属性，带有缓存功能，避免因.Net内部GetCustomAttributes没有缓存而带来的损耗</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetDisplayName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取成员绑定的显示名</summary>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetDescription(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取成员绑定的备注</summary>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetCustomAttributeValue``2(System.Reflection.Assembly)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.AttributeX.GetCustomAttributeValue``2(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="target">目标对象</param>
            <param name="inherit">是否递归</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiAction">
            <summary>Api动作</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Name">
            <summary>动作名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Type">
            <summary>动作所在类型</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Method">
            <summary>方法</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Controller">
            <summary>控制器对象</summary>
            <remarks>如果指定控制器对象，则每次调用前不再实例化对象</remarks>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.IsPacketParameter">
            <summary>是否二进制参数</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.IsPacketReturn">
            <summary>是否二进制返回</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.StatProcess">
            <summary>处理统计</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.LastSession">
            <summary>最后会话</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiAction.#ctor(System.Reflection.MethodInfo,System.Type,System.String)">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiAction.GetName(System.Type,System.Reflection.MethodInfo,System.String)">
            <summary>获取名称</summary>
            <param name="type"></param>
            <param name="method"></param>
            <param name="defaultrouter">默认路由名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiAction.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiAttribute">
            <summary>标识Api</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAttribute.Name">
            <summary>名称</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiAttribute.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="name"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiClient">
            <summary>应用接口客户端</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Active">
            <summary>是否已打开</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Servers">
            <summary>服务端地址集合。负载均衡</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Cluster">
            <summary>客户端连接集群</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.UsePool">
            <summary>是否使用连接池。true时建立多个到服务端的连接（高吞吐），默认false使用单一连接（低延迟）</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Token">
            <summary>令牌。每次请求携带</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.StatInvoke">
            <summary>调用统计</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Tracer">
            <summary>性能跟踪器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.#ctor">
            <summary>实例化应用接口客户端</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.#ctor(System.String)">
            <summary>实例化应用接口客户端</summary>
            <param name="uris">服务端地址集合，逗号分隔</param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Open">
            <summary>打开客户端</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InitCluster">
            <summary>初始化集群</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InvokeAsync``1(System.String,System.Object)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult">返回类型</typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Invoke``1(System.String,System.Object)">
            <summary>同步调用，阻塞等待</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InvokeOneWay(System.String,System.Object,System.Byte)">
            <summary>单向发送。同步调用，不等待返回</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InvokeWithClientAsync``1(NewLife.Net.ISocketClient,System.String,System.Object,System.Byte)">
            <summary>指定客户端的异步调用，等待返回结果</summary>
            <remarks>常用于在OnLoginAsync中实现连接后登录功能</remarks>
            <typeparam name="TResult"></typeparam>
            <param name="client">客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Invoke(System.Object,System.String,System.Object,System.Byte)">
            <summary>调用</summary>
            <param name="session"></param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnReceive(NewLife.Messaging.IMessage)">
            <summary>客户端收到服务端主动下发消息</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnNewSession(NewLife.Net.ISocketClient)">
            <summary>新会话。客户端每次连接或断线重连后，可用InvokeWithClientAsync做登录</summary>
            <param name="client">会话</param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnLoginAsync(NewLife.Net.ISocketClient,System.Boolean)">
            <summary>连接后自动登录</summary>
            <param name="client">客户端</param>
            <param name="force">强制登录</param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.LoginAsync">
            <summary>登录</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnCreate(System.String)">
            <summary>创建客户端之后，打开连接之前</summary>
            <param name="svr"></param>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.StatPeriod">
            <summary>显示统计信息的周期。默认600秒，0表示不显示统计信息</summary>
        </member>
        <member name="T:NewLife.Remoting.ApiException">
            <summary>远程调用异常</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiException.Code">
            <summary>代码</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiException.#ctor(System.Int32,System.String)">
            <summary>实例化远程调用异常</summary>
            <param name="code"></param>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiException.#ctor(System.Int32,System.Exception)">
            <summary>实例化远程调用异常</summary>
            <param name="code"></param>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiHost">
            <summary>Api主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Encoder">
            <summary>编码器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Timeout">
            <summary>调用超时时间。请求发出后，等待响应的最大时间，默认15_000ms</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.SlowTrace">
            <summary>慢追踪。远程调用或处理时间超过该值时，输出慢调用日志，默认5000ms</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.StartTime">
            <summary>启动时间</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.GetMessageCodec">
            <summary>获取消息编码器。重载以指定不同的封包协议</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Log">
            <summary>日志</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.EncoderLog">
            <summary>编码器日志</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.ShowError">
            <summary>显示调用和处理错误。默认false</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.ToString">
            <summary>已重载。返回具有本类特征的字符串</summary>
            <returns>String</returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHttpServer.Init(System.Object,NewLife.Remoting.IApiHost)">
            <summary>初始化</summary>
            <param name="config"></param>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiNetServer.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetServer.AllSessions">
            <summary>当前服务器所有会话</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiNetServer.Init(System.Object,NewLife.Remoting.IApiHost)">
            <summary>初始化</summary>
            <param name="config"></param>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.NewLife#Remoting#IApiSession#Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.AllSessions">
            <summary>所有服务器所有会话，包含自己</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.Token">
            <summary>令牌</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.Items2">
            <summary>第二会话数据</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.Item(System.String)">
            <summary>获取/设置 用户会话数据。优先使用第二会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.Start">
            <summary>开始会话处理</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.FindAction(System.String)">
            <summary>查找Api动作</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.CreateController(NewLife.Remoting.ApiAction)">
            <summary>创建控制器实例</summary>
            <param name="api"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.InvokeOneWay(System.String,System.Object,System.Byte)">
            <summary>单向远程调用，无需等待返回</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiServer">
            <summary>应用接口服务器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Active">
            <summary>是否正在工作</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Server">
            <summary>服务器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Multiplex">
            <summary>连接复用。默认true，单个Tcp连接在处理某个请求未完成时，可以接收并处理新的请求</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.UseHttpStatus">
            <summary>是否使用Http状态。默认false，使用json包装响应码</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.StatProcess">
            <summary>处理统计</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Tracer">
            <summary>性能跟踪器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.#ctor">
            <summary>实例化一个应用接口服务器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.#ctor(System.Int32)">
            <summary>使用指定端口实例化网络服务应用接口提供者</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.#ctor(NewLife.Net.NetUri)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Dispose(System.Boolean)">
            <summary>销毁时停止服务</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Manager">
            <summary>接口动作管理器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Register``1">
            <summary>注册服务提供类。该类的所有公开方法将直接暴露</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Register(System.Object,System.String)">
            <summary>注册服务</summary>
            <param name="controller">控制器对象</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.ShowService">
            <summary>显示可用服务</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Use(NewLife.Net.NetUri)">
            <summary>添加服务器</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.EnsureCreate">
            <summary>确保已创建服务器对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Start">
            <summary>开始服务</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Stop(System.String)">
            <summary>停止服务</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Process(NewLife.Remoting.IApiSession,NewLife.Messaging.IMessage)">
            <summary>处理会话收到的消息，并返回结果消息</summary>
            <remarks>
            这里是网络RPC的消息处理核心，目标协议只要能封装为IMessage，即可通过重载该方法得到支持
            </remarks>
            <param name="session">网络会话</param>
            <param name="msg">消息</param>
            <returns>要应答对方的消息，为空表示不应答</returns>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.OnProcess(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>执行消息处理，交给Handler</summary>
            <param name="session">会话</param>
            <param name="action">动作</param>
            <param name="args">参数</param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.StatPeriod">
            <summary>显示统计信息的周期。默认600秒，0表示不显示统计信息</summary>
        </member>
        <member name="T:NewLife.Remoting.ClientPoolCluster">
            <summary>客户端连接池负载均衡集群</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientPoolCluster.Current">
            <summary>最后使用资源</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientPoolCluster.GetItems">
            <summary>服务器地址列表</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientPoolCluster.OnCreate">
            <summary>创建回调</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientPoolCluster.Pool">
            <summary>连接池</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.#ctor">
            <summary>实例化连接池集群</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.Get">
            <summary>从集群中获取资源</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.Put(NewLife.Net.ISocketClient)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="F:NewLife.Remoting.ClientPoolCluster._index">
            <summary>Round-Robin 负载均衡</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.CreateClient">
            <summary>为连接池创建连接</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.MyPool.OnPut(NewLife.Net.ISocketClient)">
            <summary>释放时，返回是否有效。无效对象将会被抛弃</summary>
            <param name="value"></param>
        </member>
        <member name="P:NewLife.Remoting.ClientPoolCluster.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientPoolCluster.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.ClientSingleCluster">
            <summary>客户端单连接故障转移集群</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientSingleCluster.Current">
            <summary>最后使用资源</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientSingleCluster.GetItems">
            <summary>服务器地址列表</summary>
        </member>
        <member name="P:NewLife.Remoting.ClientSingleCluster.OnCreate">
            <summary>创建回调</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientSingleCluster.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientSingleCluster.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Remoting.ClientSingleCluster.Get">
            <summary>从集群中获取资源</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ClientSingleCluster.Put(NewLife.Net.ISocketClient)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="F:NewLife.Remoting.ClientSingleCluster._index">
            <summary>Round-Robin 负载均衡</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientSingleCluster.CreateClient">
            <summary>为连接池创建连接</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ClientSingleCluster.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Remoting.ClientSingleCluster.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiController">
            <summary>API控制器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiController.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiController.Session">
            <summary>会话</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiController.All">
            <summary>获取所有接口</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiController.Info(System.String)">
            <summary>服务器信息，用户健康检测</summary>
            <param name="state">状态信息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiController.Info2(NewLife.Data.Packet)">
            <summary>服务器信息，用户健康检测，二进制压测</summary>
            <param name="state">状态信息</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ControllerContext">
            <summary>控制器上下文</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Controller">
            <summary>控制器实例</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Action">
            <summary>处理动作</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.ActionName">
            <summary>真实动作名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Session">
            <summary>会话</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.ActionParameters">
            <summary>获取或设置操作方法参数。</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Result">
            <summary>获取或设置由操作方法返回的结果。</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Exception">
            <summary>获取或设置在操作方法的执行过程中发生的异常（如果有）。</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.ExceptionHandled">
            <summary>获取或设置一个值，该值指示是否处理异常。</summary>
        </member>
        <member name="M:NewLife.Remoting.ControllerContext.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Current">
            <summary>当前线程上下文</summary>
        </member>
        <member name="M:NewLife.Remoting.ControllerContext.Reset">
            <summary>重置为默认状态</summary>
        </member>
        <member name="T:NewLife.Remoting.IActionFilter">
            <summary>定义操作筛选器中使用的方法。</summary>
        </member>
        <member name="M:NewLife.Remoting.IActionFilter.OnActionExecuting(NewLife.Remoting.ControllerContext)">
            <summary>在执行操作方法之前调用。</summary>
            <param name="filterContext"></param>
        </member>
        <member name="M:NewLife.Remoting.IActionFilter.OnActionExecuted(NewLife.Remoting.ControllerContext)">
            <summary>在执行操作方法后调用。</summary>
            <param name="filterContext"></param>
        </member>
        <member name="T:NewLife.Remoting.IApi">
            <summary>Api接口</summary>
            <remarks>
            在基于令牌Token的无状态验证模式中，可以借助Token重写IApiHandler.Prepare，来达到同一个Token共用相同的IApiSession.Items
            </remarks>
        </member>
        <member name="P:NewLife.Remoting.IApi.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Remoting.IApiClient">
            <summary>应用接口客户端接口</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiClient.Token">
            <summary>令牌。每次请求携带</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiClient.Invoke``1(System.String,System.Object)">
            <summary>同步调用，阻塞等待</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiClient.InvokeAsync``1(System.String,System.Object)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult"></typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IApiHandler">
            <summary>Api处理器</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiHandler.Execute(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>执行</summary>
            <param name="session">会话</param>
            <param name="action">动作</param>
            <param name="args">参数</param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiHandler">
            <summary>默认处理器</summary>
            <remarks>
            在基于令牌Token的无状态验证模式中，可以借助Token重写IApiHandler.Prepare，来达到同一个Token共用相同的IApiSession.Items
            </remarks>
        </member>
        <member name="P:NewLife.Remoting.ApiHandler.Host">
            <summary>Api接口主机</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHandler.Execute(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>执行</summary>
            <param name="session">会话</param>
            <param name="action">动作</param>
            <param name="args">参数</param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHandler.Prepare(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet,NewLife.Remoting.ApiAction,NewLife.Messaging.IMessage)">
            <summary>准备上下文，可以借助Token重写Session会话集合</summary>
            <param name="session"></param>
            <param name="action"></param>
            <param name="args"></param>
            <param name="api"></param>
            <param name="msg">消息内容，辅助数据解析</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHandler.GetParams(System.Reflection.MethodInfo,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Remoting.IEncoder)">
            <summary>获取参数</summary>
            <param name="method"></param>
            <param name="args"></param>
            <param name="encoder"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.TokenApiHandler">
            <summary>带令牌会话的处理器</summary>
            <remarks>
            在基于令牌Token的无状态验证模式中，可以借助Token重写IApiHandler.Prepare，来达到同一个Token共用相同的IApiSession.Items。
            支持内存缓存和Redis缓存。
            </remarks>
        </member>
        <member name="P:NewLife.Remoting.TokenApiHandler.Cache">
            <summary>会话存储</summary>
        </member>
        <member name="M:NewLife.Remoting.TokenApiHandler.Prepare(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet,NewLife.Remoting.ApiAction,NewLife.Messaging.IMessage)">
            <summary>准备上下文，可以借助Token重写Session会话集合</summary>
            <param name="session"></param>
            <param name="action"></param>
            <param name="args"></param>
            <param name="api"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.TokenApiHandler.GetKey(System.String)">
            <summary>根据令牌活期缓存Key</summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IApiHost">
            <summary>Api主机</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.Encoder">
            <summary>编码器</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiHost.GetMessageCodec">
            <summary>获取消息编码器。重载以指定不同的封包协议</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiHost.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.IApiManager">
            <summary>接口管理器</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiManager.Services">
            <summary>可提供服务的方法</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Register``1">
            <summary>注册服务提供类。该类的所有公开方法将直接暴露</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Register(System.Object,System.String)">
            <summary>注册服务</summary>
            <param name="controller">控制器对象</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Find(System.String)">
            <summary>查找服务</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiManager.Services">
            <summary>可提供服务的方法</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Register``1">
            <summary>注册服务提供类。该类的所有公开方法将直接暴露</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Register(System.Object,System.String)">
            <summary>注册服务</summary>
            <param name="controller">控制器对象</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Find(System.String)">
            <summary>查找服务</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IApiServer">
            <summary>应用接口服务器接口</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiServer.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiServer.AllSessions">
            <summary>当前服务器所有会话</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiServer.Init(System.Object,NewLife.Remoting.IApiHost)">
            <summary>初始化</summary>
            <param name="config"></param>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="P:NewLife.Remoting.IApiServer.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Remoting.IApiSession">
            <summary>Api会话</summary>
            <remarks>
            在基于令牌Token的无状态验证模式中，可以借助Token重写IApiHandler.Prepare，来达到同一个Token共用相同的IApiSession.Items
            </remarks>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.AllSessions">
            <summary>所有服务器所有会话，包含自己</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.Token">
            <summary>令牌</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.FindAction(System.String)">
            <summary>查找Api动作</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.CreateController(NewLife.Remoting.ApiAction)">
            <summary>创建控制器实例</summary>
            <param name="api"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.InvokeOneWay(System.String,System.Object,System.Byte)">
            <summary>单向远程调用，无需等待返回</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IEncoder">
            <summary>编码器</summary>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.CreateRequest(System.String,System.Object)">
            <summary>创建请求</summary>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.CreateResponse(NewLife.Messaging.IMessage,System.String,System.Int32,System.Object)">
            <summary>创建响应</summary>
            <param name="msg"></param>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.Decode(NewLife.Messaging.IMessage,System.String@,System.Int32@,NewLife.Data.Packet@)">
            <summary>解码 请求/响应</summary>
            <param name="msg">消息</param>
            <param name="action">服务动作</param>
            <param name="code">错误码</param>
            <param name="value">参数或结果</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.DecodeParameters(System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>解码参数</summary>
            <param name="action">动作</param>
            <param name="data">数据</param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.DecodeResult(System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>解码结果</summary>
            <param name="action"></param>
            <param name="data"></param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.Convert(System.Object,System.Type)">
            <summary>转换为目标类型</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.IEncoder.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="T:NewLife.Remoting.EncoderBase">
            <summary>编码器基类</summary>
        </member>
        <member name="M:NewLife.Remoting.EncoderBase.Decode(NewLife.Messaging.IMessage,System.String@,System.Int32@,NewLife.Data.Packet@)">
            <summary>解码 请求/响应</summary>
            <param name="msg">消息</param>
            <param name="action">服务动作</param>
            <param name="code">错误码</param>
            <param name="value">参数或结果</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.EncoderBase.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Remoting.EncoderBase.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.JsonEncoder">
            <summary>Json编码器</summary>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.Encode(System.String,System.Int32,NewLife.Data.Packet)">
            <summary>编码。请求/响应</summary>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.DecodeParameters(System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>解码参数</summary>
            <param name="action">动作</param>
            <param name="data">数据</param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.DecodeResult(System.String,NewLife.Data.Packet,NewLife.Messaging.IMessage)">
            <summary>解码结果</summary>
            <param name="action"></param>
            <param name="data"></param>
            <param name="msg">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.Convert(System.Object,System.Type)">
            <summary>转换为目标类型</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.CreateRequest(System.String,System.Object)">
            <summary>创建请求</summary>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.CreateResponse(NewLife.Messaging.IMessage,System.String,System.Int32,System.Object)">
            <summary>创建响应</summary>
            <param name="msg"></param>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Asn1">
            <summary>抽象语法标记。ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式。</summary>
        </member>
        <member name="P:NewLife.Security.Asn1.Tag">
            <summary>标签</summary>
        </member>
        <member name="P:NewLife.Security.Asn1.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Security.Asn1.Value">
            <summary>数值</summary>
        </member>
        <member name="M:NewLife.Security.Asn1.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.GetOids">
            <summary>获取OID</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.Read(System.Byte[])">
            <summary>读取</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.Read(System.IO.Stream)">
            <summary>读取</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.Read(System.IO.BinaryReader)">
            <summary>读取对象</summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.GetByteArray(System.Boolean)">
            <summary>获取字节数组</summary>
            <param name="trimZero"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Asn1.ReadTLV(System.IO.BinaryReader,System.Byte@)">
            <summary>读取TLV，Tag+Length+Value</summary>
            <param name="reader">读取器</param>
            <param name="tag"></param>
            <returns>返回长度，数据流指针移到Value第一个字节</returns>
        </member>
        <member name="M:NewLife.Security.Asn1.ReadTLV(System.IO.BinaryReader,System.Boolean)">
            <summary>读取TLV，Tag+Length+Value</summary>
            <param name="reader">读取器</param>
            <param name="trimZero">是否剔除头部的0x00</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Asn1Tags">
            <summary>ASN.1标签</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Boolean">
            <summary>布尔</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Integer">
            <summary>长整数</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.BitString">
            <summary>比特串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.OctetString">
            <summary>字节串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Null">
            <summary>空</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.ObjectIdentifier">
            <summary>OID实体标识符</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.External">
            <summary>外部</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Enumerated">
            <summary>枚举</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Sequence">
            <summary>序列</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Set">
            <summary>集合</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.NumericString">
            <summary>数字字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.PrintableString">
            <summary>可打印字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.T61String">
            <summary>T61字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.VideotexString">
            <summary>视频</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.IA5String">
            <summary>IA5字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.UtcTime">
            <summary>UTC时间</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.GeneralizedTime">
            <summary>通用时间</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.GraphicString">
            <summary>图形</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.VisibleString">
            <summary>可见字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.GeneralString">
            <summary>基本字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.UniversalString">
            <summary>全局字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.BmpString">
            <summary>位图</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Utf8String">
            <summary>UTF8字符串</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Constructed">
            <summary>组合</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Application">
            <summary>应用</summary>
        </member>
        <member name="F:NewLife.Security.Asn1Tags.Tagged">
            <summary>标记</summary>
        </member>
        <member name="T:NewLife.Security.Certificate">
            <summary>证书</summary>
            <remarks>http://blogs.msdn.com/b/dcook/archive/2008/11/25/creating-a-self-signed-certificate-in-c.aspx</remarks>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.String)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="insecurePassword"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>建立自签名证书</summary>
            <param name="x500">例如CN=SelfSignCertificate;C=China;OU=NewLife;O=Development Team;E=nnhy@vip.qq.com，其中CN是显示名</param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>建立自签名证书</summary>
            <param name="distName"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Crc16">
            <summary>CRC16校验</summary>
        </member>
        <member name="F:NewLife.Security.Crc16.CrcTable">
            <summary>CRC16表</summary>
        </member>
        <member name="P:NewLife.Security.Crc16.Value">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Int16)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验  CRC16-CCITT x16+x12+x5+1 1021  ISO HDLC, ITU X.25, V.34/V.41/V.42, PPP-FCS</summary>
            <remarks>字符串123456789的Crc16是31C3</remarks>
            <param name = "buffer">数据缓冲区</param>
            <param name = "offset">偏移量</param>
            <param name = "count">字节个数</param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验  CRC-16 x16+x15+x2+1 8005 IBM SDLC</summary>
            <param name="stream"></param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>计算校验码</summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.IO.Stream,System.Int32)">
            <summary>计算数据流校验码</summary>
            <param name="stream"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.IO.Stream,System.Int64,System.Int32)">
            <summary>计算数据流校验码，指定起始位置和字节数偏移量</summary>
            <remarks>
            一般用于计算数据包校验码，需要回过头去开始校验，并且可能需要跳过最后的校验码长度。
            position小于0时，数据流从当前位置开始计算校验；
            position大于等于0时，数据流移到该位置开始计算校验，最后由count决定可能差几个字节不参与计算；
            </remarks>
            <param name="stream"></param>
            <param name="position">如果大于等于0，则表示从该位置开始计算</param>
            <param name="count">字节数偏移量，一般用负数表示</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Crc32">
             <summary>CRC32校验</summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:NewLife.Security.Crc32.Table">
            <summary>校验表</summary>
        </member>
        <member name="F:NewLife.Security.Crc32.crc">
            <summary>校验值</summary>
        </member>
        <member name="P:NewLife.Security.Crc32.Value">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Int32)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验</summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验</summary>
            <param name="stream"></param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Security.Crc32.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>计算校验码</summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc32.Compute(System.IO.Stream,System.Int32)">
            <summary>计算数据流校验码</summary>
            <param name="stream"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc32.ComputeRange(System.IO.Stream,System.Int64,System.Int32)">
            <summary>计算数据流校验码，指定起始位置和字节数偏移量</summary>
            <remarks>
            一般用于计算数据包校验码，需要回过头去开始校验，并且可能需要跳过最后的校验码长度。
            position小于0时，数据流从当前位置开始计算校验；
            position大于等于0时，数据流移到该位置开始计算校验，最后由count决定可能差几个字节不参与计算；
            </remarks>
            <param name="stream"></param>
            <param name="position">如果大于等于0，则表示从该位置开始计算</param>
            <param name="count">字节数偏移量，一般用负数表示</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.DSAHelper">
            <summary>DSA算法</summary>
        </member>
        <member name="M:NewLife.Security.DSAHelper.GenerateKey(System.Int32)">
            <summary>产生非对称密钥对（私钥和公钥）</summary>
            <param name="keySize">密钥长度，默认1024位强密钥</param>
            <returns>私钥和公钥</returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.Sign(System.Byte[],System.String)">
            <summary>签名</summary>
            <param name="buf"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证</summary>
            <param name="buf"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.FromXmlStringX(System.Security.Cryptography.DSACryptoServiceProvider,System.String)">
            <summary>从Xml加载DSA密钥</summary>
            <param name="rsa"></param>
            <param name="xmlString"></param>
        </member>
        <member name="M:NewLife.Security.DSAHelper.ToXmlStringX(System.Security.Cryptography.DSACryptoServiceProvider,System.Boolean)">
            <summary>保存DSA密钥到Xml</summary>
            <param name="rsa"></param>
            <param name="includePrivateParameters"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.ECDsaHelper">
            <summary>椭圆曲线数字签名算法 (ECDSA) </summary>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.CreatBase64(System.Int32)">
            <summary>
            产生非对称密钥对
            </summary>
            <param name="keysize"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.Create(System.String,System.Nullable{System.Boolean})">
            <summary>创建ECDsa对象，支持Base64密钥和Pem密钥</summary>
            <param name="key"></param>
            <param name="privateKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.Sign(System.Byte[],System.String)">
            <summary>签名，MD5散列</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证，MD5散列</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.SignSha256(System.Byte[],System.String)">
            <summary>Sha256</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.VerifySha256(System.Byte[],System.String,System.Byte[])">
            <summary>Sha256</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.SignSha384(System.Byte[],System.String)">
            <summary>Sha384</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.VerifySha384(System.Byte[],System.String,System.Byte[])">
            <summary>Sha384</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.SignSha512(System.Byte[],System.String)">
            <summary>Sha512</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.VerifySha512(System.Byte[],System.String,System.Byte[])">
            <summary>Sha512</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECDsaHelper.ReadPem(System.String)">
            <summary>读取PEM文件到RSA参数</summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.ECKey">
            <summary>椭圆曲线密钥</summary>
        </member>
        <member name="P:NewLife.Security.ECKey.Algorithm">
            <summary>算法</summary>
        </member>
        <member name="P:NewLife.Security.ECKey.X">
            <summary>坐标X</summary>
        </member>
        <member name="P:NewLife.Security.ECKey.Y">
            <summary>坐标Y</summary>
        </member>
        <member name="P:NewLife.Security.ECKey.D">
            <summary>私钥才有</summary>
        </member>
        <member name="M:NewLife.Security.ECKey.SetAlgorithm(System.Security.Cryptography.Oid,System.Boolean)">
            <summary>设置算法参数</summary>
            <param name="oid"></param>
            <param name="privateKey"></param>
        </member>
        <member name="M:NewLife.Security.ECKey.Read(System.Byte[])">
            <summary>读取</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Security.ECKey.ToArray">
            <summary>转字节数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECKey.Read(System.IO.Stream,System.Object)">
            <summary>读取</summary>
            <param name="stream"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECKey.Write(System.IO.Stream,System.Object)">
            <summary>写入</summary>
            <param name="stream"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.ECKey.ExportParameters">
            <summary>导出参数</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Murmur128">
            <summary>高性能低碰撞Murmur128哈希算法</summary>
            <remarks>
            Redis等大量使用，比MD5要好
            </remarks>
        </member>
        <member name="P:NewLife.Security.Murmur128.Seed">
            <summary>种子</summary>
        </member>
        <member name="P:NewLife.Security.Murmur128.HashSize">
            <summary>哈希大小</summary>
        </member>
        <member name="M:NewLife.Security.Murmur128.#ctor(System.UInt32)">
            <summary>实例化</summary>
            <param name="seed"></param>
        </member>
        <member name="M:NewLife.Security.Murmur128.Initialize">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Security.Murmur128.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>哈希核心</summary>
            <param name="array"></param>
            <param name="ibStart"></param>
            <param name="cbSize"></param>
        </member>
        <member name="M:NewLife.Security.Murmur128.HashFinal">
            <summary>哈希结束</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Rand">
            <summary>随机数</summary>
        </member>
        <member name="M:NewLife.Security.Rand.Next(System.Int32)">
            <summary>返回一个小于所指定最大值的非负随机数</summary>
            <param name="max">返回的随机数的上界（随机数不能取该上界值）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.Next(System.Int32,System.Int32)">
            <summary>返回一个指定范围内的随机数</summary>
            <remarks>
            调用平均耗时37.76ns，其中GC耗时77.56%
            </remarks>
            <param name="min">返回的随机数的下界（随机数可取该下界值）</param>
            <param name="max">返回的随机数的上界（随机数不能取该上界值）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextBytes(System.Int32)">
            <summary>返回指定长度随机字节数组</summary>
            <remarks>
            调用平均耗时5.46ns，其中GC耗时15%
            </remarks>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextString(System.Int32,System.Boolean)">
            <summary>返回指定长度随机字符串</summary>
            <param name="length">长度</param>
            <param name="symbol">是否包含符号</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.RC4">
            <summary>RC4对称加密算法</summary>
            <remarks>
            RC4于1987年提出，和DES算法一样，是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。
            但不同于DES的是，RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。
            
            RC4算法的特点是算法简单，运行速度快，而且密钥长度是可变的，可变范围为1-256字节(8-2048比特)，
            在如今技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以可以预见RC4的密钥范围任然可以在今后相当长的时间里抵御暴力搜索密钥的攻击。
            实际上，如今也没有找到对于128bit密钥长度的RC4加密算法的有效攻击方法。
            </remarks>
        </member>
        <member name="M:NewLife.Security.RC4.Encrypt(System.Byte[],System.Byte[])">
            <summary>加密</summary>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RC4.GetKey(System.Byte[],System.Int32)">
            <summary>打乱密码</summary>  
            <param name="pass">密码</param>  
            <param name="len">密码箱长度</param>  
            <returns>打乱后的密码</returns>  
        </member>
        <member name="T:NewLife.Security.RSAHelper">
            <summary>RSA算法</summary>
            <remarks>
            RSA加密或签名小数据块时，密文长度128，速度也很快。
            </remarks>
        </member>
        <member name="M:NewLife.Security.RSAHelper.ReadParameters(System.String,System.Nullable{System.Boolean})">
            <summary>根据Base64密钥创建RSA参数</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Encrypt_JS_OAEP(System.String,System.String)">
            <summary>
            获取 等同 VUE js 中 RSA-OAEP 的实现加密
            </summary>
            <param name="msg">加密消息</param>
            <param name="key">公钥, -----BEGIN RSA PUBLIC KEY----- 或者 -----BEGIN PUBLIC KEY-----</param>
            <returns>返回 base64 </returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Decrypt_JS_OAEP(System.String,System.String)">
            <summary>
            获取 等同 VUE js 中 RSA-OAEP 的实现解密
            </summary>
            <param name="msg"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Create(System.String)">
            <summary>创建RSA对象，支持Xml密钥和Pem密钥</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Encrypt(System.Byte[],System.String,System.Boolean)">
            <summary>RSA公钥加密。仅用于加密少量数据</summary>
            <remarks>
            (PKCS # 1 v2) 的 OAEP 填充	模数大小-2-2 * hLen，其中 hLen 是哈希的大小。
            直接加密 (PKCS # 1 1.5 版)	模数大小-11。 (11 个字节是可能的最小填充。 )
            </remarks>
            <param name="data">数据明文</param>
            <param name="pubKey">公钥</param>
            <param name="fOAEP">如果为 true，则使用 OAEP 填充（仅可用于运行 Windows XP 及更高版本的计算机）执行直接 System.Security.Cryptography.RSA加密；否则，如果为 false，则使用 PKCS#1 v1.5 填充。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Decrypt(System.Byte[],System.String,System.Boolean)">
            <summary>RSA私钥解密。仅用于加密少量数据</summary>
            <remarks>
            (PKCS # 1 v2) 的 OAEP 填充	模数大小-2-2 * hLen，其中 hLen 是哈希的大小。
            直接加密 (PKCS # 1 1.5 版)	模数大小-11。 (11 个字节是可能的最小填充。 )
            </remarks>
            <param name="data">数据密文</param>
            <param name="priKey">私钥</param>
            <param name="fOAEP">如果为 true，则使用 OAEP 填充（仅可用于运行 Microsoft Windows XP 及更高版本的计算机）执行直接 System.Security.Cryptography.RSA解密；否则，如果为 false 则使用 PKCS#1 v1.5 填充。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Sign(System.Byte[],System.String)">
            <summary>签名，MD5散列</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证，MD5散列</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SignSha256(System.Byte[],System.String)">
            <summary>RS256</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.VerifySha256(System.Byte[],System.String,System.Byte[])">
            <summary>RS256</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SignSha384(System.Byte[],System.String)">
            <summary>RS384</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.VerifySha384(System.Byte[],System.String,System.Byte[])">
            <summary>RS384</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SignSha512(System.Byte[],System.String)">
            <summary>RS512</summary>
            <param name="data"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.VerifySha512(System.Byte[],System.String,System.Byte[])">
            <summary>RS512</summary>
            <param name="data"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.ReadPem(System.String)">
            <summary>读取PEM文件到RSA参数</summary>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.SecurityHelper">
            <summary>安全算法</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/security_helper
            </remarks>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5(System.Byte[])">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5(System.String,System.Text.Encoding)">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <param name="encoding">字符串编码，默认Default</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5_16(System.String,System.Text.Encoding)">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <param name="encoding">字符串编码，默认Default</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.MD5(System.IO.FileInfo)">
            <summary>计算文件的MD5散列</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Crc(System.Byte[])">
            <summary>Crc散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Crc16(System.Byte[])">
            <summary>Crc16散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA1(System.Byte[],System.Byte[])">
            <summary>SHA128</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA256(System.Byte[],System.Byte[])">
            <summary>SHA256</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA384(System.Byte[],System.Byte[])">
            <summary>SHA384</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.SHA512(System.Byte[],System.Byte[])">
            <summary>SHA512</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Murmur128(System.Byte[],System.UInt32)">
            <summary>Murmur128哈希</summary>
            <param name="data"></param>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Encrypt(System.Security.Cryptography.SymmetricAlgorithm,System.IO.Stream,System.IO.Stream)">
            <summary>对称加密算法扩展</summary>
            <remarks>注意：CryptoStream会把 outstream 数据流关闭</remarks>
            <param name="sa"></param>
            <param name="instream"></param>
            <param name="outstream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Encrypt(System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>对称加密算法扩展</summary>
            <param name="sa">算法</param>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <param name="mode">模式。.Net默认CBC，Java默认ECB</param>
            <param name="padding">填充算法。默认PKCS7，等同Java的PKCS5</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Decrypt(System.Security.Cryptography.SymmetricAlgorithm,System.IO.Stream,System.IO.Stream)">
            <summary>对称解密算法扩展
            <para>注意：CryptoStream会把 instream 数据流关闭</para>
            </summary>
            <param name="sa"></param>
            <param name="instream"></param>
            <param name="outstream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.Decrypt(System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>对称解密算法扩展</summary>
            <param name="sa">算法</param>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <param name="mode">模式。.Net默认CBC，Java默认ECB</param>
            <param name="padding">填充算法。默认PKCS7，等同Java的PKCS5</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.SecurityHelper.RC4(System.Byte[],System.Byte[])">
            <summary>RC4对称加密算法</summary>
            <param name="data"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Accessor">
            <summary>访问器基类</summary>
        </member>
        <member name="M:NewLife.Serialization.Accessor.Read(System.IO.Stream,System.Object)">
            <summary>从数据流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.Write(System.IO.Stream,System.Object)">
            <summary>把消息写入到数据流中</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Serialization.Accessor.ToPacket">
            <summary>消息转为字节数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.CreateFormatter(System.Boolean)">
            <summary>创建序列化器</summary>
            <param name="isRead"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.ToString">
            <summary>输出消息实体</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.GetMember(System.Reflection.PropertyInfo,System.Int32,System.Text.StringBuilder)">
            <summary>获取成员输出</summary>
            <param name="pi"></param>
            <param name="len"></param>
            <param name="sb"></param>
        </member>
        <member name="M:NewLife.Serialization.Accessor.GetMemberValue(System.Reflection.PropertyInfo)">
            <summary>获取用于输出的成员值</summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Accessor`1">
            <summary>访问器泛型基类</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Serialization.Accessor`1.Read(System.IO.Stream)">
            <summary>从流中读取消息</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor`1.Read(NewLife.Data.Packet)">
            <summary>从字节数组中读取消息</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryCodec`1">
            <summary>二进制编码解码器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryCodec`1.EncodedInt">
            <summary>使用7位编码整数。默认true使用</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec`1.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>对象转二进制</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec`1.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>二进制转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryCodec2">
            <summary>二进制编码解码器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryCodec2.EncodedInt">
            <summary>使用7位编码整数。默认true使用</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec2.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>对象转二进制</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec2.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>二进制转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Binary">
            <summary>二进制序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.EncodeInt">
            <summary>使用7位编码整数。默认false不使用</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.IsLittleEndian">
            <summary>小端字节序。默认false大端</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.UseFieldSize">
            <summary>使用指定大小的FieldSizeAttribute特性，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.UseRef">
            <summary>使用对象引用，默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.SizeWidth">
            <summary>大小宽度。可选0/1/2/4，默认0表示压缩编码整数</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.AddHandler(NewLife.Serialization.IBinaryHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.GetHandler``1">
            <summary>获取处理器</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteSize(System.Int32)">
            <summary>写入大小，如果有FieldSize则返回，否则写入编码的大小</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteEncoded(System.Int32)">
            <summary>写7位压缩编码整数</summary>
            <remarks>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </remarks>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.EnableTrace">
            <summary>使用跟踪流。实际上是重新包装一次Stream，必须在设置Stream后，使用之前</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastRead``1(System.IO.Stream,System.Boolean)">
            <summary>快速读取</summary>
            <typeparam name="T"></typeparam>
            <param name="stream">数据流</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastWrite(System.Object,System.Boolean)">
            <summary>快速写入</summary>
            <param name="value">对象</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastWrite(System.Object,System.IO.Stream,System.Boolean)">
            <summary>快速写入</summary>
            <param name="value">对象</param>
            <param name="stream">目标数据流</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryColor">
            <summary>颜色处理器。</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryComposite">
            <summary>复合对象处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryDictionary">
            <summary>字典数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryGeneral">
            <summary>二进制基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte)">
            <summary>将一个无符号字节写入</summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[])">
            <summary>将字节数组写入，如果设置了UseSize，则先写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer">缓冲区</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteIntBytes(System.Byte[])">
            <summary>判断字节顺序</summary>
            <param name="buffer">缓冲区</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt16)">
            <summary>将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt32)">
            <summary>将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt64)">
            <summary>将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Single)">
            <summary>将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Double)">
            <summary>将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Decimal)">
            <summary>将一个十进制值写入当前流，并将流位置提升十六个字节。</summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Char)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadByte">
            <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadIntBytes(System.Int32)">
            <summary>读取整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序</summary>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt16">
            <summary>使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt32">
            <summary>从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt64">
            <summary>从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadSingle">
            <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadDouble">
            <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadChar">
            <summary>从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadString">
            <summary>从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadDecimal">
            <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int16)">
            <summary>
            以7位压缩格式写入16位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int32)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int64)">
            <summary>
            以7位压缩格式写入64位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryList">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryNormal">
            <summary>常用类型编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer">缓冲区</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryPair">
            <summary>二进制名值对</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.WritePair(System.String,System.Object)">
            <summary>写入名值对</summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.ReadPair">
            <summary>读取原始名值对</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.ReadPair(System.IO.Stream,System.Text.Encoding)">
            <summary>读取原始名值对</summary>
            <param name="ms">数据流</param>
            <param name="encoding">编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.TryReadPair(System.Collections.Generic.IDictionary{System.String,System.Byte[]},System.String,System.Type,System.Object@)">
            <summary>从原始名值对读取数据</summary>
            <param name="dic"></param>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryTest">
            <summary>Binary测试</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryTest.Start">
            <summary>开始测试</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryUnknown">
            <summary>内部对象处理器。对于其它处理器无法支持的类型，一律由该处理器解决</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryUnknown.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryUnknown.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryUnknown.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FieldSizeAttribute">
            <summary>字段大小特性。</summary>
            <remarks>
            可以通过Size指定字符串或数组的固有大小，为0表示自动计算；也可以通过指定参考字段ReferenceName，然后从其中获取大小。
            支持_Header._Questions形式的多层次引用字段
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.Size">
            <summary>大小。使用<see cref="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName"/>时，作为偏移量；0表示自动计算大小</summary>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName">
            <summary>参考大小字段名</summary>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.Int32)">
            <summary>通过Size指定字符串或数组的固有大小，为0表示自动计算</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String,System.Int32)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
            <param name="size">在参考字段值基础上的增量，可以是正数负数</param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.FindReference(System.Object,System.Reflection.MemberInfo,System.Object@)">
            <summary>找到所引用的参考字段</summary>
            <param name="target">目标对象</param>
            <param name="member">目标对象的成员</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.SetReferenceSize(System.Object,System.Reflection.MemberInfo,System.Text.Encoding)">
            <summary>设置目标对象的引用大小值</summary>
            <param name="target">目标对象</param>
            <param name="member"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.GetReferenceSize(System.Object,System.Reflection.MemberInfo)">
            <summary>获取目标对象的引用大小值</summary>
            <param name="target">目标对象</param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IBinary">
            <summary>二进制序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.EncodeInt">
            <summary>编码整数</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.IsLittleEndian">
            <summary>小端字节序。默认false大端</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.UseFieldSize">
            <summary>使用指定大小的FieldSizeAttribute特性，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.IBinary.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IBinary.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.IBinary.WriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size">要写入的大小值</param>
            <returns>返回特性指定的固定长度，如果没有则返回-1</returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IBinaryHandler">
            <summary>二进制读写处理器接口</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryHandlerBase">
            <summary>二进制读写处理器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.IAccessor">
            <summary>序列化访问器。接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Read(System.IO.Stream,System.Object)">
            <summary>从数据流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Write(System.IO.Stream,System.Object)">
            <summary>把消息写入到数据流中</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:NewLife.Serialization.AccessorHelper">
            <summary>访问器助手</summary>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.ToPacket(NewLife.Serialization.IAccessor,System.Object)">
            <summary>支持访问器的对象转数据包</summary>
            <param name="accessor">访问器</param>
            <param name="context">上下文</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.AccessorRead(System.Type,NewLife.Data.Packet,System.Object)">
            <summary>通过访问器读取</summary>
            <param name="type"></param>
            <param name="pk"></param>
            <param name="context">上下文</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.ToEntity``1(NewLife.Data.Packet,System.Object)">
            <summary>通过访问器转换数据包为实体对象</summary>
            <typeparam name="T"></typeparam>
            <param name="pk"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IFormatterX">
            <summary>序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Hosts">
            <summary>主对象</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Encoding">
            <summary>字符串编码，默认utf-8</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.UseProperty">
            <summary>序列化属性而不是字段。默认true</summary>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="T:NewLife.Serialization.IHandler`1">
            <summary>序列化处理器接口</summary>
            <typeparam name="THost"></typeparam>
        </member>
        <member name="P:NewLife.Serialization.IHandler`1.Host">
            <summary>宿主读写器</summary>
        </member>
        <member name="P:NewLife.Serialization.IHandler`1.Priority">
            <summary>优先级</summary>
        </member>
        <member name="M:NewLife.Serialization.IHandler`1.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IHandler`1.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FormatterBase">
            <summary>序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Stream">
            <summary>数据流。默认实例化一个内存数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Hosts">
            <summary>主对象</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Encoding">
            <summary>字符串编码，默认utf-8</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.UseProperty">
            <summary>序列化属性而不是字段。默认true</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.GetBytes">
            <summary>获取流里面的数据</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Serialization.HandlerBase`2">
            <summary>读写处理器基类</summary>
        </member>
        <member name="P:NewLife.Serialization.HandlerBase`2.Host">
            <summary>宿主读写器</summary>
        </member>
        <member name="P:NewLife.Serialization.HandlerBase`2.Priority">
            <summary>优先级</summary>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Serialization.IMemberAccessor">
            <summary>成员序列化访问器。接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.IMemberAccessor.Read(NewLife.Serialization.IFormatterX,System.Reflection.MemberInfo)">
            <summary>从数据流中读取消息</summary>
            <param name="fm">序列化</param>
            <param name="member">成员</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IMemberAccessor.Write(NewLife.Serialization.IFormatterX,System.Reflection.MemberInfo)">
            <summary>把消息写入到数据流中</summary>
            <param name="fm">序列化</param>
            <param name="member">成员</param>
        </member>
        <member name="T:NewLife.Serialization.JsonCodec`1">
            <summary>Json编码解码器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec`1.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>对象转Json</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec`1.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>Json转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonCodec2">
            <summary>Json编码解码器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec2.Write(NewLife.Model.IHandlerContext,System.Object)">
            <summary>对象转Json</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec2.Read(NewLife.Model.IHandlerContext,System.Object)">
            <summary>Json转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IJson">
            <summary>IJson序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IJson.Indented">
            <summary>是否缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.IJson.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.IJson.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IJson.Write(System.Text.StringBuilder,System.Object)">
            <summary>写入</summary>
            <param name="sb"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IJson.Read(System.String)">
            <summary>读取</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJson.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IJsonHandler">
            <summary>IJson读写处理器接口</summary>
        </member>
        <member name="M:NewLife.Serialization.IJsonHandler.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="T:NewLife.Serialization.JsonHandlerBase">
            <summary>IJson读写处理器基类</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonHandlerBase.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHandlerBase.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="T:NewLife.Serialization.IJsonHost">
            <summary>Json序列化接口</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/json
            </remarks>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Write(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Read(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Convert(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonHelper">
            <summary>Json助手</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.JsonHelper.Default">
            <summary>默认实现</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJson(System.Object,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJson(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否换行缩进。默认false</param>
            <param name="nullValue">是否写空值。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJsonEntity(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJsonEntity``1(System.String)">
            <summary>从Json字符串中读取对象</summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Format(System.String)">
            <summary>格式化Json文本</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Convert``1(System.Object)">
            <summary>Json类型对象转换实体类</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Json">
            <summary>Json序列化</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.Json.Indented">
            <summary>是否缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.AddHandler(NewLife.Serialization.IJsonHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.GetHandler``1">
            <summary>获取处理器</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.Text.StringBuilder,System.Object)">
            <summary>写入</summary>
            <param name="sb"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Read(System.String)">
            <summary>读取</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonArray">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonComposite">
            <summary>复合对象处理器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonComposite.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonGeneral">
            <summary>Json基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonParser">
            <summary>Json分析器</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/json
            </remarks>
        </member>
        <member name="T:NewLife.Serialization.JsonParser.Token">
            <summary>标识符</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Curly_Open">
            <summary>左大括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Curly_Close">
            <summary>右大括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Squared_Open">
            <summary>左方括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Squared_Close">
            <summary>右方括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Colon">
            <summary>冒号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Comma">
            <summary>逗号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.String">
            <summary>字符串</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Number">
            <summary>数字</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.True">
            <summary>布尔真</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.False">
            <summary>布尔真</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Null">
            <summary>空值</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="json"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.Decode(System.String)">
            <summary>解码</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.Decode">
            <summary>解码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.SkipToken">
            <summary>读取一个Token</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader">
            <summary>Json读取器</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.UseUTCDateTime">
            <summary>是否使用UTC时间</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.Provider">
            <summary>服务提供者</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Read``1(System.String)">
            <summary>读取Json到指定类型</summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Read(System.String,System.Type)">
            <summary>读取Json到指定类型</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ToObject(System.Object,System.Type,System.Object)">
            <summary>Json字典或列表转为具体类型对象</summary>
            <param name="jobj">Json对象</param>
            <param name="type">模板类型</param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseList(System.Collections.Generic.IList{System.Object},System.Type,System.Object)">
            <summary>转为泛型列表</summary>
            <param name="vlist"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseArray(System.Collections.Generic.IList{System.Object},System.Type,System.Object)">
            <summary>转为数组</summary>
            <param name="list"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Collections.IDictionary)">
            <summary>转为泛型字典</summary>
            <param name="dic"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseObject(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Object)">
            <summary>字典转复杂对象，反射属性赋值</summary>
            <param name="dic"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.CreateDateTime(System.Object)">
            <summary>创建时间</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonTest">
            <summary>Json测试</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonTest.Start">
            <summary>开始测试</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonWriter">
            <summary>Json写入器</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/json
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.UseUTCDateTime">
            <summary>使用UTC时间。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.LowerCase">
            <summary>使用小写名称</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.CamelCase">
            <summary>使用驼峰命名</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreNullValues">
            <summary>忽略空值。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreReadOnlyProperties">
            <summary>忽略只读属性。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreComment">
            <summary>忽略注释。默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.IgnoreCircle">
            <summary>忽略循环引用。遇到循环引用时写{}，默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.EnumString">
            <summary>枚举使用字符串。默认false使用数字</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.Indented">
            <summary>缩进。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.SmartIndented">
            <summary>智能缩进，内层不换行。默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.MaxDepth">
            <summary>最大序列化深度。超过时不再序列化，而不是抛出异常，默认5</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.ToJson(System.Object,System.Boolean,System.Boolean,System.Boolean)">
            <summary>对象序列化为Json字符串</summary>
            <param name="obj"></param>
            <param name="indented">是否缩进。默认false</param>
            <param name="nullValue">是否写控制。默认true</param>
            <param name="camelCase">是否驼峰命名。默认false</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.Write(System.Object)">
            <summary>写入对象</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.GetString">
            <summary>获取结果</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.FormatName(System.String)">
            <summary>根据小写和驼峰格式化名称</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Serialization.JsonWriter._level">
            <summary>当前缩进层级</summary>
        </member>
        <member name="T:NewLife.Serialization.SerialHelper">
            <summary>序列化助手</summary>
        </member>
        <member name="M:NewLife.Serialization.SerialHelper.GetName(System.Reflection.PropertyInfo)">
            <summary>获取序列化名称</summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.SerialHelper.BuildModelClass(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
            <summary>依据 Json/Xml 字典生成实体模型类</summary>
            <param name="dic"></param>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IXml">
            <summary>二进制序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IXml.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="P:NewLife.Serialization.IXml.UseComment">
            <summary>使用注释</summary>
        </member>
        <member name="M:NewLife.Serialization.IXml.Write(System.Object,System.String,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IXml.GetWriter">
            <summary>获取Xml写入器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IXml.GetReader">
            <summary>获取Xml读取器</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IXmlHandler">
            <summary>二进制读写处理器接口</summary>
        </member>
        <member name="T:NewLife.Serialization.XmlHandlerBase">
            <summary>Xml读写处理器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.Xml">
            <summary>Xml序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Depth">
            <summary>深度</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.UseAttribute">
            <summary>使用特性</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.UseComment">
            <summary>使用注释</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.CurrentName">
            <summary>当前名称</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.AddHandler(NewLife.Serialization.IXmlHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Write(System.Object,System.String,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.WriteStart(System.Type)">
            <summary>写入开头</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Xml.WriteEnd">
            <summary>写入结尾</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetWriter">
            <summary>获取Xml写入器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.ReadStart(System.Type)">
            <summary>读取开始</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Xml.ReadEnd">
            <summary>读取结束</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetReader">
            <summary>获取Xml读取器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetString">
            <summary>获取字符串</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlComposite">
            <summary>Xml复合对象处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.GetMembers(System.Type)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlGeneral">
            <summary>Xml基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlList">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlList.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlList.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlList.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlParser">
            <summary>Xml解析器，得到字典和数组</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlParser.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="xml"></param>
        </member>
        <member name="M:NewLife.Serialization.XmlParser.Decode(System.String)">
            <summary>解码</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Setting">
            <summary>核心设置</summary>
        </member>
        <member name="P:NewLife.Setting.Debug">
            <summary>是否启用全局调试。默认启用</summary>
        </member>
        <member name="P:NewLife.Setting.LogLevel">
            <summary>日志等级，只输出大于等于该级别的日志，All/Debug/Info/Warn/Error/Fatal，默认Info</summary>
        </member>
        <member name="P:NewLife.Setting.LogPath">
            <summary>文件日志目录。默认Log子目录，web上一级Log</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileMaxBytes">
            <summary>日志文件上限。超过上限后拆分新日志文件，默认10MB，0表示不限制大小</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileBackups">
            <summary>日志文件备份。超过备份数后，最旧的文件将被删除，默认100，0表示不限制个数</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileFormat">
            <summary>日志文件格式。默认{0:yyyy_MM_dd}.log，支持日志等级如 {1}_{0:yyyy_MM_dd}.log</summary>
        </member>
        <member name="P:NewLife.Setting.DataPath">
            <summary>数据目录。本地数据库目录，默认Data子目录，web上一级Data</summary>
        </member>
        <member name="P:NewLife.Setting.BackupPath">
            <summary>备份目录。备份数据库时存放的目录，默认Backup子目录，web上一级Backup</summary>
        </member>
        <member name="P:NewLife.Setting.PluginPath">
            <summary>插件目录</summary>
        </member>
        <member name="P:NewLife.Setting.PluginServer">
            <summary>插件服务器。将从该网页上根据关键字分析链接并下载插件</summary>
        </member>
        <member name="M:NewLife.Setting.OnLoaded">
            <summary>加载完成后</summary>
        </member>
        <member name="M:NewLife.Setting.GetPluginPath">
            <summary>获取插件目录</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.Cron">
            <summary>轻量级Cron表达式</summary>
            <remarks>
            基本构成：秒+分+时+天+月+星期
            每段构成：
                *全部，该类型片段全部可选
                ?跳过
                数字，具体某个数值可选
                -区间，横杠表示的一个区间可选
                逗号多选，逗号分隔的多个数字或区间可选
                /步进，在上述可选数字内，间隔多少选一个
            </remarks>
            <example>
            */2 每两秒一次
            0,1,2 * * * * 每分钟的0秒1秒2秒各一次
            5/20 * * * * 每分钟的5秒25秒45秒各一次
            * 1-10,13,25/3 * * * 每小时的1分4分7分10分13分25分，每一秒各一次
            0 0 0 1 * * 每个月1日的0点整
            0 0 2 * * 1-5 每个工作日的凌晨2点
            
            星期部分采用Linux和.NET风格，0表示周日，1表示周一。
            可设置Sunday为1，1表示周日，2表示周一。
            </example>
        </member>
        <member name="F:NewLife.Threading.Cron.Seconds">
            <summary>秒数集合</summary>
        </member>
        <member name="F:NewLife.Threading.Cron.Minutes">
            <summary>分钟集合</summary>
        </member>
        <member name="F:NewLife.Threading.Cron.Hours">
            <summary>小时集合</summary>
        </member>
        <member name="F:NewLife.Threading.Cron.DaysOfMonth">
            <summary>日期集合</summary>
        </member>
        <member name="F:NewLife.Threading.Cron.Months">
            <summary>月份集合</summary>
        </member>
        <member name="F:NewLife.Threading.Cron.DaysOfWeek">
            <summary>星期集合</summary>
        </member>
        <member name="P:NewLife.Threading.Cron.Sunday">
            <summary>星期天偏移量。周日对应的数字，默认0。1表示周日时，2表示周一</summary>
        </member>
        <member name="M:NewLife.Threading.Cron.#ctor">
            <summary>实例化Cron表达式</summary>
        </member>
        <member name="M:NewLife.Threading.Cron.#ctor(System.String)">
            <summary>实例化Cron表达式</summary>
            <param name="expression"></param>
        </member>
        <member name="M:NewLife.Threading.Cron.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.IsTime(System.DateTime)">
            <summary>指定时间是否位于表达式之内</summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.Parse(System.String)">
            <summary>分析表达式</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.Cron.GetNext(System.DateTime)">
            <summary>获得指定时间之后的下一次执行时间，不含指定时间</summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadPoolX">
            <summary>轻量级线程池。无等待和调度逻辑，直接创建线程竞争处理器资源</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Init">
            <summary>初始化线程池
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(System.Action)">
            <summary>带异常处理的线程池任务调度，不允许异常抛出，以免造成应用程序退出</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem``1(System.Action{``0},``0)">
            <summary>带异常处理的线程池任务调度，不允许异常抛出，以免造成应用程序退出</summary>
            <param name="callback"></param>
            <param name="state"></param>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Instance">
            <summary>静态实例</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Pool">
            <summary>内部池</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.MyThreadPool.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueWorkItem(System.Action)">
            <summary>把委托放入线程池执行</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueTask(System.Action)">
            <summary>在线程池中异步执行任务</summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueTask``1(System.Func{``0})">
            <summary>在线程池中异步执行任务</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueTask``1(System.Func{System.Threading.CancellationToken,``0},System.Threading.CancellationToken)">
            <summary>在线程池中异步执行任务</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadItem">
            <summary>线程任务项</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.Thread">
            <summary>线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.Host">
            <summary>主机线程池</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.Active">
            <summary>活跃</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.#ctor(NewLife.Threading.ThreadPoolX)">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.Execute(System.Action)">
            <summary>执行委托</summary>
            <param name="callback"></param>
        </member>
        <member name="T:NewLife.Threading.TimerScheduler">
            <summary>定时器调度器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Create(System.String)">
            <summary>创建指定名称的调度器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Default">
            <summary>默认调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Current">
            <summary>当前调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Count">
            <summary>定时器个数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.MaxCost">
            <summary>最大耗时。超过时报警告日志，默认500ms</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Add(NewLife.Threading.TimerX)">
            <summary>把定时器加入队列</summary>
            <param name="timer"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Remove(NewLife.Threading.TimerX,System.String)">
            <summary>从队列删除定时器</summary>
            <param name="timer"></param>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Wake">
            <summary>唤醒处理</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Process(System.Object)">
            <summary>调度主程序</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.CheckTime(NewLife.Threading.TimerX,System.DateTime)">
            <summary>检查定时器是否到期</summary>
            <param name="timer"></param>
            <param name="now"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Execute(System.Object)">
            <summary>处理每一个定时器</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.ExecuteAsync(System.Object)">
            <summary>处理每一个定时器</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Threading.TimerX">
            <summary>不可重入的定时器，支持Cron</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/timerx
            
            为了避免系统的Timer可重入的问题，差别在于本地调用完成后才开始计算时间间隔。这实际上也是经常用到的。
            
            因为挂载在静态列表上，必须从外部主动调用<see cref="M:System.IDisposable.Dispose"/>才能销毁定时器。
            但是要注意GC回收定时器实例。
            
            该定时器不能放入太多任务，否则适得其反！
            
            TimerX必须维持对象，否则Scheduler也没有维持对象时，大家很容易一起被GC回收。
            </remarks>
        </member>
        <member name="P:NewLife.Threading.TimerX.Id">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Scheduler">
            <summary>所属调度器</summary>
        </member>
        <member name="F:NewLife.Threading.TimerX.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.Threading.TimerX.Method">
            <summary>委托方法</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.State">
            <summary>获取/设置 用户数据</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.NextTime">
            <summary>获取/设置 下一次调用时间</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Timers">
            <summary>获取/设置 调用次数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Period">
            <summary>获取/设置 间隔周期。毫秒，设为0或-1则只调用一次</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Async">
            <summary>获取/设置 异步执行任务。默认false</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Absolutely">
            <summary>获取/设置 绝对精确时间执行。默认false</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Calling">
            <summary>调用中</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Cost">
            <summary>平均耗时。毫秒</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.CanExecute">
            <summary>判断任务是否执行的委托。一般跟异步配合使用，避免频繁从线程池借出线程</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Cron">
            <summary>Cron表达式，实现复杂的定时逻辑</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Current">
            <summary>当前定时器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32,System.String)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始。毫秒</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.Int32,System.Int32,System.String)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始。毫秒</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.TimerCallback,System.Object,System.DateTime,System.Int32,System.String)">
            <summary>实例化一个绝对定时器，指定时刻执行，跟当前时间和SetNext无关</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="startTime">绝对开始时间</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.DateTime,System.Int32,System.String)">
            <summary>实例化一个绝对定时器，指定时刻执行，跟当前时间和SetNext无关</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="startTime">绝对开始时间</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.TimerCallback,System.Object,System.String,System.String)">
            <summary>实例化一个Cron定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="cronExpression">Cron表达式</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.String,System.String)">
            <summary>实例化一个Cron定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="cronExpression">Cron表达式</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.Dispose">
            <summary>销毁定时器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="F:NewLife.Threading.TimerX.hasSetNext">
            <summary>是否已设置下一次时间</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.SetNext(System.Int32)">
            <summary>设置下一次运行时间</summary>
            <param name="ms">小于等于0表示马上调度</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.SetAndGetNextTime">
            <summary>设置下一次执行时间，并获取间隔</summary>
            <returns>返回下一次执行的间隔时间，不能小于等于0，否则定时器被销毁</returns>
        </member>
        <member name="M:NewLife.Threading.TimerX.Delay(System.Threading.TimerCallback,System.Int32)">
            <summary>延迟执行一个委托。特别要小心，很可能委托还没被执行，对象就被gc回收了</summary>
            <param name="callback"></param>
            <param name="ms"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerX.Now">
            <summary>当前时间。定时读取系统时间，避免频繁读取系统时间造成性能瓶颈</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.JwtEncodeDelegate">
            <summary>Jwt编码委托</summary>
            <param name="data"></param>
            <param name="secrect"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.JwtDecodeDelegate">
            <summary>Jwt解码委托</summary>
            <param name="data"></param>
            <param name="secrect"></param>
            <param name="signature"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.JwtBuilder">
            <summary>JSON Web Token RS256</summary>
            <remarks>
            主要问题：
            1，JWT默认不加密，但可以加密。生成原始令牌后，可以使用该令牌再次对其进行加密。
            2，当JWT未加密时，私密数据无法通过JWT传输。
            3，JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。
            4，JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。
            5，JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。
            6，为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。
            </remarks>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Issuer">
            <summary>颁发者</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Subject">
            <summary>主体所有人。可以存放userid/roleid等，作为用户唯一标识</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Audience">
            <summary>受众</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Expire">
            <summary>有效期。默认2小时</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.NotBefore">
            <summary>生效时间，在此之前是无效的</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.IssuedAt">
            <summary>颁发时间</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Id">
            <summary>标识</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Algorithm">
            <summary>算法。默认HS256</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Type">
            <summary>令牌类型。默认JWT</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Secret">
            <summary>密钥</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Web.JwtBuilder.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.Encode(System.Object)">
            <summary>编码目标对象，生成令牌</summary>
            <param name="payload"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.Parse(System.String)">
            <summary>分析令牌</summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.TryDecode(System.String,System.String@)">
            <summary>解码令牌，得到目标对象</summary>
            <param name="token"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.JwtBuilder.RegisterAlgorithm(System.String,NewLife.Web.JwtEncodeDelegate,NewLife.Web.JwtDecodeDelegate)">
            <summary>注册算法的编解码实现</summary>
            <param name="algorithm"></param>
            <param name="encode"></param>
            <param name="decode"></param>
        </member>
        <member name="T:NewLife.Web.Link">
            <summary>超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Web.Link.FullName">
            <summary>全名</summary>
        </member>
        <member name="P:NewLife.Web.Link.Url">
            <summary>超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.RawUrl">
            <summary>原始超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.Title">
            <summary>标题</summary>
        </member>
        <member name="P:NewLife.Web.Link.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Web.Link.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Web.Link.Html">
            <summary>原始Html</summary>
        </member>
        <member name="M:NewLife.Web.Link.Parse(System.String,System.String,System.Func{NewLife.Web.Link,System.Boolean})">
            <summary>分析HTML中的链接</summary>
            <param name="html">Html文本</param>
            <param name="baseurl">基础Url，用于生成超链接的完整Url</param>
            <param name="filter">用于基础过滤的过滤器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Link.Parse(System.String)">
            <summary>分解文件</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Link.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.OAuthClient">
            <summary>OAuth 2.0 客户端</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Server">
            <summary>验证服务器地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AccessServer">
            <summary>令牌服务地址。可以不同于验证地址的内网直达地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Key">
            <summary>应用Key</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Secret">
            <summary>安全码</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AuthUrl">
            <summary>验证地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AccessUrl">
            <summary>访问令牌地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.ResponseType">
            <summary>响应类型</summary>
            <remarks>
            验证服务器跳转回来子系统时的类型，默认code，此时还需要子系统服务端请求验证服务器换取AccessToken；
            可选token，此时验证服务器直接返回AccessToken，子系统不需要再次请求。
            </remarks>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Scope">
            <summary>作用域</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Code">
            <summary>授权码</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AccessToken">
            <summary>访问令牌</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.RefreshToken">
            <summary>刷新令牌</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.OpenID">
            <summary>统一标识</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UnionID">
            <summary>企业级标识</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Expire">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Items">
            <summary>访问项</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Create(System.String)">
            <summary>根据名称创建客户端</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Apply(System.String)">
            <summary>应用参数设置</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Apply(NewLife.Web.OAuthItem)">
            <summary>应用参数设置</summary>
            <param name="mi"></param>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Authorize(System.String,System.String,System.Uri)">
            <summary>构建跳转验证地址</summary>
            <param name="redirect">验证完成后调整的目标地址</param>
            <param name="state">用户状态数据</param>
            <param name="baseUri">相对地址的基地址</param>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetAccessToken(System.String)">
            <summary>根据授权码获取访问令牌</summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthClient.OpenIDUrl">
            <summary>OpenID地址</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetOpenID">
            <summary>根据授权码获取访问令牌</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserUrl">
            <summary>用户信息地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserID">
            <summary>用户ID</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserName">
            <summary>用户名</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.NickName">
            <summary>昵称</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserCode">
            <summary>用户代码</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Mobile">
            <summary>手机</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Mail">
            <summary>邮箱</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Avatar">
            <summary>头像</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Detail">
            <summary>明细</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetUserInfo">
            <summary>获取用户信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Fill(NewLife.Model.IManageUser)">
            <summary>填充用户，登录成功并获取用户信息之后</summary>
            <param name="user"></param>
        </member>
        <member name="P:NewLife.Web.OAuthClient.LogoutUrl">
            <summary>注销地址</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Logout(System.String,System.String,System.Uri)">
            <summary>注销</summary>
            <param name="redirect">完成后调整的目标地址</param>
            <param name="state">用户状态数据</param>
            <param name="baseUri">相对地址的基地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetUrl(System.String)">
            <summary>替换地址模版参数</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetNameValues(System.String)">
            <summary>获取名值字典</summary>
            <param name="html"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthClient.LastHtml">
            <summary>最后一次请求的响应内容</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Request(System.String)">
            <summary>创建客户端</summary>
            <param name="url">路径</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Web.OAuthConfig">
            <summary>配置</summary>
        </member>
        <member name="P:NewLife.Web.OAuthConfig.Debug">
            <summary>调试开关。默认true</summary>
        </member>
        <member name="P:NewLife.Web.OAuthConfig.AppUrl">
            <summary>应用地址。域名和端口，应用系统经过反向代理重定向时指定外部地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthConfig.Items">
            <summary>配置项</summary>
        </member>
        <member name="M:NewLife.Web.OAuthConfig.OnLoaded">
            <summary>已加载</summary>
        </member>
        <member name="M:NewLife.Web.OAuthConfig.Get(System.String)">
            <summary>获取</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthConfig.GetOrAdd(System.String)">
            <summary>获取或添加</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.OAuthItem">
            <summary>开放验证服务器配置项</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Name">
            <summary>服务地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Server">
            <summary>验证服务地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.AccessServer">
            <summary>令牌服务地址。可以不同于验证地址的内网直达地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.AppID">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Secret">
            <summary>密钥</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Scope">
            <summary>授权范围</summary>
        </member>
        <member name="T:NewLife.Web.OAuthServer">
            <summary>单点登录服务端</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Cache">
            <summary>缓存</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.TokenProvider">
            <summary>令牌提供者</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Expire">
            <summary>令牌有效期。默认24小时</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Instance">
            <summary>实例</summary>
        </member>
        <member name="M:NewLife.Web.OAuthServer.Authorize(System.String,System.String,System.String,System.String,System.String)">
            <summary>验证用户身份</summary>
            <remarks>
            子系统需要验证访问者身份时，引导用户跳转到这里。
            用户登录完成后，得到一个独一无二的code，并跳转回去子系统。
            </remarks>
            <param name="client_id">应用标识</param>
            <param name="redirect_uri">回调地址</param>
            <param name="response_type">响应类型。默认code</param>
            <param name="scope">授权域</param>
            <param name="state">用户状态数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthServer.GetResult(System.Int32,NewLife.Model.IManageUser)">
            <summary>根据验证结果获取跳转回子系统的Url</summary>
            <param name="key"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthServer.GetToken(System.String,System.String,System.String)">
            <summary>根据Code获取令牌</summary>
            <param name="client_id"></param>
            <param name="client_secret"></param>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthServer.Decode(System.String)">
            <summary>解码令牌</summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Web.OAuthServer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.BaiduClient">
            <summary>百度身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.BaiduClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.BaiduClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.QQClient">
            <summary>身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.QQClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.QQClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.TaobaoClient">
            <summary>淘宝身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.TaobaoClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.TaobaoClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.WeixinClient">
            <summary>身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.WeixinClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.WeixinClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.Pager">
            <summary>分页器。包含分页排序参数，支持构造Url的功能</summary>
        </member>
        <member name="T:NewLife.Web.Pager.__">
            <summary>名称类。用户可根据需要修改Url参数名</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.Sort">
            <summary>排序字段</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.Desc">
            <summary>是否降序</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.PageIndex">
            <summary>页面索引</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.PageSize">
            <summary>页面大小</summary>
        </member>
        <member name="F:NewLife.Web.Pager._">
            <summary>名称类。用户可根据需要修改Url参数名</summary>
        </member>
        <member name="P:NewLife.Web.Pager.Params">
            <summary>参数集合</summary>
        </member>
        <member name="P:NewLife.Web.Pager.PageUrlTemplate">
            <summary>分页链接模版。内部将会替换{链接}和{名称}</summary>
        </member>
        <member name="P:NewLife.Web.Pager.Default">
            <summary>默认参数。如果分页参数为默认参数，则不参与构造Url</summary>
        </member>
        <member name="P:NewLife.Web.Pager.Item(System.String)">
            <summary>获取/设置 参数</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.Pager.#ctor(NewLife.Data.PageParameter)">
            <summary>用另一个分页参数实例化</summary>
            <param name="pm"></param>
        </member>
        <member name="M:NewLife.Web.Pager.GetBaseUrl(System.Boolean,System.Boolean,System.Boolean)">
            <summary>获取基础Url，用于附加参数</summary>
            <param name="where">查询条件，不包含排序和分页</param>
            <param name="order">排序</param>
            <param name="page">分页</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetSortUrl(System.String)">
            <summary>获取排序的Url</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetPageUrl(System.String,System.Int64)">
            <summary>获取分页Url</summary>
            <param name="name"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetPage(System.String)">
            <summary>获取分页Url</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.PluginHelper">
            <summary>插件助手</summary>
        </member>
        <member name="M:NewLife.Web.PluginHelper.LoadPlugin(System.String,System.String,System.String,System.String,System.String)">
            <summary>加载插件</summary>
            <param name="typeName"></param>
            <param name="disname"></param>
            <param name="dll"></param>
            <param name="linkName"></param>
            <param name="urls">提供下载地址的多个目标页面</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.TokenModel">
            <summary>访问令牌模型</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.AccessToken">
            <summary>访问令牌</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.TokenType">
            <summary>令牌类型</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.ExpireIn">
            <summary>过期时间。秒</summary>
        </member>
        <member name="P:NewLife.Web.TokenModel.RefreshToken">
            <summary>刷新令牌</summary>
        </member>
        <member name="T:NewLife.Web.TokenProvider">
            <summary>令牌提供者</summary>
            <remarks>
            文档 https://www.yuque.com/smartstone/nx/token_provider
            </remarks>
        </member>
        <member name="P:NewLife.Web.TokenProvider.Key">
            <summary>密钥。签发方用私钥，验证方用公钥</summary>
        </member>
        <member name="M:NewLife.Web.TokenProvider.ReadKey(System.String,System.Boolean)">
            <summary>读取密钥</summary>
            <param name="file">文件</param>
            <param name="generate">是否生成</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.Encode(System.String,System.DateTime)">
            <summary>编码用户和有效期得到令牌</summary>
            <param name="user">用户</param>
            <param name="expire">有效期</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.Decode(System.String,System.DateTime@)">
            <summary>令牌解码得到用户和有效期</summary>
            <param name="token">令牌</param>
            <param name="expire">有效期</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.TryDecode(System.String,System.String@,System.DateTime@)">
            <summary>尝试解码令牌，即使失败，也会返回用户信息和有效时间</summary>
            <param name="token">令牌</param>
            <param name="user">用户信息</param>
            <param name="expire">有效时间</param>
            <returns>解码结果，成功或失败</returns>
        </member>
        <member name="T:NewLife.Web.WebClientX">
            <summary>扩展的Web客户端</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Timeout">
            <summary>超时，默认15000毫秒</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.LastLink">
            <summary>最后使用的连接名</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.EnsureCreate">
            <summary>创建客户端会话</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.SendAsync(System.String,System.Net.Http.HttpContent)">
            <summary>发送请求，获取响应</summary>
            <param name="address"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadStringAsync(System.String)">
            <summary>下载字符串</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadFileAsync(System.String,System.String)">
            <summary>下载文件</summary>
            <param name="address"></param>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetHtml(System.String)">
            <summary>获取指定地址的Html，自动处理文本编码</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetLinks(System.String)">
            <summary>获取指定地址的Html，分析所有超链接</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadLink(System.String,System.String,System.String)">
            <summary>分析指定页面指定名称的链接，并下载到目标目录，返回目标文件</summary>
            <remarks>
            根据版本或时间降序排序选择
            </remarks>
            <param name="urls">指定页面</param>
            <param name="name">页面上指定名称的链接</param>
            <param name="destdir">要下载到的目标目录</param>
            <returns>返回已下载的文件，无效时返回空</returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadLinkAndExtract(System.String,System.String,System.String,System.Boolean)">
            <summary>分析指定页面指定名称的链接，并下载到目标目录，解压Zip后返回目标文件</summary>
            <param name="urls">提供下载地址的多个目标页面</param>
            <param name="name">页面上指定名称的链接</param>
            <param name="destdir">要下载到的目标目录</param>
            <param name="overwrite">是否覆盖目标同名文件</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.WebClientX.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Web.WebHelper">
            <summary>网页工具类</summary>
        </member>
        <member name="P:NewLife.Web.WebHelper.UserHost">
            <summary>用户主机。支持非Web</summary>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParam(System.Text.StringBuilder,System.String)">
            <summary>追加Url参数，不为空时加与符号</summary>
            <param name="sb"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParam(System.Text.StringBuilder,System.String,System.Object)">
            <summary>追加Url参数，不为空时加与符号</summary>
            <param name="sb">字符串构建</param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParams(System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.String},System.String[])">
            <summary>把一个参数字典追加Url参数，指定包含的参数</summary>
            <param name="sb">字符串构建</param>
            <param name="pms">参数字典</param>
            <param name="includes">包含的参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParamsExcept(System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.String},System.String[])">
            <summary>把一个参数字典追加Url参数，排除一些参数</summary>
            <param name="sb">字符串构建</param>
            <param name="pms">参数字典</param>
            <param name="excludes">要排除的参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.AsUri(System.String,System.Uri)">
            <summary>相对路径转Uri</summary>
            <param name="url">相对路径</param>
            <param name="baseUri">基础</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.AppendReturn(System.Uri,System.String,System.String)">
            <summary>打包返回地址</summary>
            <param name="uri"></param>
            <param name="returnUrl"></param>
            <param name="returnKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.AppendReturn(System.String,System.String,System.String)">
            <summary>打包返回地址</summary>
            <param name="url"></param>
            <param name="returnUrl"></param>
            <param name="returnKey"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Xml.SerializableDictionary`2">
            <summary>支持Xml序列化的泛型字典类 </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor">
            <summary></summary>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary></summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary></summary>
            <param name="serializationInfo"></param>
            <param name="streamingContext"></param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.ReadXml(System.Xml.XmlReader)">
            <summary>读取Xml</summary>
            <param name="reader">Xml读取器</param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.WriteXml(System.Xml.XmlWriter)">
            <summary>写入Xml</summary>
            <param name="writer">Xml写入器</param>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1">
            <summary>Xml配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Xml.XmlConfigFileAttribute"/>特性指定配置文件路径以及自动更新时间。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            
            考虑到自动刷新，不提供LoadFile和SaveFile等方法，可通过扩展方法ToXmlFileEntity和ToXmlFile实现。
            
            用户也可以通过配置实体类的静态构造函数修改基类的<see cref="P:NewLife.Xml.XmlConfig`1._.ConfigFile"/>和<see cref="P:NewLife.Xml.XmlConfig`1._.ReloadTime"/>来动态配置加载信息。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1._">
            <summary>一些设置。派生类可以在自己的静态构造函数中指定</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ConfigFile">
            <summary>配置文件路径</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.SaveNew">
            <summary>没有配置文件时是否保存新配置。默认true</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.ConfigFile">
            <summary>配置文件</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.lastWrite">
            <summary>最后写入时间</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.expire">
            <summary>过期时间。如果在这个时间之后再次访问，将检查文件修改时间</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.IsUpdated">
            <summary>是否已更新。通过文件写入时间判断</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.SetExpire">
            <summary>设置过期重新加载配置的时间</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Dispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Load(System.String)">
            <summary>加载指定配置文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save(System.String)">
            <summary>保存到配置文件中去</summary>
            <param name="filename"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnSaving(System.String,System.String,System.String)">
            <summary>
            在持久化配置文件时执行
            如果重写该方法 请注意调用父类 以免造成配置文件不能正常持久化。
            </summary>
            <param name="filename">配置文件全路径</param>
            <param name="oldXml">老配置文件的内容</param>
            <param name="newXml">新配置文件的内容</param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnNew">
            <summary>新创建配置文件时执行</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfigFileAttribute">
            <summary>Xml配置文件特性</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.FileName">
            <summary>配置文件名</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String)">
            <summary>指定配置文件名</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String,System.Int32)">
            <summary>指定配置文件名和重新加载时间（毫秒）</summary>
            <param name="fileName"></param>
            <param name="reloadTime"></param>
        </member>
        <member name="T:NewLife.Xml.XmlHelper">
            <summary>Xml辅助类</summary>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>序列化为Xml字符串</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <param name="useAttribute">是否使用特性输出</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.IO.Stream,System.Text.Encoding,System.Boolean,System.Boolean)">
            <summary>序列化为Xml数据流</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="stream">目标数据流</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <param name="useAttribute">是否使用特性输出</param>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFile(System.Object,System.String,System.Text.Encoding,System.Boolean)">
            <summary>序列化为Xml文件</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="file">目标Xml文件</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.String)">
            <summary>字符串转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="xml">Xml字符串</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.String,System.Type)">
            <summary>字符串转为Xml实体对象</summary>
            <param name="xml">Xml字符串</param>
            <param name="type">实体类型</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.IO.Stream,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="stream">数据流</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.IO.Stream,System.Type,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <param name="stream">数据流</param>
            <param name="type">实体类型</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFileEntity``1(System.String,System.Text.Encoding)">
            <summary>Xml文件转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="file">Xml文件</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlDictionary(System.String)">
            <summary>简单Xml转为字符串字典</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>字符串字典转为Xml</summary>
            <param name="dic"></param>
            <param name="rootName"></param>
            <returns></returns>
        </member>
        <member name="P:LineConnections.HttpClient.HttpResult.Html">
            <summary>
            返回的String类型数据
            </summary>
        </member>
        <member name="P:LineConnections.HttpClient.HttpResult.StatusDescription">
            <summary>
            返回状态说明
            </summary>
        </member>
        <member name="P:LineConnections.HttpClient.HttpResult.StatusCode">
            <summary>
            返回状态码,默认为OK
            </summary>
        </member>
        <member name="M:RestSharp.HttpProxyMgr.GetWebProxyOnce">
            <summary>
            获取单次可用的http代理
            </summary>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:RestSharp.HttpProxyMgr.GetOnceProxy">
            <summary>
            获取单次可用的htpp代理
            </summary>
            <returns></returns>
        </member>
        <member name="T:RestSharp.info_proxy">
            <summary> 
            [info_proxy]
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.id">
            <summary> 
            [id]
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.username">
            <summary> 
            [username]
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.password">
            <summary> 
            [password]
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.proxyurl">
            <summary> 
            [proxyurl]
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.proxyport">
            <summary> 
            [proxyport]
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.state">
            <summary> 
            [state]0 禁用 1 可用 2 正在使用
            </summary> 
        </member>
        <member name="P:RestSharp.info_proxy.updated_at">
            <summary> 
            [updated_at]
            </summary> 
        </member>
        <member name="M:RestSharp.RestClientProxy.#ctor(System.Uri)">
            <inheritdoc />
            <summary>
            Sets the BaseUrl property for requests made by this client instance
            </summary>
            <param name="baseUrl"></param>
        </member>
        <member name="M:RestSharp.RestClientProxy.InitProxy(System.Net.IWebProxy,System.Boolean)">
            <summary>
            初始化http代理
            </summary>
            <param name="webProxy"></param>
        </member>
        <member name="M:RestSharp.RestSharpHelper.DoExecute(RestSharp.RestClient,RestSharp.IRestRequest)">
            <summary>
            执行重置 User-Agent 的 Execute
            此处暂时处理,需要更改 RestSharp bug
            </summary>
            <param name="client"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="T:JJYRest.RPC.OutArg`2">
            <summary>
            继承后的序列化需要显示指定,且不能继承
            </summary>
            <typeparam name="R1"></typeparam>
            <typeparam name="R2"></typeparam>
        </member>
        <member name="P:JJYRest.SerializeDataSet.Tables">
            <summary>
            所有列
            </summary>
        </member>
        <member name="P:JJYRest.SerializeDataTable.Colunms">
            <summary>
            所有列
            </summary>
        </member>
        <member name="T:PrimS.Telnet.BaseClient">
            <summary>
            The base class for Clients.
            </summary>
            <summary>
            The base class for Clients.
            </summary>
        </member>
        <member name="F:PrimS.Telnet.BaseClient.DefaultTimeoutMs">
            <summary>
            The default time out ms.
            </summary>
        </member>
        <member name="F:PrimS.Telnet.BaseClient.byteStream">
            <summary>
            The byte stream.
            </summary>
        </member>
        <member name="P:PrimS.Telnet.BaseClient.IsConnected">
            <summary>
            Gets a value indicating whether this instance is connected.
            </summary>
            <value>
            <c>true</c> if this instance is connected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:PrimS.Telnet.BaseClient.ByteStream">
            <summary>
            Gets the byte stream.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.BaseClient.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.BaseClient.IsTerminatorLocated(System.String,System.String)">
            <summary>
            Determines whether the specified terminator has been located.
            </summary>
            <param name="terminator">The terminator to search for.</param>
            <param name="s">The content to search for the <paramref name="terminator"/>.</param>
            <returns>True if the terminator is located, otherwise false.</returns>
        </member>
        <member name="M:PrimS.Telnet.BaseClient.IsRegexLocated(System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Determines whether the specified Regex has been located.
            </summary>
            <param name="regex">The Regex to search for.</param>
            <param name="s">The content to search for the <paramref name="regex"/>.</param>
            <returns>True if the Regex is matched, otherwise false.</returns>
        </member>
        <member name="F:PrimS.Telnet.BaseClient.sendRateLimit">
            <summary>
            The send rate limit.
            </summary>
        </member>
        <member name="F:PrimS.Telnet.BaseClient.internalCancellation">
            <summary>
            The internal cancellation token.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.BaseClient.#ctor(PrimS.Telnet.IByteStream,System.Threading.CancellationToken)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.BaseClient"/> class.
            </summary>
            <param name="byteStream">The byte stream.</param>
            <param name="token">The token.</param>
        </member>
        <member name="P:PrimS.Telnet.BaseClient.SendRateLimit">
            <summary>
            Gets the send rate limit.
            </summary>
        </member>
        <member name="P:PrimS.Telnet.BaseClient.InternalCancellation">
            <summary>
            Gets the internal cancellation token.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.BaseClient.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:PrimS.Telnet.ByteStreamHandler">
            <summary>
            Provides core functionality for interacting with the ByteStream.
            </summary>
            <summary>
            Provides core functionality for interacting with the ByteStream.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.ByteStreamHandler.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.ByteStreamHandler.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="M:PrimS.Telnet.ByteStreamHandler.#ctor(PrimS.Telnet.IByteStream,System.Threading.CancellationTokenSource)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.ByteStreamHandler"/> class.
            </summary>
            <param name="byteStream">The byteStream to handle.</param>
            <param name="internalCancellation">A cancellation token.</param>
        </member>
        <member name="M:PrimS.Telnet.ByteStreamHandler.Read(System.TimeSpan)">
            <summary>
            Reads from the stream.
            </summary>
            <param name="timeout">The rolling timeout to wait for no further response from stream.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="T:PrimS.Telnet.Client">
            <inheritdoc />
            <summary>
            Basic Telnet client.
            </summary>
            <summary>
            Basic Telnet client.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.Client.TryLogin(System.String,System.String,System.Int32,System.String,System.String)">
            <summary>
            Tries to login.
            </summary>
            <param name="userName">The user name.</param>
            <param name="password">The password.</param>
            <param name="loginTimeOutMs">The login time out ms.</param>
            <param name="terminator">The terminator.</param>
            <param name="lineFeed">The line feed to use. Issue 38: According to RFC 854, CR+LF should be the default a client sends. For backward compatibility \n maintained.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.WriteLine(System.String,System.String)">
            <summary>
            Writes the line to the server.
            </summary>
            <param name="command">The command.</param>
            <param name="lineFeed">The line feed to use. Issue 38: According to RFC 854, CR+LF should be the default a client sends. For backward compatibility \n maintained.</param>
        </member>
        <member name="M:PrimS.Telnet.Client.Write(System.String)">
            <summary>
            Writes the specified command to the server.
            </summary>
            <param name="command">The command.</param>
        </member>
        <member name="M:PrimS.Telnet.Client.Read">
            <summary>
            Reads asynchronously from the stream.
            </summary>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.TerminatedRead(System.String)">
            <summary>
            Reads asynchronously from the stream, terminating as soon as the <paramref name="terminator"/> is located.
            </summary>
            <param name="terminator">The terminator.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.TerminatedRead(System.Text.RegularExpressions.Regex)">
            <summary>
            Reads asynchronously from the stream, terminating as soon as the <paramref name="regex"/> is matched.
            </summary>
            <param name="regex">The regex to match.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.TerminatedRead(System.String,System.TimeSpan)">
            <summary>
            Reads synchronously from the stream, terminating as soon as the <paramref name="terminator"/> is located.
            </summary>
            <param name="terminator">The terminator.</param>
            <param name="timeout">The timeout.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.TerminatedRead(System.Text.RegularExpressions.Regex,System.TimeSpan)">
            <summary>
            Reads synchronously from the stream, terminating as soon as the/> is located.
            </summary>
            <param name="regex">The terminator.</param>
            <param name="timeout">The timeout.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.TerminatedRead(System.String,System.TimeSpan,System.Int32)">
            <summary>
            Reads synchronously from the stream, terminating as soon as the <paramref name="terminator"/> is located.
            </summary>
            <param name="terminator">The terminator.</param>
            <param name="timeout">The maximum time to wait.</param>
            <param name="millisecondSpin">The millisecond spin between each read from the stream.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.TerminatedRead(System.Text.RegularExpressions.Regex,System.TimeSpan,System.Int32)">
            <summary>
            Reads synchronously from the stream, terminating as soon as the <paramref name="regex"/> is matched.
            </summary>
            <param name="regex">The regex to match.</param>
            <param name="timeout">The maximum time to wait.</param>
            <param name="millisecondSpin">The millisecond spin between each read from the stream.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="M:PrimS.Telnet.Client.#ctor(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.Client"/> class.
            </summary>
            <param name="hostname">The hostname.</param>
            <param name="port">The port.</param>
            <param name="token">The cancellation token.</param>
        </member>
        <member name="M:PrimS.Telnet.Client.Read(System.TimeSpan)">
            <summary>
            Reads from the stream.
            </summary>
            <param name="timeout">The timeout.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="T:PrimS.Telnet.IByteStream">
            <summary>
            Contract of core functionality provided by a ByteStream.
            </summary>
        </member>
        <member name="P:PrimS.Telnet.IByteStream.Available">
            <summary>
            Gets the amount of data that has been received from the network and is available to be read.
            </summary>
            <value>
            The number of bytes of data received from the network and available to be read.
            </value>
            <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.Socket has been closed.</exception>
        </member>
        <member name="P:PrimS.Telnet.IByteStream.Connected">
            <summary>
            Gets a value indicating whether this <see cref="T:PrimS.Telnet.IByteStream"/> is connected.
            </summary>
            <value>
              <c>True</c> if connected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:PrimS.Telnet.IByteStream.ReceiveTimeout">
            <summary>
            Gets or sets the amount of time this <see cref="T:PrimS.Telnet.IByteStream"/> will wait to receive data once a read operation is initiated.
            </summary>
            <value>
            The time-out value of the connection in milliseconds. The default value is 0.
            </value>
        </member>
        <member name="M:PrimS.Telnet.IByteStream.Close">
            <summary>
            Disposes the instance and requests that the underlying connection be closed.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.IByteStream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            <returns>The unsigned byte cast to an integer, or -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">The stream does not support reading.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:PrimS.Telnet.IByteStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances the position within the stream by one byte.
            </summary>
            <param name="value">The byte to write to the stream.</param>
            <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
            <exception cref="T:System.NotSupportedException">The stream does not support writing, or the stream is already closed.</exception>
            <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
        </member>
        <member name="M:PrimS.Telnet.IByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write data from.</param>
            <param name="offset">The zero-based byte offset in buffer from which to begin copying bytes to the stream.</param>
            <param name="count">The maximum number of bytes to write.</param>
            <exception cref="T:System.ArgumentNullException">The buffer parameter is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The offset parameter is less than 0.-or- The offset parameter is greater than the length of buffer.-or- The size parameter is less than 0.-or- The size parameter is greater than the length of buffer minus the value of the offset parameter.</exception>
            <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
            <exception cref="T:System.IO.IOException">There was a failure while writing to the network. -or-An error occurred when accessing the socket. See the Remarks section for more information.</exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.NetworkStream is closed.-or- There was a failure reading from the network.</exception>
        </member>
        <member name="M:PrimS.Telnet.IByteStream.Write(System.String)">
            <summary>
            Writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="value">The string to write.</param>
            <exception cref="T:System.ArgumentNullException">The buffer parameter is null.</exception>
            <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
            <exception cref="T:System.IO.IOException">There was a failure while writing to the network. -or-An error occurred when accessing the socket. See the Remarks section for more information.</exception>
            <exception cref="T:System.ObjectDisposedException">The System.Net.Sockets.NetworkStream is closed.-or- There was a failure reading from the network.</exception>
        </member>
        <member name="T:PrimS.Telnet.IByteStreamHandler">
            <summary>
            Contract of core functionality required to interact with a ByteStream.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.IByteStreamHandler.Read(System.TimeSpan)">
            <summary>
            Reads for up to the specified timeout.
            </summary>
            <param name="timeout">The timeout.</param>
            <returns>Any text read from the stream.</returns>
        </member>
        <member name="T:PrimS.Telnet.INetworkStream">
            <summary>
            A network stream that can be read and written to.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.INetworkStream.ReadByte">
            <summary>
            Reads the next byte.
            </summary>
            <returns>The next byte read.</returns>
        </member>
        <member name="M:PrimS.Telnet.INetworkStream.WriteByte(System.Byte)">
            <summary>
            Writes the byte.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PrimS.Telnet.INetworkStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the specified buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="size">The size.</param>
        </member>
        <member name="T:PrimS.Telnet.IsNotDeadCodeAttribute">
            <summary>
            Suppress IsDeadCode warning.
            </summary>
        </member>
        <member name="T:PrimS.Telnet.ISocket">
            <summary>
            A socket to connect to.
            </summary>
        </member>
        <member name="P:PrimS.Telnet.ISocket.Connected">
            <summary>
            Gets a value indicating whether this <see cref="T:PrimS.Telnet.ISocket" /> is connected.
            </summary>
            <value>
            <c>true</c> if connected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:PrimS.Telnet.ISocket.Available">
            <summary>
            Gets the available bytes to be read.
            </summary>
            <value>
            The available bytes to be read.
            </value>
        </member>
        <member name="P:PrimS.Telnet.ISocket.ReceiveTimeout">
            <summary>
            Gets or sets the receive timeout.
            </summary>
            <value>
            The receive timeout.
            </value>
        </member>
        <member name="M:PrimS.Telnet.ISocket.GetStream">
            <summary>
            Gets the stream.
            </summary>
            <returns>Network stream socket connected to.</returns>
        </member>
        <member name="M:PrimS.Telnet.ISocket.Close">
            <summary>
            Closes this instance.
            </summary>
        </member>
        <member name="T:PrimS.Telnet.NetworkStream">
            <summary>
            An implementation of a network stream to read from and write to.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.NetworkStream.#ctor(System.Net.Sockets.NetworkStream)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.NetworkStream" /> class.
            </summary>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:PrimS.Telnet.NetworkStream.ReadByte">
            <summary>
            Reads the next byte.
            </summary>
            <returns>
            The next byte read.
            </returns>
        </member>
        <member name="M:PrimS.Telnet.NetworkStream.WriteByte(System.Byte)">
            <summary>
            Writes the byte.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PrimS.Telnet.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the specified buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:PrimS.Telnet.NetworkStream.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.NetworkStream.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <param name="disposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:PrimS.Telnet.TcpByteStream">
            <summary>
            A ByteStream acting over a TCP channel.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.#ctor(System.String,System.Int32)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.TcpByteStream" /> class. 
            </summary>
            <param name="hostName">The host name.</param>
            <param name="port">The port.</param>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.#ctor(PrimS.Telnet.ISocket)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.TcpByteStream" /> class.
            </summary>
            <param name="tcpSocket">The TCP socket.</param>
        </member>
        <member name="P:PrimS.Telnet.TcpByteStream.Available">
            <summary>
            Gets the amount of data that has been received from the network and is available to be read.
            </summary>
            <value>
            The number of bytes of data received from the network and available to be read.
            </value>
        </member>
        <member name="P:PrimS.Telnet.TcpByteStream.Connected">
            <summary>
            Gets a value indicating whether this <see cref="T:PrimS.Telnet.IByteStream" /> is connected.
            </summary>
            <value>
              <c>True</c> if connected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:PrimS.Telnet.TcpByteStream.ReceiveTimeout">
            <summary>
            Gets or sets the amount of time this <see cref="T:PrimS.Telnet.IByteStream" /> will wait to receive data once a read operation is initiated.
            </summary>
            <value>
            The time-out value of the connection in milliseconds. The default value is 0.
            </value>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.ReadByte">
            <summary>
            Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.
            </summary>
            <returns>
            The unsigned byte cast to an integer, or -1 if at the end of the stream.
            </returns>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.WriteByte(System.Byte)">
            <summary>
            Writes a byte to the current position in the stream and advances the position within the stream by one byte.
            </summary>
            <param name="value">The byte to write to the stream.</param>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the specified buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.Write(System.String)">
            <summary>
            Writes the specified command to the stream.
            </summary>
            <param name="value">The command.</param>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.Close">
            <summary>
            Disposes the instance and requests that the underlying connection be closed.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.TcpByteStream.Dispose(System.Boolean)">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <param name="isDisposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
        </member>
        <member name="T:PrimS.Telnet.TcpClient">
            <summary>
            A TcpClient to connect to the specified socket.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.TcpClient.#ctor(System.String,System.Int32)">
            <summary>
            Initialises a new instance of the <see cref="T:PrimS.Telnet.TcpClient"/> class.
            </summary>
            <param name="hostName">The host name.</param>
            <param name="port">The port.</param>
        </member>
        <member name="P:PrimS.Telnet.TcpClient.ReceiveTimeout">
            <summary>
            Gets or sets the receive timeout.
            </summary>
            <value>
            The receive timeout.
            </value>
        </member>
        <member name="P:PrimS.Telnet.TcpClient.Connected">
            <summary>
            Gets a value indicating whether this <see cref="T:PrimS.Telnet.ISocket" /> is connected.
            </summary>
            <value>
              <c>true</c> if connected; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:PrimS.Telnet.TcpClient.Available">
            <summary>
            Gets the available bytes to be read.
            </summary>
            <value>
            The available bytes to be read.
            </value>
        </member>
        <member name="M:PrimS.Telnet.TcpClient.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.TcpClient.Close">
            <summary>
            Closes this instance.
            </summary>
        </member>
        <member name="M:PrimS.Telnet.TcpClient.GetStream">
            <summary>
            Gets the stream.
            </summary>
            <returns>
            Network stream socket connected to.
            </returns>
        </member>
        <member name="T:Microsoft.Extensions.DependencyInjection.DependencyInjectionExtensions">
            <summary>
            DependencyInjectionExtensions
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjectionExtensions.AddRedis(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String)">
            <summary>
            Adds services for FullRedis to the specified Microsoft.Extensions.DependencyInjection.IServiceCollection.
            </summary>
            <param name="services"></param>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjectionExtensions.AddRedis(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String,System.String,System.Int32)">
            <summary>
            Adds services for FullRedis to the specified Microsoft.Extensions.DependencyInjection.IServiceCollection.
            </summary>
            <param name="services"></param>
            <param name="name"></param>
            <param name="config"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.DependencyInjectionExtensions.AddRedis(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Adds services for FullRedis to the specified Microsoft.Extensions.DependencyInjection.IServiceCollection.
            </summary>
            <param name="services"></param>
            <param name="server"></param>
            <param name="psssword"></param>
            <param name="db"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.SwaggerDoc(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.String,Microsoft.OpenApi.Models.OpenApiInfo)">
            <summary>
            Define one or more documents to be created by the Swagger generator
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="name">A URI-friendly name that uniquely identifies the document</param>
            <param name="info">Global metadata to be included in the Swagger output</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.DocInclusionPredicate(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.String,Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription,System.Boolean})">
            <summary>
            Provide a custom strategy for selecting actions.
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="predicate">
            A lambda that returns true/false based on document name and ApiDescription
            </param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.IgnoreObsoleteActions(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Ignore any actions that are decorated with the ObsoleteAttribute
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.ResolveConflictingActions(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Collections.Generic.IEnumerable{Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription},Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription})">
            <summary>
            Merge actions that have conflicting HTTP methods and paths (must be unique for Swagger 2.0)
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="resolver"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.CustomOperationIds(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription,System.String})">
            <summary>
            Provide a custom strategy for assigning "operationId" to operations
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.TagActionsBy(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription,System.String})">
            <summary>
            Provide a custom strategy for assigning a default "tag" to operations
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="tagSelector"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.TagActionsBy(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription,System.Collections.Generic.IList{System.String}})">
            <summary>
            Provide a custom strategy for assigning "tags" to actions
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="tagsSelector"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.OrderActionsBy(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{Microsoft.AspNetCore.Mvc.ApiExplorer.ApiDescription,System.String})">
            <summary>
            Provide a custom strategy for sorting actions before they're transformed into the Swagger format
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="sortKeySelector"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.DescribeAllParametersInCamelCase(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Describe all parameters, regardless of how they appear in code, in camelCase
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.AddServer(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,Microsoft.OpenApi.Models.OpenApiServer)">
            <summary>
            Provide specific server information to include in the generated Swagger document
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="server">A description of the server</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.AddSecurityDefinition(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.String,Microsoft.OpenApi.Models.OpenApiSecurityScheme)">
            <summary>
            Add one or more "securityDefinitions", describing how your API is protected, to the generated Swagger
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="name">A unique name for the scheme, as per the Swagger spec.</param>
            <param name="securityScheme">
            A description of the scheme - can be an instance of BasicAuthScheme, ApiKeyScheme or OAuth2Scheme
            </param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.AddSecurityRequirement(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,Microsoft.OpenApi.Models.OpenApiSecurityRequirement)">
            <summary>
            Adds a global security requirement
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="securityRequirement">
            A dictionary of required schemes (logical AND). Keys must correspond to schemes defined through AddSecurityDefinition
            If the scheme is of type "oauth2", then the value is a list of scopes, otherwise it MUST be an empty array
            </param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.MapType(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Type,System.Func{Microsoft.OpenApi.Models.OpenApiSchema})">
            <summary>
            Provide a custom mapping, for a given type, to the Swagger-flavored JSONSchema
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="type">System type</param>
            <param name="schemaFactory">A factory method that generates Schema's for the provided type</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.MapType``1(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{Microsoft.OpenApi.Models.OpenApiSchema})">
            <summary>
            Provide a custom mapping, for a given type, to the Swagger-flavored JSONSchema
            </summary>
            <typeparam name="T">System type</typeparam>
            <param name="swaggerGenOptions"></param>
            <param name="schemaFactory">A factory method that generates Schema's for the provided type</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.UseInlineDefinitionsForEnums(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Generate inline schema definitions (as opposed to referencing a shared definition) for enum parameters and properties
            </summary>
            <param name="swaggerGenOptions"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.CustomSchemaIds(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Type,System.String})">
            <summary>
            Provide a custom strategy for generating the unique Id's that are used to reference object Schema's
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="schemaIdSelector">
            A lambda that returns a unique identifier for the provided system type
            </param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.IgnoreObsoleteProperties(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Ignore any properties that are decorated with the ObsoleteAttribute
            </summary>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.UseAllOfForInheritance(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Enables composite schema generation. If enabled, subtype schemas will contain the allOf construct to
            incorporate properties from the base class instead of defining those properties inline.
            </summary>
            <param name="swaggerGenOptions"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.UseOneOfForPolymorphism(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Enables polymorphic schema generation. If enabled, request and response schemas will contain the oneOf
            construct to describe sub types as a set of alternative schemas.
            </summary>
            <param name="swaggerGenOptions"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.SelectSubTypesUsing(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}})">
            <summary>
            To support polymorphism and inheritance behavior, Swashbuckle needs to detect the "known" subtypes for a given base type.
            That is, the subtypes exposed by your API. By default, this will be any subtypes in the same assembly as the base type.
            To override this, you can provide a custom selector function. This setting is only applicable when used in conjunction with
            UseOneOfForPolymorphism and/or UseAllOfForInheritance.
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="customSelector"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.SelectDiscriminatorNameUsing(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Type,System.String})">
            <summary>
            If the configured serializer supports polymorphic serialization/deserialization by emitting/accepting a special "discriminator" property,
            and UseOneOfForPolymorphism is enabled, then Swashbuckle will include a description for that property based on the serializer's behavior.
            However, if you've customized your serializer to support polymorphism, you can provide a custom strategy to tell Swashbuckle which property,
            for a given type, will be used as a discriminator. This setting is only applicable when used in conjunction with UseOneOfForPolymorphism.
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="customSelector"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.SelectDiscriminatorValueUsing(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Type,System.String})">
            <summary>
            If the configured serializer supports polymorphic serialization/deserialization by emitting/accepting a special "discriminator" property,
            and UseOneOfForPolymorphism is enabled, then Swashbuckle will include a mapping of possible discriminator values to schema definitions.
            However, if you've customized your serializer to support polymorphism, you can provide a custom mapping strategy to tell Swashbuckle what
            the discriminator value should be for a given sub type. This setting is only applicable when used in conjunction with UseOneOfForPolymorphism.
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="customSelector"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.UseAllOfToExtendReferenceSchemas(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Extend reference schemas (using the allOf construct) so that contextual metadata can be applied to all parameter and property schemas
            </summary>
            <param name="swaggerGenOptions"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.SupportNonNullableReferenceTypes(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions)">
            <summary>
            Enable detection of non nullable reference types to set Nullable flag accordingly on schema properties
            </summary>
            <param name="swaggerGenOptions"></param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.SchemaFilter``1(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Object[])">
            <summary>
            Extend the Swagger Generator with "filters" that can modify Schemas after they're initially generated
            </summary>
            <typeparam name="TFilter">A type that derives from ISchemaFilter</typeparam>
            <param name="swaggerGenOptions"></param>
            <param name="arguments">Optionally inject parameters through filter constructors</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.ParameterFilter``1(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Object[])">
            <summary>
            Extend the Swagger Generator with "filters" that can modify Parameters after they're initially generated
            </summary>
            <typeparam name="TFilter">A type that derives from IParameterFilter</typeparam>
            <param name="swaggerGenOptions"></param>
            <param name="arguments">Optionally inject parameters through filter constructors</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.RequestBodyFilter``1(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Object[])">
            <summary>
            Extend the Swagger Generator with "filters" that can modify RequestBodys after they're initially generated
            </summary>
            <typeparam name="TFilter">A type that derives from IRequestBodyFilter</typeparam>
            <param name="swaggerGenOptions"></param>
            <param name="arguments">Optionally inject parameters through filter constructors</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.OperationFilter``1(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Object[])">
            <summary>
            Extend the Swagger Generator with "filters" that can modify Operations after they're initially generated
            </summary>
            <typeparam name="TFilter">A type that derives from IOperationFilter</typeparam>
            <param name="swaggerGenOptions"></param>
            <param name="arguments">Optionally inject parameters through filter constructors</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.DocumentFilter``1(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Object[])">
            <summary>
            Extend the Swagger Generator with "filters" that can modify SwaggerDocuments after they're initially generated
            </summary>
            <typeparam name="TFilter">A type that derives from IDocumentFilter</typeparam>
            <param name="swaggerGenOptions"></param>
            <param name="arguments">Optionally inject parameters through filter constructors</param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.IncludeXmlComments(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Xml.XPath.XPathDocument},System.Boolean)">
            <summary>
            Inject human-friendly descriptions for Operations, Parameters and Schemas based on XML Comment files
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="xmlDocFactory">A factory method that returns XML Comments as an XPathDocument</param>
            <param name="includeControllerXmlComments">
            Flag to indicate if controller XML comments (i.e. summary) should be used to assign Tag descriptions.
            Don't set this flag if you're customizing the default tag for operations via TagActionsBy.
            </param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.IncludeXmlComments(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.String,System.Boolean)">
            <summary>
            Inject human-friendly descriptions for Operations, Parameters and Schemas based on XML Comment files
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="filePath">An abolsute path to the file that contains XML Comments</param>
            <param name="includeControllerXmlComments">
            Flag to indicate if controller XML comments (i.e. summary) should be used to assign Tag descriptions.
            Don't set this flag if you're customizing the default tag for operations via TagActionsBy.
            </param>
        </member>
        <member name="M:Microsoft.Extensions.DependencyInjection.SwaggerGenOptionsExtensions.GeneratePolymorphicSchemas(Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Func{System.Type,System.String})">
            <summary>
            Generate polymorphic schemas (i.e. "oneOf") based on discovered subtypes.
            Deprecated: Use the \"UseOneOfForPolymorphism\" and \"UseAllOfForInheritance\" settings instead
            </summary>
            <param name="swaggerGenOptions"></param>
            <param name="subTypesResolver"></param>
            <param name="discriminatorSelector"></param>
        </member>
        <member name="T:Microsoft.Extensions.ApiDescriptions.IDocumentProvider">
            <summary>
            This service will be looked up by name from the service collection when using
            the <c>dotnet-getdocument</c> tool from the Microsoft.Extensions.ApiDescription.Server package.
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Builder.SwaggerBuilderExtensions.UseSwagger(Microsoft.AspNetCore.Builder.IApplicationBuilder,Swashbuckle.AspNetCore.Swagger.SwaggerOptions)">
            <summary>
            Register the Swagger middleware with provided options
            </summary>
        </member>
        <member name="M:Microsoft.AspNetCore.Builder.SwaggerBuilderExtensions.UseSwagger(Microsoft.AspNetCore.Builder.IApplicationBuilder,System.Action{Swashbuckle.AspNetCore.Swagger.SwaggerOptions})">
            <summary>
            Register the Swagger middleware with optional setup action for DI-injected options
            </summary>
        </member>
        <member name="T:Masuit.Tools.DateTimeExt.ChineseCalendar">
            <summary>
            中国农历类 支持 1900.1.31日起至 2069.12.31日止的数据
            </summary>
            <remarks>
            本程序使用数据来源于网上的万年历查询，并综合了一些其它数据
            </remarks>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar._cIsLeapMonth">
            <summary>
            当月是否闰月
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar._cIsLeapYear">
            <summary>
            当年是否有闰月
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar.LunarDateArray">
             <summary>
             来源于网上的农历数据
             </summary>
             <remarks>
             数据结构如下，共使用17位数据
             第17位：表示闰月天数，0表示29天   1表示30天
             第16位-第5位（共12位）表示12个月，其中第16位表示第一月，如果该月为30天则为1，29天为0
             第4位-第1位（共4位）表示闰月是哪个月，如果当年没有闰月，则置0
            </remarks>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar.ConstellationName">
            <summary>
            星座
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar.LunarHolidayName">
            <summary>
            二十四节气
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseConstellationName">
            <summary>
            二十八星宿
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.ChineseCalendar.SolarTerm">
            <summary>
            节气数据
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.CustomWorkDays">
            <summary>
            自定义的工作日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.CustomHolidays">
            <summary>
            自定义的节假日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.SolarHolidayInfo">
            <summary>
            按公历计算的通用节假日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.LunarHolidayInfo">
            <summary>
            按农历计算的通用节假日
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.#ctor(System.DateTime)">
            <summary>
            用一个标准的公历日期来初使化
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            用农历的日期来初使化
            </summary>
            <param name="cy">农历年</param>
            <param name="cm">农历月</param>
            <param name="cd">农历日</param>
            <param name="leapMonthFlag">闰月标志</param>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.GetChineseMonthDays(System.Int32,System.Int32)">
            <summary>
            传回农历 y年m月的总天数
            </summary>
            <param name="year"></param>
            <param name="month"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.GetChineseLeapMonth(System.Int32)">
            <summary>
            传回农历 y年闰哪个月 1-12 , 没闰传回 0
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.GetChineseLeapMonthDays(System.Int32)">
            <summary>
            传回农历 y年闰月的天数
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.GetChineseYearDays(System.Int32)">
            <summary>
            取农历年一年的天数
            </summary>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.GetChineseHour(System.DateTime)">
            <summary>
            获得当前时间的时辰
            </summary>
            <param name="dt"></param>
            <returns></returns>
            
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.CheckChineseDateLimit(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            检查农历日期是否合理
            </summary>
            <param name="year"></param>
            <param name="month"></param>
            <param name="day"></param>
            <param name="leapMonth"></param>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.ConvertNumToChineseNum(System.Char)">
            <summary>
            将0-9转成汉字形式
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.BitTest32(System.Int32,System.Int32)">
            <summary>
            测试某位是否为真
            </summary>
            <param name="num"></param>
            <param name="bitpostion"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.ConvertDayOfWeek(System.DayOfWeek)">
            <summary>
            将星期几转成数字表示
            </summary>
            <param name="dayOfWeek"></param>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.CompareWeekDayHoliday(System.DateTime,System.Int32,System.Int32,System.Int32)">
            <summary>
            比较当天是不是指定的第周几
            </summary>
            <param name="date"></param>
            <param name="month"></param>
            <param name="week"></param>
            <param name="day"></param>
            <returns></returns>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseCalendarHoliday">
            <summary>
            计算中国农历节日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.WeekDayHoliday">
            <summary>
            按某月第几周第几日计算的节日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.DateHoliday">
            <summary>
            按公历日计算的节日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.IsHoliday">
            <summary>
            今天是否是假期
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.IsWorkDay">
            <summary>
            今天是否是工作日
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.IsWeekend">
            <summary>
            是否是周末
            </summary>
            <returns></returns>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.Date">
            <summary>
            取对应的公历日期
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.WeekDay">
            <summary>
            取星期几
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.WeekDayStr">
            <summary>
            周几的字符
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.DateString">
            <summary>
            公历日期中文表示法 如一九九七年七月一日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.IsLeapYear">
            <summary>
            当前是否公历闰年
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseConstellation">
            <summary>
            28星宿计算
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseHour">
            <summary>
            时辰
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.Today">
            <summary>
            农历今天
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.IsChineseLeapMonth">
            <summary>
            是否闰月
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.IsChineseLeapYear">
            <summary>
            当年是否有闰月
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseDay">
            <summary>
            农历日
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseDayString">
            <summary>
            农历日中文表示
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseMonth">
            <summary>
            农历的月份
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseMonthString">
            <summary>
            农历月份字符串
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseYear">
            <summary>
            取农历年份
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseYearString">
            <summary>
            取农历年字符串如，一九九七年
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseDateString">
            <summary>
            取农历日期表示法：农历一九九七年正月初五
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseTwentyFourDay">
            <summary>
            定气法计算二十四节气,二十四节气是按地球公转来计算的，并非是阴历计算的
            </summary>
            <remarks>
            节气的定法有两种。古代历法采用的称为"恒气"，即按时间把一年等分为24份，
            每一节气平均得15天有余，所以又称"平气"。现代农历采用的称为"定气"，即
            按地球在轨道上的位置为标准，一周360°，两节气之间相隔15°。由于冬至时地
            球位于近日点附近，运动速度较快，因而太阳在黄道上移动15°的时间不到15天。
            夏至前后的情况正好相反，太阳在黄道上移动较慢，一个节气达16天之多。采用
            定气时可以保证春、秋两分必然在昼夜平分的那两天。
            </remarks>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseTwentyFourPrevDay">
            <summary>
            当前日期前一个最近节气
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.ChineseTwentyFourNextDay">
            <summary>
            当前日期后一个最近节气
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.Constellation">
            <summary>
            计算指定日期的星座序号 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.Animal">
            <summary>
            计算属相的索引，注意虽然属相是以农历年来区别的，但是目前在实际使用中是按公历来计算的
            鼠年为1,其它类推
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.AnimalString">
            <summary>
            取属相字符串
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.GanZhiYearString">
            <summary>
            取农历年的干支表示法如 乙丑年
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.GanZhiMonthString">
            <summary>
            取干支的月表示字符串，注意农历的闰月不记干支
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.GanZhiDayString">
            <summary>
            取干支日表示法
            </summary>
        </member>
        <member name="P:Masuit.Tools.DateTimeExt.ChineseCalendar.GanZhiDateString">
            <summary>
            取当前日期的干支表示法如 甲子年乙丑月丙庚日
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.NextDay">
            <summary>
            取下一天
            </summary>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.PervDay">
            <summary>
            取前一天
            </summary>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.AddDays(System.Int32)">
            <summary>
            取下n天
            </summary>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.AddWorkDays(System.Int32)">
            <summary>
            取下n天
            </summary>
            <returns></returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.ChineseCalendar.AddMonths(System.Int32)">
            <summary>
            加n月
            </summary>
            <returns></returns>
        </member>
        <member name="T:Masuit.Tools.DateTimeExt.DateInfoStruct">
            <summary>
            日期信息
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.DateInfoStruct.Month">
            <summary>
            月
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.DateInfoStruct.Day">
            <summary>
            日
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.DateInfoStruct.Recess">
            <summary>
            假期长度
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.DateInfoStruct.HolidayName">
            <summary>
            节假日名
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateInfoStruct.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            日期信息
            </summary>
            <param name="month"></param>
            <param name="day"></param>
            <param name="recess"></param>
            <param name="name"></param>
        </member>
        <member name="T:Masuit.Tools.DateTimeExt.DateTimeHelper">
            <summary>
            日期时间帮助类
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateTimeHelper.GetWeekAmount(System.DateTime,System.Int32)">
            <summary>
            获取某一年有多少周
            </summary>
            <param name="_"></param>
            <param name="year">年份</param>
            <returns>该年周数</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateTimeHelper.WeekOfYear(System.DateTime)">
            <summary>
            返回年度第几个星期   默认星期日是第一天
            </summary>
            <param name="date">时间</param>
            <returns>第几周</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateTimeHelper.WeekOfYear(System.DateTime,System.DayOfWeek)">
            <summary>
            返回年度第几个星期
            </summary>
            <param name="date">时间</param>
            <param name="week">一周的开始日期</param>
            <returns>第几周</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateTimeHelper.GetWeekTime(System.DateTime,System.Int32,System.Int32,System.DateTime@,System.DateTime@)">
            <summary>
            得到一年中的某周的起始日和截止日
            年 nYear
            周数 nNumWeek
            周始 out dtWeekStart
            周终 out dtWeekeEnd
            </summary>
            <param name="_"></param>
            <param name="nYear">年份</param>
            <param name="nNumWeek">第几周</param>
            <param name="dtWeekStart">开始日期</param>
            <param name="dtWeekeEnd">结束日期</param>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateTimeHelper.GetWeekWorkTime(System.DateTime,System.Int32,System.Int32,System.DateTime@,System.DateTime@)">
            <summary>
            得到一年中的某周的起始日和截止日    周一到周五  工作日
            </summary>
            <param name="_"></param>
            <param name="nYear">年份</param>
            <param name="nNumWeek">第几周</param>
            <param name="dtWeekStart">开始日期</param>
            <param name="dtWeekeEnd">结束日期</param>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.DateTimeHelper.SetLocalTime(System.DateTime)">
            <summary>
            设置本地计算机时间
            </summary>
            <param name="dt">DateTime对象</param>
        </member>
        <member name="T:Masuit.Tools.DateTimeExt.TimeHelper">
            <summary>
            时间相关操作帮助类
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.ReturnDateFormat(System.DateTime,System.Int32,System.String@,System.String@)">
            <summary>
             返回每月的第一天和最后一天
            </summary>
            <param name="_"></param>
            <param name="month">月份</param>
            <param name="firstDay">第一天</param>
            <param name="lastDay">最后一天</param>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetFormatDate(System.DateTime,System.Char)">
            <summary>
            将时间格式化成 年月日 的形式,如果时间为null，返回当前系统时间
            </summary>
            <param name="dt">年月日分隔符</param>
            <param name="separator">分隔符</param>
            <returns>xxxx年xx月xx日</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetFormatTime(System.DateTime,System.Char)">
            <summary>
            将时间格式化成 时分秒 的形式,如果时间为null，返回当前系统时间
            </summary>
            <param name="dt">当前日期时间对象</param>
            <param name="separator">分隔符</param>
            <returns> xx时xx分xx秒 </returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.SecondToMinute(System.DateTime,System.Int32)">
            <summary>
            把秒转换成分钟
            </summary>
            <param name="_"></param>
            <param name="second">秒数</param>
            <returns>分钟数</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetMonthLastDate(System.DateTime,System.Int32,System.Int32)">
            <summary>
            返回某年某月最后一天
            </summary>
            <param name="_"></param>
            <param name="year">年份</param>
            <param name="month">月份</param>
            <returns>日</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.DateDiff2(System.DateTime,System.DateTime)">
            <summary>
            获得两个日期的间隔
            </summary>
            <param name="dateTime1">日期一。</param>
            <param name="dateTime2">日期二。</param>
            <returns>日期间隔TimeSpan。</returns>
            <exception cref="T:System.OverflowException">The return value is less than <see cref="F:System.TimeSpan.MinValue" /> or greater than <see cref="F:System.TimeSpan.MaxValue" />. </exception>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetRandomTime(System.DateTime,System.DateTime)">
            <summary>
            得到随机日期
            </summary>
            <param name="time1">起始日期</param>
            <param name="time2">结束日期</param>
            <returns>间隔日期之间的 随机日期</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.DateConvert(System.String)">
            <summary> 
            Rss日期时间转换，将时间全部转换为GMT时间 
            </summary> 
            <param name="strDateTime">Rss中读取的时间</param> 
            <returns>处理后的标准时间格式</returns> 
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetTimeDelay(System.DateTime,System.DateTime)">
            <summary>
            获得一段时间内有多少小时
            </summary>
            <param name="dtStar">起始时间</param>
            <param name="dtEnd">终止时间</param>
            <returns>小时差</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetDateString(System.DateTime)">
            <summary>
            获得8位时间整型数字
            </summary>
            <param name="dt">当前的日期时间对象</param>
            <returns>8位时间整型数字</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.DateDiff(System.DateTime,System.DateTime)">
            <summary>
            返回时间差
            </summary>
            <param name="dateTime1">时间1</param>
            <param name="dateTime2">时间2</param>
            <returns>时间差</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetDiffTime(System.DateTime,System.DateTime)">
            <summary>
            时间差
            </summary>
            <param name="beginTime">开始时间</param>
            <param name="endTime">结束时间</param>
            <returns>时间差</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.GetDiffTime(System.DateTime,System.DateTime,System.Int32@)">
            <summary>
            计算2个时间差
            </summary>
            <param name="beginTime">开始时间</param>
            <param name="endTime">结束时间</param>
            <param name="mindTime">中间的时间</param>
            <returns>时间差</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.CsharpTime2JavascriptTime(System.DateTime)">
            <summary>
            C#的时间到Javascript的时间的转换
            </summary>
            <param name="theDate">C#的时间</param>
            <returns>Javascript的时间</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.PhpTime2CsharpTime(System.DateTime,System.Int64)">
            <summary>
            PHP的时间转换成C#中的DateTime
            </summary>
            <param name="_"></param>
            <param name="time">php的时间</param>
            <returns>C#的时间</returns>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.TimeHelper.CsharpTime2PhpTime(System.DateTime)">
            <summary>
             C#中的DateTime转换成PHP的时间
            </summary>
            <param name="time">C#时间</param>
            <returns>php时间</returns>
        </member>
        <member name="T:Masuit.Tools.DateTimeExt.WeekHolidayStruct">
            <summary>
            节假日信息
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.WeekHolidayStruct.Month">
            <summary>
            月
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.WeekHolidayStruct.WeekAtMonth">
            <summary>
            这个月第几周
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.WeekHolidayStruct.WeekDay">
            <summary>
            周末日
            </summary>
        </member>
        <member name="F:Masuit.Tools.DateTimeExt.WeekHolidayStruct.HolidayName">
            <summary>
            假日名
            </summary>
        </member>
        <member name="M:Masuit.Tools.DateTimeExt.WeekHolidayStruct.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            节假日信息
            </summary>
            <param name="month"></param>
            <param name="weekAtMonth"></param>
            <param name="weekDay"></param>
            <param name="name"></param>
        </member>
        <member name="T:JZYD.TY.Common.Util.ThreadUtil">
            <summary> 线程工具类 </summary>
        </member>
        <member name="M:JZYD.TY.Common.Util.ThreadUtil.Sync(System.Action)">
            <summary> 异步线程，使用线程池 </summary>
            <param name="act"></param>
        </member>
        <member name="M:JZYD.TY.Common.Util.ThreadUtil.Sleep(System.Int32)">
            <summary> 指定当前线程睡眠多少毫秒 </summary>
            <param name="time"></param>
        </member>
        <member name="M:JZYD.TY.Common.Util.ThreadUtil.Interrupt">
            <summary> 尝试打断当前线程 </summary>
        </member>
        <member name="M:JZYD.TY.Common.Util.ThreadUtil.Interrupt(System.Threading.Thread)">
            <summary> 尝试打断指定线程 </summary>
            <param name="t"></param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksums.Adler32">
            <summary>
            Computes Adler32 checksum for a stream of data. An Adler32
            checksum is not as reliable as a CRC32 checksum, but a lot faster to
            compute.
            
            The specification for Adler32 may be found in RFC 1950.
            ZLIB Compressed Data Format Specification version 3.3)
            
            
            From that document:
            
                 "ADLER32 (Adler-32 checksum)
                  This contains a checksum value of the uncompressed data
                  (excluding any dictionary data) computed according to Adler-32
                  algorithm. This algorithm is a 32-bit extension and improvement
                  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                  standard.
            
                  Adler-32 is composed of two sums accumulated per byte: s1 is
                  the sum of all bytes, s2 is the sum of all s1 values. Both sums
                  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                  Adler-32 checksum is stored as s2*65536 + s1 in most-
                  significant-byte first (network) order."
            
             "8.2. The Adler-32 algorithm
            
               The Adler-32 algorithm is much faster than the CRC32 algorithm yet
               still provides an extremely low probability of undetected errors.
            
               The modulo on unsigned long accumulators can be delayed for 5552
               bytes, so the modulo operation time is negligible.  If the bytes
               are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
               and order sensitive, unlike the first sum, which is just a
               checksum.  That 65521 is prime is important to avoid a possible
               large class of two-byte errors that leave the check unchanged.
               (The Fletcher checksum uses 255, which is not prime and which also
               makes the Fletcher check insensitive to single byte changes 0 -
               255.)
            
               The sum s1 is initialized to 1 instead of zero to make the length
               of the sequence part of s2, so that the length does not have to be
               checked separately. (Any sequence of zeroes has a Fletcher
               checksum of zero.)"
            </summary>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Checksums.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksums.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Adler32.#ctor">
            <summary>
            Creates a new instance of the Adler32 class.
            The checksum starts off with a value of 1.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Adler32.Reset">
            <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with a byte value.
            </summary>
            <param name="value">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Adler32.Update(System.Byte[])">
            <summary>
            Updates the checksum with an array of bytes.
            </summary>
            <param name="buffer">
            The source of the data to update with.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            an array of bytes
            </param>
            <param name="offset">
            the start of the data used for this update
            </param>
            <param name="count">
            the number of bytes to use for this update
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksums.Crc32">
             <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Checksums.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksums.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Checksums.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Checksums.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "value">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Checksums.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            the number of data bytes to add.
            </param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ScanEventArgs">
            <summary>
            Event arguments for scanning.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.ScanEventArgs.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.ScanEventArgs"/>
            </summary>
            <param name="name">The file or directory name.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanEventArgs.Name">
            <summary>
            The fie or directory name for this event.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanEventArgs.ContinueRunning">
            <summary>
            Get set a value indicating if scanning should continue or not.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs">
            <summary>
            Event arguments during processing of a single file or directory.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.ScanEventArgs"/>
            </summary>
            <param name="name">The file or directory name if known.</param>
            <param name="processed">The number of bytes processed so far</param>
            <param name="target">The total number of bytes to process, 0 if not known</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Name">
            <summary>
            The name for this event if known.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.ContinueRunning">
            <summary>
            Get set a value indicating wether scanning should continue or not.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.PercentComplete">
            <summary>
            Get a percentage representing how much of the <see cref="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Target"></see> has been processed
            </summary>
            <value>0.0 to 100.0 percent; 0 if target is not known.</value>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Processed">
            <summary>
            The number of bytes processed so far
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ProgressEventArgs.Target">
            <summary>
            The number of bytes to process.
            </summary>
            <remarks>Target may be 0 or negative if the value isnt known.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs">
            <summary>
            Event arguments for directories.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs.#ctor(System.String,System.Boolean)">
            <summary>
            Initialize an instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs"></see>.
            </summary>
            <param name="name">The name for this directory.</param>
            <param name="hasMatchingFiles">Flag value indicating if any matching files are contained in this directory.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.DirectoryEventArgs.HasMatchingFiles">
            <summary>
            Get a value indicating if the directory contains any matching files or not.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs">
            <summary>
            Arguments passed when scan failures are detected.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs"></see>
            </summary>
            <param name="name">The name to apply.</param>
            <param name="e">The exception to use.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.Name">
            <summary>
            The applicable name.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.Exception">
            <summary>
            The applicable exception.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Core.ScanFailureEventArgs.ContinueRunning">
            <summary>
            Get / set a value indicating wether scanning should continue.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProcessDirectoryHandler">
            <summary>
            Delegate invoked before starting to process a directory.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProcessFileHandler">
            <summary>
            Delegate invoked before starting to process a file.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.ProgressHandler">
            <summary>
            Delegate invoked during processing of a file or directory
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.CompletedFileHandler">
            <summary>
            Delegate invoked when a file has been completely processed.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.DirectoryFailureHandler">
            <summary>
            Delegate invoked when a directory failure is detected.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.FileFailureHandler">
            <summary>
            Delegate invoked when a file failure is detected.
            </summary>
            <param name="sender">The source of the event</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner">
            <summary>
            FileSystemScanner provides facilities scanning of files and directories.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="filter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply when scanning.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(System.String,System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter"> directory filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(ICCEmbedded.SharpZipLib.Core.IScanFilter)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The file <see cref="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.#ctor(ICCEmbedded.SharpZipLib.Core.IScanFilter,ICCEmbedded.SharpZipLib.Core.IScanFilter)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.FileSystemScanner"></see>
            </summary>
            <param name="fileFilter">The file <see cref="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
            <param name="directoryFilter">The directory <see cref="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">filter</see>  to apply.</param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.ProcessDirectory">
            <summary>
            Delegate to invoke when a directory is processed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.ProcessFile">
            <summary>
            Delegate to invoke when a file is processed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.CompletedFile">
            <summary>
            Delegate to invoke when processing for a file has finished.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.DirectoryFailure">
            <summary>
            Delegate to invoke when a directory failure is detected.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.FileFailure">
            <summary>
            Delegate to invoke when a file failure is detected.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnDirectoryFailure(System.String,System.Exception)">
            <summary>
            Raise the DirectoryFailure event.
            </summary>
            <param name="directory">The directory name.</param>
            <param name="e">The exception detected.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnFileFailure(System.String,System.Exception)">
            <summary>
            Raise the FileFailure event.
            </summary>
            <param name="file">The file name.</param>
            <param name="e">The exception detected.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnProcessFile(System.String)">
            <summary>
            Raise the ProcessFile event.
            </summary>
            <param name="file">The file name.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnCompleteFile(System.String)">
            <summary>
            Raise the complete file event
            </summary>
            <param name="file">The file name</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.OnProcessDirectory(System.String,System.Boolean)">
            <summary>
            Raise the ProcessDirectory event.
            </summary>
            <param name="directory">The directory name.</param>
            <param name="hasMatchingFiles">Flag indicating if the directory has matching files.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.Scan(System.String,System.Boolean)">
            <summary>
            Scan a directory.
            </summary>
            <param name="directory">The base directory to scan.</param>
            <param name="recurse">True to recurse subdirectories, false to scan a single directory.</param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.fileFilter_">
            <summary>
            The file filter currently in use.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.directoryFilter_">
            <summary>
            The directory filter currently in use.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Core.FileSystemScanner.alive_">
            <summary>
            Flag indicating if scanning should continue running.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.INameTransform">
            <summary>
            INameTransform defines how file system names are transformed for use with archives.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.INameTransform.TransformFile(System.String)">
            <summary>
            Given a file name determine the transformed value.
            </summary>
            <param name="name">The name to transform.</param>
            <returns>The transformed file name.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.INameTransform.TransformDirectory(System.String)">
            <summary>
            Given a directory name determine the transformed value.
            </summary>
            <param name="name">The name to transform.</param>
            <returns>The transformed directory name</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.IScanFilter">
            <summary>
            Scanning filters support filtering of names.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.IScanFilter.IsMatch(System.String)">
            <summary>
            Test a name to see if it 'matches' the filter.
            </summary>
            <param name="name">The name to test.</param>
            <returns>Returns true if the name matches the filter, false if it does not match.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.NameFilter">
            <summary>
            NameFilter is a string matching class which allows for both positive and negative
            matching.
            A filter is a sequence of independant <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see> separated by semi-colons ';'
            Each expression can be prefixed by a plus '+' sign or a minus '-' sign to denote the expression
            is intended to include or exclude names.  If neither a plus or minus sign is found include is the default
            A given name is tested for inclusion before checking exclusions.  Only names matching an include spec 
            and not matching an exclude spec are deemed to match the filter.
            An empty filter matches any name.
            </summary>
            <example>The following expression includes all name ending in '.dat' with the exception of 'dummy.dat'
            "+\.dat$;-^dummy\.dat$"
            </example>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.#ctor(System.String)">
            <summary>
            Construct an instance based on the filter expression passed
            </summary>
            <param name="filter">The filter expression.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsValidExpression(System.String)">
            <summary>
            Test a string to see if it is a valid regular expression.
            </summary>
            <param name="expression">The expression to test.</param>
            <returns>True if expression is a valid <see cref="T:System.Text.RegularExpressions.Regex"/> false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsValidFilterExpression(System.String)">
            <summary>
            Test an expression to see if it is valid as a filter.
            </summary>
            <param name="toTest">The filter expression to test.</param>
            <returns>True if the expression is valid, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.ToString">
            <summary>
            Convert this filter to its string equivalent.
            </summary>
            <returns>The string equivalent for this filter.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsIncluded(System.String)">
            <summary>
            Test a value to see if it is included by the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value is included, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsExcluded(System.String)">
            <summary>
            Test a value to see if it is excluded by the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value is excluded, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.IsMatch(System.String)">
            <summary>
            Test a value to see if it matches the filter.
            </summary>
            <param name="name">The value to test.</param>
            <returns>True if the value matches, false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.NameFilter.Compile">
            <summary>
            Compile this filter.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.PathFilter">
            <summary>
            PathFilter filters directories and files using a form of <see cref="T:System.Text.RegularExpressions.Regex">regular expressions</see>
            by full path name.
            See <see cref="T:ICCEmbedded.SharpZipLib.Core.NameFilter">NameFilter</see> for more detail on filtering.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.PathFilter.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter"></see>.
            </summary>
            <param name="filter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.NameFilter">filter</see> expression to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.PathFilter.IsMatch(System.String)">
            <summary>
            Test a name to see if it matches the filter.
            </summary>
            <param name="name">The name to test.</param>
            <returns>True if the name matches, false otherwise.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Core.StreamUtils">
            <summary>
            Provides simple <see cref="T:System.IO.Stream"/>" utilities.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/> ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read.</param>
            <param name="buffer">The buffer to fill.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.ReadFully(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read from a <see cref="T:System.IO.Stream"/>" ensuring all the required data is read.
            </summary>
            <param name="stream">The stream to read data from.</param>
            <param name="buffer">The buffer to store data in.</param>
            <param name="offset">The offset at which to begin storing data.</param>
            <param name="count">The number of bytes of data to store.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[],ICCEmbedded.SharpZipLib.Core.ProgressHandler,System.TimeSpan,System.Object,System.String)">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
            <param name="progressHandler">The <see cref="T:ICCEmbedded.SharpZipLib.Core.ProgressHandler">progress handler delegate</see> to use.</param>
            <param name="updateInterval">The minimum <see cref="T:System.TimeSpan"/> between progress updates.</param>
            <param name="sender">The source for this event.</param>
            <param name="name">The name to use with the event.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.Copy(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copy the contents of one <see cref="T:System.IO.Stream"/> to another.
            </summary>
            <param name="source">The stream to source data from.</param>
            <param name="destination">The stream to write data to.</param>
            <param name="buffer">The buffer to use during copying.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Core.StreamUtils.#ctor">
            <summary>
            Initialise an instance of <see cref="T:ICCEmbedded.SharpZipLib.Core.StreamUtils"></see>
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassic">
            <summary>
            PkzipClassic embodies the classic or original encryption facilities used in Pkzip archives.
            While it has been superceded by more recent and more powerful algorithms, its still in use and 
            is viable for preventing casual snooping
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassic.GenerateKeys(System.Byte[])">
            <summary>
            Generates new encryption keys based on given seed
            </summary>
            <param name="seed">The seed value to initialise keys with.</param>
            <returns>A new key value.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase">
            <summary>
            PkzipClassicCryptoBase provides the low level facilities for encryption
            and decryption using the PkzipClassic algorithm.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.TransformByte">
            <summary>
            Transform a single byte 
            </summary>
            <returns>
            The transformed value
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.SetKeys(System.Byte[])">
            <summary>
            Set the key schedule for encryption/decryption.
            </summary>
            <param name="keyData">The data use to set the keys from.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.UpdateKeys(System.Byte)">
            <summary>
            Update encryption keys 
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicCryptoBase.Reset">
            <summary>
            Reset the internal state.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for encryption.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform"></see>
            </summary>
            <param name="keyBlock">The key block to use.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies 
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicEncryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform">
            <summary>
            PkzipClassic CryptoTransform for decryption.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.#ctor(System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform"></see>.
            </summary>
            <param name="keyBlock">The key block to decrypt with.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Transforms the specified region of the specified byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the byte array to use as data.</param>
            <returns>The computed transform.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transforms the specified region of the input byte array and copies 
            the resulting transform to the specified region of the output byte array.
            </summary>
            <param name="inputBuffer">The input for which to compute the transform.</param>
            <param name="inputOffset">The offset into the input byte array from which to begin using data.</param>
            <param name="inputCount">The number of bytes in the input byte array to use as data.</param>
            <param name="outputBuffer">The output to which to write the transform.</param>
            <param name="outputOffset">The offset into the output byte array from which to begin writing data.</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanReuseTransform">
            <summary>
            Gets a value indicating whether the current transform can be reused.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.InputBlockSize">
            <summary>
            Gets the size of the input data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.OutputBlockSize">
            <summary>
            Gets the size of the output data blocks in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.CanTransformMultipleBlocks">
            <summary>
            Gets a value indicating whether multiple blocks can be transformed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicDecryptCryptoTransform.Dispose">
            <summary>
            Cleanup internal state.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged">
            <summary>
            Defines a wrapper object to access the Pkzip algorithm. 
            This class cannot be inherited.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.BlockSize">
            <summary>
            Get / set the applicable block size in bits.
            </summary>
            <remarks>The only valid block size is 8.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.LegalKeySizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">key sizes.</see>
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.GenerateIV">
            <summary>
            Generate an initial vector.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.LegalBlockSizes">
            <summary>
            Get an array of legal <see cref="T:System.Security.Cryptography.KeySizes">block sizes</see>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.Key">
            <summary>
            Get / set the key value applicable.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.GenerateKey">
            <summary>
            Generate a new random key.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.CreateEncryptor(System.Byte[],System.Byte[])">
            <summary>
            Create an encryptor.
            </summary>
            <param name="rgbKey">The key to use for this encryptor.</param>
            <param name="rgbIV">Initialisation vector for the new encryptor.</param>
            <returns>Returns a new PkzipClassic encryptor</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Encryption.PkzipClassicManaged.CreateDecryptor(System.Byte[],System.Byte[])">
            <summary>
            Create a decryptor.
            </summary>
            <param name="rgbKey">Keys to use for this new decryptor.</param>
            <param name="rgbIV">Initialisation vector for the new decryptor.</param>
            <returns>Returns a new decryptor.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for the SharpZipLibrary.
            All library exceptions are derived from this.
            </summary>
            <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater">
             <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
             
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.#ctor">
            <summary>
            Creates a new deflater with default compression level.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
            <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="offset">
            the start of the data.
            </param>
            <param name="count">
            the number of data bytes of input.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="level">
            the new compression level.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetStrategy(ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dictionary">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dictionary">
            The dictionary data
            </param>
            <param name="index">
            The index where dictionary information commences.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.level">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
            <summary>
            Set to true to enable debugging
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine">
            <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">
            Pending buffer to use
            </param>>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
            <param name="flush">True to flush input buffers</param>
            <param name="finish">Finish deflation with the current input.</param>
            <returns>Returns true if progress has been made.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
            <param name="buffer">The buffer containing input data.</param>
            <param name="offset">The offset of the first byte of data.</param>
            <param name="count">The number of bytes of data to use as input.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
            <summary>
            Determines if more <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>		
            <returns>Return true if input is needed via <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
            <param name="buffer">The buffer containing the dictionary data</param>
            <param name="offset">The offset in the buffer for the first byte of data</param>
            <param name="length">The length of the dictionary data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see>
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
            <param name="level">The value to set the level to.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
            <summary>
            Fill the window
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.InsertString">
            <summary>
            Inserts the current string in the head hash and returns the previous
            value for this hash.
            </summary>
            <returns>The previous hash value</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.FindLongestMatch(System.Int32)">
             <summary>
             Find the best (longest) string in the window matching the 
             string starting at strstart.
            
             Preconditions:
             <code>
             strstart + MAX_MATCH &lt;= window.length.</code>
             </summary>
             <param name="curMatch"></param>
             <returns>True if a match greater than the minimum length is found</returns>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.head">
            <summary>
            Hashtable, hashing three characters to an index for window, so
            that window[index]..window[index+2] have this hash code.  
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.prev">
            <summary>
            <code>prev[index &amp; WMASK]</code> points to the previous index that has the
            same hash code as the string starting at index.  This way 
            entries with the same hash code are in a linked list.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.strstart">
            <summary>
            Points to the current character in the window.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.lookahead">
            <summary>
            lookahead is the number of characters starting at strstart in
            window that are valid.
            So window[strstart] until window[strstart+lookahead-1] are valid
            characters.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.window">
            <summary>
            This array contains the part of the uncompressed stream that 
            is of relevance.  The current character is indexed by strstart.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.compressionFunction">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman">
            <summary>
            This is the DeflaterHuffman class.
            
            This class is <i>not</i> thread safe.  This is inherent in the API, due
            to the split of Deflate and SetInput.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CheckEmpty">
            <summary>
            Check that all frequencies are zero
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            At least one frequency is non-zero
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="staticCodes">new codes</param>
            <param name="staticLengths">length for new codes</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CalcBLFreq(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Scan a literal or distance tree to determine the frequencies of the codes
            in the bit length tree.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteTree(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
            <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>		
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="literal">Literal value to add to buffer.</param>
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="distance">Distance code</param>
            <param name="length">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending">
            <summary>
            This class stores the pending output of the Deflater.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
            <summary>
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
             
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream. 
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or 
            footer.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
            <summary>
            Creates a new inflater.
            </summary>
            <param name="noHeader">
            True if no RFC1950/Zlib header and footer fields are expected in the input data
            
            This is used for GZIPed/Zipped input.
            
            For compatibility with
            Sun JDK you should provide one byte of input more than needed in
            this case.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer">
            <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.buffer_">
            <summary>
            Internal work buffer
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufferSize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            Write a byte to buffer
            </summary>
            <param name="value">
            The value to write
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="value">
            The value to write.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="length">number of bytes to write</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">The output array.</param>
            <param name="offset">The offset into output array.</param>
            <param name="length">The maximum number of bytes to store.</param>
            <returns>The number of bytes flushed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            The internal buffer contents converted to a byte array.
            </returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br/>
            Authors of the original java version : Tom Tromey, Jochen Hoenicke 
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Deflater)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="deflater">
            the underlying deflater.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufferSize">
            The buffer size to use when deflating
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
            <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater. 
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of the underlying stream.
            When the flag is true <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close"></see> will close the underlying stream also.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Password">
            <summary>
            Get/set the password used for encryption.
            </summary>
            <remarks>When set to null or if the password is empty no encryption is performed</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.EncryptBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encrypt a block of data
            </summary>
            <param name="buffer">
            Data to encrypt.  NOTE the original contents of the buffer are lost
            </param>
            <param name="offset">
            Offset of first byte in buffer to encrypt
            </param>
            <param name="length">
            Number of bytes in buffer to encrypt
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.InitializePassword(System.String)">
            <summary>
            Initializes encryption keys based on given password
            </summary>
            <param name="password">The password.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
            <summary>
            Gets the current position within the stream.
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <param name="value">The new stream length.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <param name="buffer">The buffer to store read data in.</param>
            <param name="offset">The offset to start storing at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous reads are not supported a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to read into.</param>
            <param name="offset">The offset to start storing data at.</param>
            <param name="count">The number of bytes to read</param>
            <param name="callback">The async callback to use.</param>
            <param name="state">The state to use.</param>
            <returns>Returns an <see cref="T:System.IAsyncResult"/></returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous writes arent supported, a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to write.</param>
            <param name="offset">The offset to begin writing at.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> to use.</param>
            <param name="state">The state object.</param>
            <returns>Returns an IAsyncResult.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
            <summary>
            Calls <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish"/> and closes the underlying
            stream when <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="value">
            The byte value.
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buffer">
            The byte array
            </param>
            <param name="offset">
            The offset into the byte array where to start.
            </param>
            <param name="count">
            The number of bytes to write.
            </param>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.buffer_">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.deflater_">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream_">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(ICCEmbedded.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Call <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
            <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform"/> to apply to any data.
            </summary>
            <remarks>Set this value to null to have no transform applied.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="!:ICCEmbedded.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,ICCEmbedded.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close"/> will close the underlying stream also.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name ="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Number of bytes to skip is less than zero
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>		
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
            </summary>
            <param name="buffer">The buffer to write data from</param>
            <param name="offset">Offset of first byte to write</param>
            <param name="count">The maximum number of bytes to write</param>
            <param name="callback">The method to be called when the asynchronous write operation is completed</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
            <returns>An <see cref="T:System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
            <summary>
            Closes the input stream.  When <see cref="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name ="buffer">
            The array to read and decompress data into
            </param>
            <param name ="offset">
            The offset indicating where the data should be placed
            </param>
            <param name ="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:ICCEmbedded.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isStreamOwner">
            <summary>
            Flag indicating wether this instance is designated the stream owner.
            When closing if this flag is true the underlying stream is closed.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
            <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZipEvents">
            <summary>
            FastZipEvents supports all events applicable to <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip">FastZip</see> operations.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessDirectory">
            <summary>
            Delegate to invoke when processing directories.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessFile">
            <summary>
            Delegate to invoke when processing files.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress">
            <summary>
            Delegate to invoke during processing of files.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.CompletedFile">
            <summary>
            Delegate to invoke when processing for a file has been completed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.DirectoryFailure">
            <summary>
            Delegate to invoke when processing directory failures.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.FileFailure">
            <summary>
            Delegate to invoke when processing file failures.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnDirectoryFailure(System.String,System.Exception)">
            <summary>
            Raise the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.DirectoryFailure">directory failure</see> event.
            </summary>
            <param name="directory">The directory causing the failure.</param>
            <param name="e">The exception for this event.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnFileFailure(System.String,System.Exception)">
            <summary>
            Raises the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.FileFailure">file failure delegate</see>.
            </summary>
            <param name="file">The file causing the failure.</param>
            <param name="e">The exception for this failure.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnProcessFile(System.String)">
            <summary>
            Fires the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessFile">Process File delegate</see>.
            </summary>
            <param name="file">The file being processed.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnCompletedFile(System.String)">
            <summary>
            Fires the CompletedFile delegate
            </summary>
            <param name="file">The file whose processing has been completed.</param>
            <returns>A boolean indicating if execution should continue or not.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.OnProcessDirectory(System.String,System.Boolean)">
            <summary>
            Fires the <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProcessDirectory">process directory</see> delegate.
            </summary>
            <param name="directory">The directory being processed.</param>
            <param name="hasMatchingFiles">Flag indicating if the directory has matching files as determined by the current filter.</param>
            <returns>A <see cref="T:System.Boolean"/> of true if the operation should continue; false otherwise.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.ProgressInterval">
            <summary>
            The minimum timespan between <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress"/> events.
            </summary>
            <value>The minimum period of time between <see cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress"/> events.</value>
            <seealso cref="F:ICCEmbedded.SharpZipLib.Zip.FastZipEvents.Progress"/>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZip">
            <summary>
            FastZip provides facilities for creating and extracting zip files.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite">
            <summary>
            Defines the desired handling when overwriting files during extraction.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite.Prompt">
            <summary>
            Prompt the user to confirm overwriting
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite.Never">
            <summary>
            Never overwrite files.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite.Always">
            <summary>
            Always overwrite files.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip"/>.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.#ctor(ICCEmbedded.SharpZipLib.Zip.FastZipEvents)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip"/>
            </summary>
            <param name="events">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZipEvents">events</see> to use during operations.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateEmptyDirectories">
            <summary>
            Get/set a value indicating wether empty directories should be created.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.Password">
            <summary>
            Get / set the password value.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.NameTransform">
            <summary>
            Get or set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"></see> active when creating Zip files.
            </summary>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.FastZip.EntryFactory"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.EntryFactory">
            <summary>
            Get or set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory"></see> active when creating Zip files.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.RestoreDateTimeOnExtract">
            <summary>
            Get/set a value indicating wether file dates and times should 
            be restored when extracting files from an archive.
            </summary>
            <remarks>The default value is false.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.FastZip.RestoreAttributesOnExtract">
            <summary>
            Get/set a value indicating wether file attributes should
            be restored during extract operations
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate">
            <summary>
            Delegate called when confirming overwriting of files.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Create a zip file.
            </summary>
            <param name="zipFileName">The name of the zip file to create.</param>
            <param name="sourceDirectory">The directory to source files from.</param>
            <param name="recurse">True to recurse directories, false for no recursion.</param>
            <param name="fileFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">directory filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateZip(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Create a zip file/archive.
            </summary>
            <param name="zipFileName">The name of the zip file to create.</param>
            <param name="sourceDirectory">The directory to obtain files and directories from.</param>
            <param name="recurse">True to recurse directories, false for no recursion.</param>
            <param name="fileFilter">The file filter to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.CreateZip(System.IO.Stream,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Create a zip archive sending output to the <paramref name="outputStream"/> passed.
            </summary>
            <param name="outputStream">The stream to write archive data to.</param>
            <param name="sourceDirectory">The directory to source files from.</param>
            <param name="recurse">True to recurse directories, false for no recursion.</param>
            <param name="fileFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">file filter</see> to apply.</param>
            <param name="directoryFilter">The <see cref="T:ICCEmbedded.SharpZipLib.Core.PathFilter">directory filter</see> to apply.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,System.String)">
            <summary>
            Extract the contents of a zip file.
            </summary>
            <param name="zipFileName">The zip file to extract from.</param>
            <param name="targetDirectory">The directory to save extracted information in.</param>
            <param name="fileFilter">A filter to apply to files.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.FastZip.ExtractZip(System.String,System.String,ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite,ICCEmbedded.SharpZipLib.Zip.FastZip.ConfirmOverwriteDelegate,System.String,System.String,System.Boolean)">
            <summary>
            Extract the contents of a zip file.
            </summary>
            <param name="zipFileName">The zip file to extract from.</param>
            <param name="targetDirectory">The directory to save extracted information in.</param>
            <param name="overwrite">The style of <see cref="T:ICCEmbedded.SharpZipLib.Zip.FastZip.Overwrite">overwriting</see> to apply.</param>
            <param name="confirmDelegate">A delegate to invoke when confirming overwriting.</param>
            <param name="fileFilter">A filter to apply to files.</param>
            <param name="directoryFilter">A filter to apply to directories.</param>
            <param name="restoreDateTime">Flag indicating wether to restore the date and time for extracted files.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory">
            <summary>
            Defines factory methods for creating new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> values.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a file given its name
            </summary>
            <param name="fileName">The name of the file to create an entry for.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeFileEntry(System.String,System.Boolean)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a file given its name
            </summary>
            <param name="fileName">The name of the file to create an entry for.</param>
            <param name="useFileSystem">If true get details from the file system if the file exists.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">file entry</see> based on the <paramref name="fileName"/> passed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a directory given its name
            </summary>
            <param name="directoryName">The name of the directory to create an entry for.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.MakeDirectoryEntry(System.String,System.Boolean)">
            <summary>
            Create a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a directory given its name
            </summary>
            <param name="directoryName">The name of the directory to create an entry for.</param>
            <param name="useFileSystem">If true get details from the file system for this directory if it exists.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">directory entry</see> based on the <paramref name="directoryName"/> passed.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.IEntryFactory.NameTransform">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"></see> applicable.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.UseZip64">
            <summary>
            Determines how entries are tested to see if they should use Zip64 extensions or not.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.UseZip64.Off">
            <summary>
            Zip64 will not be forced on entries during processing.
            </summary>
            <remarks>An entry can have this overridden if required <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ForceZip64"></see></remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.UseZip64.On">
            <summary>
            Zip64 should always be used.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.UseZip64.Dynamic">
            <summary>
            #ZipLib will determine use based on entry values when added to archive.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.CompressionMethod">
            <summary>
            The kind of compression used for an entry in an archive
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Stored">
            <summary>
            A direct copy of the file contents is held in the archive
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Deflated">
            <summary>
            Common Zip compression method using a sliding dictionary 
            of up to 32KB and secondary compression from Huffman/Shannon-Fano trees
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Deflate64">
            <summary>
            An extension to deflate with a 64KB window. Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.BZip2">
            <summary>
            Not supported by #Zip currently
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.WinZipAES">
            <summary>
            WinZip special for AES encryption, Not supported by #Zip
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm">
            <summary>
            Identifies the encryption algorithm used for an entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.None">
            <summary>
            No encryption has been used.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.PkzipClassic">
            <summary>
            Encrypted using PKZIP 2.0 or 'classic' encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Des">
            <summary>
            DES encryption has been used.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.RC2">
            <summary>
            RCS encryption has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes168">
            <summary>
            Triple DES encryption with 168 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.TripleDes112">
            <summary>
            Triple DES with 112 bit keys has been used for this entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Aes128">
            <summary>
            AES 128 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Aes192">
            <summary>
            AES 192 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Aes256">
            <summary>
            AES 256 has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.RC2Corrected">
            <summary>
            RC2 corrected has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Blowfish">
            <summary>
            Blowfish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Twofish">
            <summary>
            Twofish has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.RC4">
            <summary>
            RCS has been used for encryption.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.EncryptionAlgorithm.Unknown">
            <summary>
            An unknown algorithm has been used for encryption.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags">
            <summary>
            Defines the contents of the general bit flags field for an archive entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Encrypted">
            <summary>
            Bit 0 if set indicates that the file is encrypted
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Method">
            <summary>
            Bits 1 and 2 - Two bits defining the compression method (only for Method 6 Imploding and 8,9 Deflating)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Descriptor">
            <summary>
            Bit 3 if set indicates a trailing data desciptor is appended to the entry data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.ReservedPKware4">
            <summary>
            Bit 4 is reserved for use with method 8 for enhanced deflation
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Patched">
            <summary>
            Bit 5 if set indicates the file contains Pkzip compressed patched data.
            Requires version 2.7 or greater.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.StrongEncryption">
            <summary>
            Bit 6 if set strong encryption has been used for this entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused7">
            <summary>
            Bit 7 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused8">
            <summary>
            Bit 8 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused9">
            <summary>
            Bit 9 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.Unused10">
            <summary>
            Bit 10 is currently unused
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.UnicodeText">
            <summary>
            Bit 11 if set indicates the filename and 
            comment fields for this file must be encoded using UTF-8.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.EnhancedCompress">
            <summary>
            Bit 12 is documented as being reserved by PKware for enhanced compression.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.HeaderMasked">
            <summary>
            Bit 13 if set indicates that values in the local header are masked to hide
            their actual values, and the central directory is encrypted.
            </summary>
            <remarks>
            Used when encrypting the central directory contents.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware14">
            <summary>
            Bit 14 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.GeneralBitFlags.ReservedPkware15">
            <summary>
            Bit 15 is documented as being reserved for use by PKware
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipConstants">
            <summary>
            This class contains constants used for Zip format files
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VersionMadeBy">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CanDecompress"/>.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VERSION_MADE_BY">
            <summary>
            The version made by field for entries in the central header when created by this library
            </summary>
            <remarks>
            This is also the Zip version for the library when comparing against the version required to extract
            for an entry.  See <see cref="!:ZipInputStream.CanDecompressEntry">ZipInputStream.CanDecompressEntry</see>.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VersionStrongEncryption">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VERSION_STRONG_ENCRYPTION">
            <summary>
            The minimum version required to support strong encryption
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.VersionZip64">
            <summary>
            The version required for Zip64 extensions
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LocalHeaderBaseSize">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LOCHDR">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.Zip64DataDescriptorSize">
            <summary>
            Size of Zip64 data descriptor
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.DataDescriptorSize">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EXTHDR">
            <summary>
            Size of data descriptor
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CentralHeaderBaseSize">
            <summary>
            Size of central header entry (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENHDR">
            <summary>
            Size of central header entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EndOfCentralRecordBaseSize">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ENDHDR">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CryptoHeaderSize">
            <summary>
            Size of 'classic' cryptographic header stored before any entry data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CRYPTO_HEADER_SIZE">
            <summary>
            Size of cryptographic header stored before entry data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LocalHeaderSignature">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.LOCSIG">
            <summary>
            Signature for local entry header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SpanningSignature">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SPANNINGSIG">
            <summary>
            Signature for spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SpanningTempSignature">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.SPANTEMPSIG">
            <summary>
            Signature for temporary spanning entry
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.DataDescriptorSignature">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EXTSIG">
            <summary>
            Signature for data descriptor
            </summary>
            <remarks>
            This is only used where the length, Crc, or compressed size isnt known when the
            entry is created and the output stream doesnt support seeking.
            The local entry cannot be 'patched' with the correct values in this case
            so the values are recorded after the data prefixed by this header, as well as in the central directory.
            </remarks>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENSIG">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CentralHeaderSignature">
            <summary>
            Signature for central header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.Zip64CentralFileHeaderSignature">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENSIG64">
            <summary>
            Signature for Zip64 central file header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.Zip64CentralDirLocatorSignature">
            <summary>
            Signature for Zip64 central directory locator
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ArchiveExtraDataSignature">
            <summary>
            Signature for archive extra data signature (were headers are encrypted).
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CentralHeaderDigitalSignature">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.CENDIGITALSIG">
            <summary>
            Central header digitial signature
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.EndOfCentralDirectorySignature">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ENDSIG">
            <summary>
            End of central directory record signature
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipConstants.DefaultCodePage">
            <summary>
            Default encoding used for string conversion.  0 gives the default system OEM code page.
            Dont use unicode encodings if you want to be Zip compatible!
            Using the default code page isnt the full solution neccessarily
            there are many variable factors, codepage 850 is often a good choice for
            European users, however be careful about compatability.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            Convert a portion of a byte array to a string.
            </summary>		
            <param name="data">
            Data to convert to string
            </param>
            <param name="count">
            Number of bytes to convert starting from index 0
            </param>
            <returns>
            data[0]..data[length - 1] converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToString(System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="data">
            Byte array to convert
            </param>
            <param name="count">The number of bytes to convert.</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToStringExt(System.Int32,System.Byte[])">
            <summary>
            Convert a byte array to string
            </summary>
            <param name="data">
            Byte array to convert
            </param>
            <param name="flags">The applicable general purpose bits flags</param>
            <returns>
            <paramref name="data">data</paramref>converted to a string
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.ConvertToArray(System.Int32,System.String)">
            <summary>
            Convert a string to a byte array
            </summary>
            <param name="flags">The applicable general purpose bits flags</param>
            <param name="str">
            String to convert to an array
            </param>
            <returns>Converted array</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipConstants.#ctor">
            <summary>
            Initialise default instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipConstants">ZipConstants</see>
            </summary>
            <remarks>
            Private to prevent instances being created.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.HostSystemID">
            <summary>
            Defines known values for the <see cref="T:ICCEmbedded.SharpZipLib.Zip.HostSystemID"/> property.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Msdos">
            <summary>
            Host system = MSDOS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Amiga">
            <summary>
            Host system = Amiga
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OpenVms">
            <summary>
            Host system = Open VMS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Unix">
            <summary>
            Host system = Unix
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.VMCms">
            <summary>
            Host system = VMCms
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.AtariST">
            <summary>
            Host system = Atari ST
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OS2">
            <summary>
            Host system = OS2
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Macintosh">
            <summary>
            Host system = Macintosh
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.ZSystem">
            <summary>
            Host system = ZSystem
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Cpm">
            <summary>
            Host system = Cpm
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.WindowsNT">
            <summary>
            Host system = Windows NT
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.MVS">
            <summary>
            Host system = MVS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Vse">
            <summary>
            Host system = VSE
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.AcornRisc">
            <summary>
            Host system = Acorn RISC
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Vfat">
            <summary>
            Host system = VFAT
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.AlternateMvs">
            <summary>
            Host system = Alternate MVS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.BeOS">
            <summary>
            Host system = BEOS
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.Tandem">
            <summary>
            Host system = Tandem
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OS400">
            <summary>
            Host system = OS400
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.OSX">
            <summary>
            Host system = OSX
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.HostSystemID.WinZipAES">
            <summary>
            Host system = WinZIP AES
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">
            <summary>
            This class represents an entry in a zip archive.  This can be a file
            or a directory
            ZipFile and ZipInputStream will give you instances of this class as 
            information about the members in an archive.  ZipOutputStream
            uses an instance of this class when creating an entry in a Zip file.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(System.String)">
            <summary>
            Creates a zip entry with the given name.
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix' style paths with relative names only.
            There are with no device names and path elements are separated by '/' characters.
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32)">
            <summary>
            Creates a zip entry with the given name and version required to extract
            </summary>
            <param name="name">
            The name for this entry. Can include directory components.
            The convention for names is 'unix'  style paths with no device names and 
            path elements separated by '/' characters.  This is not enforced see <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">CleanName</see>
            on how to ensure names are valid if this is desired.
            </param>
            <param name="versionRequiredToExtract">
            The minimum 'feature version' required this entry
            </param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(System.String,System.Int32,System.Int32,ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Initializes an entry with the given name and made by information
            </summary>
            <param name="name">Name for this entry</param>
            <param name="madeByInfo">Version and HostSystem Information</param>
            <param name="versionRequiredToExtract">Minimum required zip feature version required to extract this entry</param>
            <param name="method">Compression method for this entry.</param>
            <exception cref="T:System.ArgumentNullException">
            The name passed is null
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            versionRequiredToExtract should be 0 (auto-calculate) or > 10
            </exception>
            <remarks>
            This constructor is used by the ZipFile class when reading from the central header
            It is not generally useful, use the constructor specifying the name only.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Creates a deep copy of the given zip entry.
            </summary>
            <param name="entry">
            The entry to copy.
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HasCrc">
            <summary>
            Get a value indicating wether the entry has a CRC value available.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCrypted">
            <summary>
            Get/Set flag indicating if entry is encrypted.
            A simple helper routine to aid interpretation of <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">flags</see>
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsUnicodeText">
            <summary>
            Get / set a flag indicating wether entry name and comment text are
            encoded in <a href="http://www.unicode.org">unicode UTF8</a>.
            </summary>
            <remarks>This is an assistant that interprets the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">flags</see> property.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CryptoCheckValue">
            <summary>
            Value used during password checking for PKZIP 2.0 / 'classic' encryption.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Flags">
            <summary>
            Get/Set general purpose bit flag for entry
            </summary>
            <remarks>
            General purpose bit flag<br/>
            <br/>
            Bit 0: If set, indicates the file is encrypted<br/>
            Bit 1-2 Only used for compression type 6 Imploding, and 8, 9 deflating<br/>
            Imploding:<br/>
            Bit 1 if set indicates an 8K sliding dictionary was used.  If clear a 4k dictionary was used<br/>
            Bit 2 if set indicates 3 Shannon-Fanno trees were used to encode the sliding dictionary, 2 otherwise<br/>
            <br/>
            Deflating:<br/>
              Bit 2    Bit 1<br/>
                0        0       Normal compression was used<br/>
                0        1       Maximum compression was used<br/>
                1        0       Fast compression was used<br/>
                1        1       Super fast compression was used<br/>
            <br/>
            Bit 3: If set, the fields crc-32, compressed size
            and uncompressed size are were not able to be written during zip file creation
            The correct values are held in a data descriptor immediately following the compressed data. <br/>
            Bit 4: Reserved for use by PKZIP for enhanced deflating<br/>
            Bit 5: If set indicates the file contains compressed patch data<br/>
            Bit 6: If set indicates strong encryption was used.<br/>
            Bit 7-10: Unused or reserved<br/>
            Bit 11: If set the name and comments for this entry are in <a href="http://www.unicode.org">unicode</a>.<br/>
            Bit 12-15: Unused or reserved<br/>
            </remarks>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsUnicodeText"></seealso>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCrypted"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ZipFileIndex">
            <summary>
            Get/Set index of this entry in Zip file
            </summary>
            <remarks>This is only valid when the entry is part of a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"></see></remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Offset">
            <summary>
            Get/set offset for use in central header
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">
            <summary>
            Get/Set external file attributes as an integer.
            The values of this are operating system dependant see
            <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HostSystem">HostSystem</see> for details
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.VersionMadeBy">
            <summary>
            Get the version made by for this entry or zero if unknown.
            The value / 10 indicates the major version number, and 
            the value mod 10 is the minor version number
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsDOSEntry">
            <summary>
            Get a value indicating this entry is for a DOS/Windows system.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HasDosAttributes(System.Int32)">
            <summary>
            Test the external attributes for this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> to
            see if the external attributes are Dos based (including WINNT and variants)
            and match the values
            </summary>
            <param name="attributes">The attributes to test.</param>
            <returns>Returns true if the external attributes are known to be DOS/Windows 
            based and have the same attributes set as the value passed.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.HostSystem">
            <summary>
            Gets the compatability information for the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ExternalFileAttributes">external file attribute</see>
            If the external file attributes are compatible with MS-DOS and can be read
            by PKZIP for DOS version 2.04g then this value will be zero.  Otherwise the value
            will be non-zero and identify the host system on which the attributes are compatible.
            </summary>
            		
            <remarks>
            The values for this as defined in the Zip File format and by others are shown below.  The values are somewhat
            misleading in some cases as they are not all used as shown.  You should consult the relevant documentation
            to obtain up to date and correct information.  The modified appnote by the infozip group is
            particularly helpful as it documents a lot of peculiarities.  The document is however a little dated.
            <list type="table">
            <item>0 - MS-DOS and OS/2 (FAT / VFAT / FAT32 file systems)</item>
            <item>1 - Amiga</item>
            <item>2 - OpenVMS</item>
            <item>3 - Unix</item>
            <item>4 - VM/CMS</item>
            <item>5 - Atari ST</item>
            <item>6 - OS/2 HPFS</item>
            <item>7 - Macintosh</item>
            <item>8 - Z-System</item>
            <item>9 - CP/M</item>
            <item>10 - Windows NTFS</item>
            <item>11 - MVS (OS/390 - Z/OS)</item>
            <item>12 - VSE</item>
            <item>13 - Acorn Risc</item>
            <item>14 - VFAT</item>
            <item>15 - Alternate MVS</item>
            <item>16 - BeOS</item>
            <item>17 - Tandem</item>
            <item>18 - OS/400</item>
            <item>19 - OS/X (Darwin)</item>
            <item>99 - WinZip AES</item>
            <item>remainder - unused</item>
            </list>
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Version">
            <summary>
            Get minimum Zip feature version required to extract this entry
            </summary>		
            <remarks>
            Minimum features are defined as:<br/>
            1.0 - Default value<br/>
            1.1 - File is a volume label<br/>
            2.0 - File is a folder/directory<br/>
            2.0 - File is compressed using Deflate compression<br/>
            2.0 - File is encrypted using traditional encryption<br/>
            2.1 - File is compressed using Deflate64<br/>
            2.5 - File is compressed using PKWARE DCL Implode<br/>
            2.7 - File is a patch data set<br/>
            4.5 - File uses Zip64 format extensions<br/>
            4.6 - File is compressed using BZIP2 compression<br/>
            5.0 - File is encrypted using DES<br/>
            5.0 - File is encrypted using 3DES<br/>
            5.0 - File is encrypted using original RC2 encryption<br/>
            5.0 - File is encrypted using RC4 encryption<br/>
            5.1 - File is encrypted using AES encryption<br/>
            5.1 - File is encrypted using corrected RC2 encryption<br/>
            5.1 - File is encrypted using corrected RC2-64 encryption<br/>
            6.1 - File is encrypted using non-OAEP key wrapping<br/>
            6.2 - Central directory encryption (not confirmed yet)<br/>
            6.3 - File is compressed using LZMA<br/>
            6.3 - File is compressed using PPMD+<br/>
            6.3 - File is encrypted using Blowfish<br/>
            6.3 - File is encrypted using Twofish<br/>
            </remarks>
            <seealso cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CanDecompress"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CanDecompress">
            <summary>
            Get a value indicating wether this entry can be decompressed by the library.
            </summary>
            <remarks>This is based on the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Version"></see> and 
            wether the <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">compression method</see> is supported.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ForceZip64">
            <summary>
            Force this entry to be recorded using Zip64 extensions.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsZip64Forced">
            <summary>
            Get a value indicating wether Zip64 extensions were forced.
            </summary>
            <returns>A <see cref="T:System.Boolean"/> value of true if Zip64 extensions have been forced on; false if not.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.LocalHeaderRequiresZip64">
            <summary>
            Gets a value indicating if the entry requires Zip64 extensions 
            to store the full entry values.
            </summary>
            <value>A <see cref="T:System.Boolean"/> value of true if a local header requires Zip64 extensions; false if not.</value>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CentralHeaderRequiresZip64">
            <summary>
            Get a value indicating wether the central directory entry requires Zip64 extensions to be stored.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DosTime">
            <summary>
            Get/Set DosTime value.
            </summary>
            <remarks>
            The MS-DOS date format can only represent dates between 1/1/1980 and 12/31/2107.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DateTime">
            <summary>
            Gets/Sets the time of last modification of the entry.
            </summary>
            <remarks>
            The <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DosTime"></see> property is updated to match this as far as possible.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Name">
             <summary>
             Returns the entry name.
             </summary>
             <remarks>
             The unix naming convention is followed.
             Path components in the entry should always separated by forward slashes ('/').
             Dos device names like C: should also be removed.
             See the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform"/> class, or <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CleanName(System.String)"/>
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Size">
            <summary>
            Gets/Sets the size of the uncompressed data.
            </summary>
            <returns>
            The size or -1 if unknown.
            </returns>
            <remarks>Setting the size before adding an entry to an archive can help
            avoid compatability problems with some archivers which dont understand Zip64 extensions.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CompressedSize">
            <summary>
            Gets/Sets the size of the compressed data.
            </summary>
            <returns>
            The compressed entry size or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Crc">
            <summary>
            Gets/Sets the crc of the uncompressed data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Crc is not in the range 0..0xffffffffL
            </exception>
            <returns>
            The crc value or -1 if unknown.
            </returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CompressionMethod">
            <summary>
            Gets/Sets the compression method. Only Deflated and Stored are supported.
            </summary>
            <returns>
            The compression method for this entry
            </returns>
            <see cref="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Deflated"/>
            <see cref="F:ICCEmbedded.SharpZipLib.Zip.CompressionMethod.Stored"/>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ExtraData">
            <summary>
            Gets/Sets the extra data.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Extra data is longer than 64KB (0xffff) bytes.
            </exception>
            <returns>
            Extra data or null if not set.
            </returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ProcessExtraData(System.Boolean)">
            <summary>
            Process extra data fields updating the entry based on the contents.
            </summary>
            <param name="localHeader">True if the extra data fields should be handled
            for a local header, rather than for a central header.
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Comment">
            <summary>
            Gets/Sets the entry comment.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If comment is longer than 0xffff.
            </exception>
            <returns>
            The comment or null if not set.
            </returns>
            <remarks>
            A comment is only available for entries when read via the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> class.
            The <see cref="!:ZipInputStream"/> class doesnt have the comment data available.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsDirectory">
            <summary>
            Gets a value indicating if the entry is a directory.
            however.
            </summary>
            <remarks>
            A directory is determined by an entry name with a trailing slash '/'.
            The external file attributes can also indicate an entry is for a directory.
            Currently only dos/windows attributes are tested in this manner.
            The trailing slash convention should always be followed.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsFile">
            <summary>
            Get a value of true if the entry appears to be a file; false otherwise
            </summary>
            <remarks>
            This only takes account of DOS/Windows attributes.  Other operating systems are ignored.
            For linux and others the result may be incorrect.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported">
            <summary>
            Test entry to see if data can be extracted.
            </summary>
            <returns>Returns true if data can be extracted for this entry; false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Clone">
            <summary>
            Creates a copy of this zip entry.
            </summary>
            <returns>An <see cref="T:System.Object"/> that is a copy of the current instance.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.ToString">
            <summary>
            Gets a string representation of this ZipEntry.
            </summary>
            <returns>A readable textual representation of this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/></returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.IsCompressionMethodSupported(ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Test a <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CompressionMethod">compression method</see> to see if this library
            supports extracting data compressed with that method
            </summary>
            <param name="method">The compression method to test.</param>
            <returns>Returns true if the compression method is supported; false otherwise</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntry.CleanName(System.String)">
            <summary>
            Cleans a name making it conform to Zip file conventions.
            Devices names ('c:\') and UNC share names ('\\server\share') are removed
            and forward slashes ('\') are converted to back slashes ('/').
            Names are made relative by trimming leading slashes which is compatible
            with the ZIP naming convention.
            </summary>
            <param name="name">The name to clean</param>
            <returns>The 'cleaned' name.</returns>
            <remarks>
            The <seealso cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform">Zip name transform</seealso> class is more flexible.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory">
            <summary>
            Basic implementation of <see cref="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory"></see>
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting">
            <summary>
            Defines the possible values to be used for the <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DateTime"/>.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastWriteTime">
            <summary>
            Use the recorded LastWriteTime value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastWriteTimeUtc">
            <summary>
            Use the recorded LastWriteTimeUtc value for the file
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.CreateTime">
            <summary>
            Use the recorded CreateTime value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.CreateTimeUtc">
            <summary>
            Use the recorded CreateTimeUtc value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastAccessTime">
            <summary>
            Use the recorded LastAccessTime value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.LastAccessTimeUtc">
            <summary>
            Use the recorded LastAccessTimeUtc value for the file.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed">
            <summary>
            Use a fixed value.
            </summary>
            <remarks>The actual <see cref="T:System.DateTime"/> value used can be
            specified via the <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(System.DateTime)"/> constructor or 
            using the <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting)"/> with the setting set
            to <see cref="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed"/> which will use the <see cref="T:System.DateTime"/> when this class was constructed.
            The <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.FixedDateTime"/> property can also be used to set this value.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor">
            <summary>
            Initialise a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory"/> class.
            </summary>
            <remarks>A default <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"/>, and the LastWriteTime for files is used.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory"/> using the specified <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting"/>
            </summary>
            <param name="timeSetting">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting">time setting</see> to use when creating <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">Zip entries</see>.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.#ctor(System.DateTime)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory"/> using the specified <see cref="T:System.DateTime"/>
            </summary>
            <param name="time">The time to set all <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.DateTime"/> values to.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.NameTransform">
            <summary>
            Get / set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"/> to be used when creating new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> values.
            </summary>
            <remarks>
            Setting this property to null will cause a default <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform">name transform</see> to be used.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.Setting">
            <summary>
            Get / set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting"/> in use.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.FixedDateTime">
            <summary>
            Get / set the <see cref="T:System.DateTime"/> value to use when <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.Setting"/> is set to <see cref="F:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.TimeSetting.Fixed"/>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.GetAttributes">
            <summary>
            A bitmask defining the attributes to be retrieved from the actual file.
            </summary>
            <remarks>The default is to get all possible attributes from the actual file.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.SetAttributes">
            <summary>
            A bitmask defining which attributes are to be set on.
            </summary>
            <remarks>By default no attributes are set on.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.IsUnicodeText">
            <summary>
            Get set a value indicating wether unidoce text should be set on.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeFileEntry(System.String)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for a file.
            </summary>
            <param name="fileName">The name of the file to create a new entry for.</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeFileEntry(System.String,System.Boolean)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> from a name.
            </summary>
            <param name="fileName">The name of the file to create a new entry for.</param>
            <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> based on the <paramref name="fileName"/>.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeDirectoryEntry(System.String)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> for a directory.
            </summary>
            <param name="directoryName">The raw untransformed name for the new directory</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> representing a directory.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipEntryFactory.MakeDirectoryEntry(System.String,System.Boolean)">
            <summary>
            Make a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> for a directory.
            </summary>
            <param name="directoryName">The raw untransformed name for the new directory</param>
            <param name="useFileSystem">If true entry detail is retrieved from the file system if the file exists.</param>
            <returns>Returns a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"></see> representing a directory.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            <summary>
            Represents exception conditions specific to Zip archive handling
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor">
            <summary>
            Initializes a new instance of the ZipException class.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ZipException class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of ZipException.
            </summary>
            <param name="message">A message describing the error.</param>
            <param name="exception">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">
            <summary>
            ExtraData tagged value interface.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ITaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ITaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the contents of this instance from the data passed.
            </summary>
            <param name="data">The data to extract contents from.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ITaggedData.GetData">
            <summary>
            Get the data representing this instance.
            </summary>
            <returns>Returns the data for this instance.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.RawTaggedData">
            <summary>
            A raw binary tagged value
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.#ctor(System.Int16)">
            <summary>
            Initialise a new instance.
            </summary>
            <param name="tag">The tag ID.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="offset">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.Data">
            <summary>
            Get /set the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.RawTaggedData.tag_">
            <summary>
            The tag ID for this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData">
            <summary>
            Class representing extended unix date time values.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags">
            <summary>
            Flags indicate which values are included in this instance.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags.ModificationTime">
            <summary>
            The modification time is included
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags.AccessTime">
            <summary>
            The access time is included
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags.CreateTime">
            <summary>
            The create time is included.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.TagID">
            <summary>
            Get the ID
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> value to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>The standard Unix time is a signed integer data type, directly encoding the Unix time number,
            which is the number of seconds since 1970-01-01.
            Being 32 bits means the values here cover a range of about 136 years.
            The minimum representable time is 1901-12-13 20:45:52,
            and the maximum representable time is 2038-01-19 03:14:07.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.ModificationTime">
            <summary>
            Get /set the Modification Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.AccessTime">
            <summary>
            Get / set the Access Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.CreateTime">
            <summary>
            Get / Set the Create Time
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.IsValidValue(System.DateTime)"></seealso>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Include">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ExtendedUnixData.Flags">values</see> to include.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.NTTaggedData">
            <summary>
            Class handling NT date time values.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.TagID">
            <summary>
            Get the ID for this tagged data value.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set the data from the raw values provided.
            </summary>
            <param name="data">The raw data to extract values from.</param>
            <param name="index">The index to start extracting values from.</param>
            <param name="count">The number of bytes available.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.GetData">
            <summary>
            Get the binary data representing this instance.
            </summary>
            <returns>The raw binary data representing this instance.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.IsValidValue(System.DateTime)">
            <summary>
            Test a <see cref="T:System.DateTime"> valuie to see if is valid and can be represented here.</see>
            </summary>
            <param name="value">The <see cref="T:System.DateTime">value</see> to test.</param>
            <returns>Returns true if the value is valid and can be represented; false if not.</returns>
            <remarks>
            NTFS filetimes are 64-bit unsigned integers, stored in Intel
            (least significant byte first) byte order. They determine the
            number of 1.0E-07 seconds (1/10th microseconds!) past WinNT "epoch",
            which is "01-Jan-1601 00:00:00 UTC". 28 May 60056 is the upper limit
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.LastModificationTime">
            <summary>
            Get/set the <see cref="T:System.DateTime">last modification time</see>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.CreateTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">create time</see>
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.NTTaggedData.LastAccessTime">
            <summary>
            Get /set the <see cref="T:System.DateTime">last access time</see>.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ITaggedDataFactory">
            <summary>
            A factory that creates <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">tagged data</see> instances.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ITaggedDataFactory.Create(System.Int16,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get data for a specific tag value.
            </summary>
            <param name="tag">The tag ID to find.</param>
            <param name="data">The data to search.</param>
            <param name="offset">The offset to begin extracting data from.</param>
            <param name="count">The number of bytes to extract.</param>
            <returns>The located <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">value found</see>, or null if not found.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipExtraData">
            
            <summary>
            A class to handle the extra data field for Zip entries
            </summary>
            <remarks>
            Extra data contains 0 or more values each prefixed by a header tag and length.
            They contain zero or more bytes of actual data.
            The data is held internally using a copy on write strategy.  This is more efficient but
            means that for extra data created by passing in data can have the values modified by the caller
            in some circumstances.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.#ctor">
            <summary>
            Initialise a default instance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.#ctor(System.Byte[])">
            <summary>
            Initialise with known extra data.
            </summary>
            <param name="data">The extra data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.GetEntryData">
            <summary>
            Get the raw extra data value
            </summary>
            <returns>Returns the raw byte[] extra data this instance represents.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Clear">
            <summary>
            Clear the stored data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Length">
            <summary>
            Gets the current extra data length.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.GetStreamForTag(System.Int32)">
            <summary>
            Get a read-only <see cref="T:System.IO.Stream"/> for the associated tag.
            </summary>
            <param name="tag">The tag to locate data for.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> containing tag data or null if no tag was found.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.GetData(System.Int16)">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">tagged data</see> for a tag.
            </summary>
            <param name="tag">The tag to search for.</param>
            <returns>Returns a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData">tagged value</see> or null if none found.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ValueLength">
            <summary>
            Get the length of the last value found by <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/>
            </summary>
            <remarks>This is only value if <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previsouly returned true.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.CurrentReadIndex">
            <summary>
            Get the index for the current read value.
            </summary>
            <remarks>This is only valid if <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)"/> has previously returned true.
            Initially it will be the index of the first byte of actual data.  The value is updated after calls to
            <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadInt"/>, <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShort"/> and <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadLong"/>. </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.UnreadCount">
            <summary>
            Get the number of bytes remaining to be read for the current value;
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">
            <summary>
            Find an extra data value
            </summary>
            <param name="headerID">The identifier for the value to find.</param>
            <returns>Returns true if the value was found; false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddEntry(ICCEmbedded.SharpZipLib.Zip.ITaggedData)">
            <summary>
            Add a new entry to extra data.
            </summary>
            <param name="taggedData">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ITaggedData"/> value to add.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddEntry(System.Int32,System.Byte[])">
            <summary>
            Add a new entry to extra data
            </summary>
            <param name="headerID">The ID for this entry.</param>
            <param name="fieldData">The data to add.</param>
            <remarks>If the ID already exists its contents are replaced.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry">
            <summary>
            Start adding a new entry.
            </summary>
            <remarks>Add data using <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])"/>, <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)"/>, <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)"/>, or <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)"/>.
            The new entry is completed and actually added by calling <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)"/></remarks>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddEntry(ICCEmbedded.SharpZipLib.Zip.ITaggedData)"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddNewEntry(System.Int32)">
            <summary>
            Add entry data added since <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/> using the ID passed.
            </summary>
            <param name="headerID">The identifier to use for this entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte)">
            <summary>
            Add a byte of data to the pending new entry.
            </summary>
            <param name="data">The byte to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddData(System.Byte[])">
            <summary>
            Add data to a pending new entry.
            </summary>
            <param name="data">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeShort(System.Int32)">
            <summary>
            Add a short value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeInt(System.Int32)">
            <summary>
            Add an integer value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.AddLeLong(System.Int64)">
            <summary>
            Add a long value in little endian order to the pending new entry.
            </summary>
            <param name="toAdd">The data to add.</param>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.StartNewEntry"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Delete(System.Int32)">
            <summary>
            Delete an extra data field.
            </summary>
            <param name="headerID">The identifier of the field to delete.</param>
            <returns>Returns true if the field was found and deleted.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadLong">
            <summary>
            Read a long in little endian form from the last <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value
            </summary>
            <returns>Returns the long value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadInt">
            <summary>
            Read an integer in little endian form from the last <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the integer read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShort">
            <summary>
            Read a short value in little endian form from the last <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Find(System.Int32)">found</see> data value.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadByte">
            <summary>
            Read a byte from an extra data
            </summary>
            <returns>The byte value read or -1 if the end of data has been reached.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Skip(System.Int32)">
            <summary>
            Skip data during reading.
            </summary>
            <param name="amount">The number of bytes to skip.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShortInternal">
            <summary>
            Internal form of <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.ReadShort"/> that reads data at any location.
            </summary>
            <returns>Returns the short value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipExtraData.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs">
            <summary>
            Arguments used with KeysRequiredEvent
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs"></see>
            </summary>
            <param name="name">The name of the file for which keys are required.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.#ctor(System.String,System.Byte[])">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs"></see>
            </summary>
            <param name="name">The name of the file for which keys are required.</param>
            <param name="keyValue">The current key value.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.FileName">
            <summary>
            Get the name of the file for which keys are required.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.KeysRequiredEventArgs.Key">
            <summary>
            Get/set the key value
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.TestStrategy">
            <summary>
            The strategy to apply to testing.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestStrategy.FindFirstError">
            <summary>
            Find the first error only.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestStrategy.FindAllErrors">
            <summary>
            Find all possible errors.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.TestOperation">
            <summary>
            The operation in progress reported by a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler"/> during testing.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.Initialising">
            <summary>
            Setting up testing.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.EntryHeader">
            <summary>
            Testing an individual entries header
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.EntryData">
            <summary>
            Testing an individual entries data
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.EntryComplete">
            <summary>
            Testing an individual entry has completed.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.MiscellaneousTests">
            <summary>
            Running miscellaneous tests
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.TestOperation.Complete">
            <summary>
            Testing is complete
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.TestStatus">
            <summary>
            Status returned returned by <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler"/> during testing.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">TestArchive</seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.TestStatus.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipFile)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestStatus"/>
            </summary>
            <param name="file">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> this status applies to.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.Operation">
            <summary>
            Get the current <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestOperation"/> in progress.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.File">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> this status is applicable to.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.Entry">
            <summary>
            Get the current/last entry tested.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.ErrorCount">
            <summary>
            Get the number of errors detected so far.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.BytesTested">
            <summary>
            Get the number of bytes tested so far for the current entry.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.TestStatus.EntryValid">
            <summary>
            Get a value indicating wether the last entry test was valid.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler">
            <summary>
            Delegate invoked during <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICCEmbedded.SharpZipLib.Zip.TestStrategy,ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler)">testing</see> if supplied indicating current progress and status.
            </summary>
            <remarks>If the message is non-null an error has occured.  If the message is null
            the operation as found in <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestStatus">status</see> has started.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode">
            <summary>
            The possible ways of <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate">applying updates</see> to an archive.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode.Safe">
            <summary>
            Perform all updates on temporary files ensuring that the original file is saved.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode.Direct">
            <summary>
            Update the archive directly, which is faster but less safe.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile">
            <summary>
            This class represents a Zip archive.  You can ask for the contained
            entries, or get an input stream for a file entry.  The entry is
            automatically decompressed.
            
            You can also update the archive adding or deleting entries.
            
            This class is thread safe for input:  You can open input streams for arbitrary
            entries in different threads.
            <br/>
            <br/>Author of the original java version : Jochen Hoenicke
            </summary>
            <example>
            <code>
            using System;
            using System.Text;
            using System.Collections;
            using System.IO;
            
            using ICCEmbedded.SharpZipLib.Zip;
            
            class MainClass
            {
            	static public void Main(string[] args)
            	{
            		using (ZipFile zFile = new ZipFile(args[0])) {
            			Console.WriteLine("Listing of : " + zFile.Name);
            			Console.WriteLine("");
            			Console.WriteLine("Raw Size    Size      Date     Time     Name");
            			Console.WriteLine("--------  --------  --------  ------  ---------");
            			foreach (ZipEntry e in zFile) {
            				if ( e.IsFile ) {
            					DateTime d = e.DateTime;
            					Console.WriteLine("{0, -10}{1, -10}{2}  {3}   {4}", e.Size, e.CompressedSize,
            						d.ToString("dd-MM-yy"), d.ToString("HH:mm"),
            						e.Name);
            				}
            			}
            		}
            	}
            }
            </code>
            </example>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.KeysRequiredEventHandler">
            <summary>
            Delegate for handling keys/password setting during compresion/decompression.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipFile.KeysRequired">
            <summary>
            Event handler for handling encryption keys.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.OnKeysRequired(System.String)">
            <summary>
            Handles getting of encryption keys when required.
            </summary>
            <param name="fileName">The file for which encryption keys are required.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Key">
            <summary>
            Get/set the encryption key value.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Password">
            <summary>
            Password to be used for encrypting/decrypting files.
            </summary>
            <remarks>Set to null if no password is required.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.HaveKeys">
            <summary>
            Get a value indicating wether encryption keys are currently available.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor(System.String)">
            <summary>
            Opens a Zip file with the given name for reading.
            </summary>
            <param name="name">The name of the file to open.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor(System.IO.FileStream)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.FileStream"/>.
            </summary>
            <param name="file">The <see cref="T:System.IO.FileStream"/> to read archive data from.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor(System.IO.Stream)">
            <summary>
            Opens a Zip file reading the given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to read archive data from.</param>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The file doesn't contain a valid zip archive.<br/>
            The stream provided cannot seek
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.#ctor">
            <summary>
            Initialises a default <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> instance with no entries and no file storage.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Finalize">
            <summary>
            Finalize this instance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Close">
            <summary>
            Closes the ZipFile.  If the stream is <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsStreamOwner">owned</see> then this also closes the underlying input stream.
            Once closed, no further instance methods should be called.
            </summary>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Create(System.String)">
            <summary>
            Create a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> whose data will be stored in a file.
            </summary>
            <param name="fileName">The name of the archive to create.</param>
            <returns>Returns the newly created <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/></returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Create(System.IO.Stream)">
            <summary>
            Create a new <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> whose data will be stored on a stream.
            </summary>
            <param name="outStream">The stream providing data storage.</param>
            <returns>Returns the newly created <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/></returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsStreamOwner">
            <summary>
            Get/set a flag indicating if the underlying stream is owned by the ZipFile instance.
            If the flag is true then the stream will be closed when <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Close">Close</see> is called.
            </summary>
            <remarks>
            The default value is true in all cases.
            </remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsEmbeddedArchive">
            <summary>
            Get a value indicating wether
            this archive is embedded in another file or not.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsNewArchive">
            <summary>
            Get a value indicating that this archive is a new one.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipFileComment">
            <summary>
            Gets the comment for the zip file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Name">
            <summary>
            Gets the name of this zip file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Size">
            <summary>
            Gets the number of entries in this zip file.
            </summary>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.Count">
            <summary>
            Get the number of entries contained in this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.EntryByIndex(System.Int32)">
            <summary>
            Indexer property for ZipEntries
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetEnumerator">
            <summary>
            Gets an enumerator for the Zip entries in this Zip file.
            </summary>
            <returns>Returns an <see cref="T:System.Collections.IEnumerator"/> for this archive.</returns>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.FindEntry(System.String,System.Boolean)">
            <summary>
            Return the index of the entry with a matching name
            </summary>
            <param name="name">Entry name to find</param>
            <param name="ignoreCase">If true the comparison is case insensitive</param>
            <returns>The index position of the matching entry or -1 if not found</returns>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetEntry(System.String)">
            <summary>
            Searches for a zip entry in this archive with the given name.
            String comparisons are case insensitive
            </summary>
            <param name="name">
            The name to find. May contain directory components separated by slashes ('/').
            </param>
            <returns>
            A clone of the zip entry, or null if no entry with that name exists.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The Zip file has been closed.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetInputStream(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Gets an input stream for reading the given zip entry data in an uncompressed form.
            Normally the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> should be an entry returned by GetEntry().
            </summary>
            <param name="entry">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> to obtain a data <see cref="T:System.IO.Stream"/> for</param>
            <returns>An input <see cref="T:System.IO.Stream"/> containing data for this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/></returns>
            <exception cref="T:System.InvalidOperationException">
            The ZipFile has already been closed
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetInputStream(System.Int64)">
            <summary>
            Creates an input stream reading a zip entry
            </summary>
            <param name="entryIndex">The index of the entry to obtain an input stream for.</param>
            <returns>
            An input <see cref="T:System.IO.Stream"/> containing data for this <paramref name="entryIndex"/>
            </returns>
            <exception cref="T:System.InvalidOperationException">
            The ZipFile has already been closed
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The compression method for the entry is unknown
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            The entry is not found in the ZipFile
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean)">
            <summary>
            Test an archive for integrity/validity
            </summary>
            <param name="testData">Perform low level data Crc check</param>
            <returns>true if all tests pass, false otherwise</returns>
            <remarks>Testing will terminate on the first error found.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestArchive(System.Boolean,ICCEmbedded.SharpZipLib.Zip.TestStrategy,ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler)">
            <summary>
            Test an archive for integrity/validity
            </summary>
            <param name="testData">Perform low level data Crc check</param>
            <param name="strategy">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.TestStrategy"></see> to apply.</param>
            <param name="resultHandler">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipTestResultHandler"></see> handler to call during testing.</param>
            <returns>true if all tests pass, false otherwise</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.TestLocalHeader(ICCEmbedded.SharpZipLib.Zip.ZipEntry,ICCEmbedded.SharpZipLib.Zip.ZipFile.HeaderTest)">
            <summary>
            Test a local header against that provided from the central directory
            </summary>
            <param name="entry">
            The entry to test against
            </param>
            <param name="tests">The type of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.HeaderTest">tests</see> to carry out.</param>
            <returns>The offset of the entries data in the file</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UpdateCommand">
            <summary>
            The kind of update to apply.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.NameTransform">
            <summary>
            Get / set the <see cref="T:ICCEmbedded.SharpZipLib.Core.INameTransform"/> to apply to names when updating.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.EntryFactory">
            <summary>
            Get/set the <see cref="T:ICCEmbedded.SharpZipLib.Zip.IEntryFactory"/> used to generate <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> values
            during updates.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.BufferSize">
            <summary>
            Get /set the buffer size to be used when updating this zip file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.IsUpdating">
            <summary>
            Get a value indicating an update has <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate">been started</see>.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UseZip64">
            <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate(ICCEmbedded.SharpZipLib.Zip.IArchiveStorage,ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource)">
            <summary>
            Begin updating this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> archive.
            </summary>
            <param name="archiveStorage">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage">archive storage</see> for use during the update.</param>
            <param name="dataSource">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource">data source</see> to utilise during updating.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate(ICCEmbedded.SharpZipLib.Zip.IArchiveStorage)">
            <summary>
            Begin updating to this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> archive.
            </summary>
            <param name="archiveStorage">The storage to use during the update.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate">
            <summary>
            Begin updating this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> archive.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate(ICCEmbedded.SharpZipLib.Zip.IArchiveStorage)"/>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate"></seealso>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AbortUpdate"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate">
            <summary>
            Commit current updates, updating this archive.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate"></seealso>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AbortUpdate"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AbortUpdate">
            <summary>
            Abort updating leaving the archive unchanged.
            </summary>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.BeginUpdate"></seealso>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.SetComment(System.String)">
            <summary>
            Set the file comment to be recorded when the current update is <see cref="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.CommitUpdate">commited</see>.
            </summary>
            <param name="comment">The comment to record.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
            <summary>
            Add a new entry to the archive.
            </summary>
            <param name="fileName">The name of the file to add.</param>
            <param name="compressionMethod">The compression method to use.</param>
            <param name="useUnicodeText">Ensure Unicode text is used for name and comment for this entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Add a new entry to the archive.
            </summary>
            <param name="fileName">The name of the file to add.</param>
            <param name="compressionMethod">The compression method to use.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(System.String)">
            <summary>
            Add a file to the archive.
            </summary>
            <param name="fileName">The name of the file to add.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.IStaticDataSource,System.String)">
            <summary>
            Add a file entry with data.
            </summary>
            <param name="dataSource">The source of the data for this entry.</param>
            <param name="entryName">The name to give to the entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.IStaticDataSource,System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod)">
            <summary>
            Add a file entry with data.
            </summary>
            <param name="dataSource">The source of the data for this entry.</param>
            <param name="entryName">The name to give to the entry.</param>
            <param name="compressionMethod">The compression method to use.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.IStaticDataSource,System.String,ICCEmbedded.SharpZipLib.Zip.CompressionMethod,System.Boolean)">
            <summary>
            Add a file entry with data.
            </summary>
            <param name="dataSource">The source of the data for this entry.</param>
            <param name="entryName">The name to give to the entry.</param>
            <param name="compressionMethod">The compression method to use.</param>
            <param name="useUnicodeText">Ensure Unicode text is used for name and comments for this entry.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Add(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Add a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> that contains no data.
            </summary>
            <param name="entry">The entry to add.</param>
            <remarks>This can be used to add directories, volume labels, or empty file entries.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.AddDirectory(System.String)">
            <summary>
            Add a directory entry to the archive.
            </summary>
            <param name="directoryName">The directory to add.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Delete(System.String)">
            <summary>
            Delete an entry by name
            </summary>
            <param name="fileName">The filename to delete</param>
            <returns>True if the entry was found and deleted; false otherwise.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Delete(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Delete a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> from the archive.
            </summary>
            <param name="entry">The entry to delete.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLEUshort(System.UInt16)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLEUint(System.UInt32)">
            <summary>
            Write an unsigned int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.WriteLeLong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetBuffer">
            <summary>
            Get a raw memory buffer.
            </summary>
            <returns>Returns a raw memory buffer.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetDescriptorSize(ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate)">
            <summary>
            Get the size of the source descriptor for a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate"/>.
            </summary>
            <param name="update">The update to get the size for.</param>
            <returns>The descriptor size, zero if there isnt one.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.GetOutputStream(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Get an output stream for the specified <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/>
            </summary>
            <param name="entry">The entry to get an output stream for.</param>
            <returns>The output stream obtained for the entry.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UpdateComparer">
            <summary>
            Class used to sort updates.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.UpdateComparer.Compare(System.Object,System.Object)">
            <summary>
            Compares two objects and returns a value indicating whether one is 
            less than, equal to or greater than the other.
            </summary>
            <param name="x">First object to compare</param>
            <param name="y">Second object to compare.</param>
            <returns>Compare result.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate">
            <summary>
            Represents a pending update to a Zip file.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Copy an existing entry.
            </summary>
            <param name="entry">The existing entry to copy.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.Entry">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> for this update.
            </summary>
            <remarks>This is the source or original entry.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.OutEntry">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> that will be written to the updated/new file.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.Command">
            <summary>
            Get the command for this update.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.Filename">
            <summary>
            Get the filename if any for this update.  Null if none exists.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.SizePatchOffset">
            <summary>
            Get/set the location of the size patch for this update.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipUpdate.CrcPatchOffset">
            <summary>
            Get /set the location of the crc patch for this update.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the this instance and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources;
            false to release only unmanaged resources.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ReadLEUshort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ReadLEUint">
            <summary>
            Read a uint in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ReadEntries">
            <summary>
            Search for and read the central directory of a zip file filling the entries array.
            </summary>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The central directory is malformed or cannot be found
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.LocateEntry(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Locate the data for a given entry.
            </summary>
            <returns>
            The start offset of the data.
            </returns>
            <exception cref="T:System.IO.EndOfStreamException">
            The stream ends prematurely
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            The local header signature is invalid, the entry and central header file name lengths are different
            or the local and entry compression methods dont match
            </exception>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString">
            <summary>
            Represents a string from a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile"/> which is stored as an array of bytes.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.#ctor(System.String)">
            <summary>
            Initialise a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString"/> with a string.
            </summary>
            <param name="comment">The textual string form.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.#ctor(System.Byte[])">
            <summary>
            Initialise a <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString"/> using a string in its binary 'raw' form.
            </summary>
            <param name="rawString"></param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.IsSourceString">
            <summary>
            Get a value indicating the original source of data for this instance.
            True if the source was a string; false if the source was binary data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.RawLength">
            <summary>
            Get the length of the comment when represented as raw bytes.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.RawComment">
            <summary>
            Get the comment in its 'raw' form as plain bytes.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.Reset">
            <summary>
            Reset the comment to its initial state.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString.op_Implicit(ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString)~System.String">
            <summary>
            Implicit conversion of comment to a string.
            </summary>
            <param name="zipString">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipString"/> to convert to a string.</param>
            <returns>The textual equivalent for the input value.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.ZipEntryEnumerator">
            <summary>
            An <see cref="T:System.Collections.IEnumerator">enumerator</see> for <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry">Zip entries</see>
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream">
            <summary>
            An <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream"/> is a stream that you can write uncompressed data
            to and flush, but cannot read, seek or do anything else to.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Close">
            <summary>
            Close this stream instance.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Flush">
            <summary>
            Write any buffered data to underlying storage.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.CanWrite">
            <summary>
            Gets a value indicating whether the current stream supports writing.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.CanSeek">
            <summary>
            Gets a value indicating whether the current stream supports seeking.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Length">
            <summary>
            Get the length in bytes of the stream.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipFile.UncompressedStream.Position">
            <summary>
            Gets or sets the position within the current stream.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream">
            <summary>
            A <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream"/> is an <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            whose data is only a part or subsection of a file.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Initialise a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream"/> class.
            </summary>
            <param name="baseStream">The underlying stream to use for IO.</param>
            <param name="start">The start of the partial data.</param>
            <param name="length">The length of the partial data.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.SkipBytes(System.Int64)">
            <summary>
            Skip the specified number of input bytes.
            </summary>
            <param name="count">The maximum number of input bytes to skip.</param>
            <returns>The actuial number of input bytes skipped.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.ReadByte">
            <summary>
            Read a byte from this stream.
            </summary>
            <returns>Returns the byte read or -1 on end of stream.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream.Close">
            <summary>
            Close this <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipFile.PartialInputStream">partial input stream</see>.
            </summary>
            <remarks>
            The underlying stream is not closed.  Close the parent ZipFile class to do that.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IStaticDataSource">
            <summary>
            Provides a static way to obtain a source of data for an entry.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IStaticDataSource.GetSource">
            <summary>
            Get a source of data by creating a new stream.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> to use for compression input.</returns>
            <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource">
            <summary>
            Represents a source of data that can dynamically provide
            multiple <see cref="T:System.IO.Stream">data sources</see> based on the parameters passed.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource.GetSource(ICCEmbedded.SharpZipLib.Zip.ZipEntry,System.String)">
            <summary>
            Get a data source.
            </summary>
            <param name="entry">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipEntry"/> to get a source for.</param>
            <param name="name">The name for data if known.</param>
            <returns>Returns a <see cref="T:System.IO.Stream"/> to use for compression input.</returns>
            <remarks>Ideally a new stream is created and opened to achieve this, to avoid locking problems.</remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource">
            <summary>
            Default implementation of a <see cref="T:ICCEmbedded.SharpZipLib.Zip.IStaticDataSource"/> for use with files stored on disk.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource.#ctor(System.String)">
            <summary>
            Initialise a new instnace of <see cref="T:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource"/>
            </summary>
            <param name="fileName">The name of the file to obtain data from.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.StaticDiskDataSource.GetSource">
            <summary>
            Get a <see cref="T:System.IO.Stream"/> providing data.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> provising data.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource">
            <summary>
            Default implementation of <see cref="T:ICCEmbedded.SharpZipLib.Zip.IDynamicDataSource"/> for files stored on disk.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource.#ctor">
            <summary>
            Initialise a default instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource"/>.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DynamicDiskDataSource.GetSource(ICCEmbedded.SharpZipLib.Zip.ZipEntry,System.String)">
            <summary>
            Get a <see cref="T:System.IO.Stream"/> providing data for an entry.
            </summary>
            <param name="entry">The entry to provide data for.</param>
            <param name="name">The file name for data if known.</param>
            <returns>Returns a stream providing data; or null if not available</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage">
            <summary>
            Defines facilities for data storage when updating Zip Archives.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.UpdateMode">
            <summary>
            Get the <see cref="T:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode"/> to apply during updates.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput">
            <summary>
            Get an empty <see cref="T:System.IO.Stream"/> that can be used for temporary output.
            </summary>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/></returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Convert a temporary output stream to a final stream.
            </summary>
            <returns>The resulting final <see cref="T:System.IO.Stream"/></returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.GetTemporaryOutput"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of the original stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to copy.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="stream">The current stream.</param>
            <returns>Returns a stream suitable for direct updating.</returns>
            <remarks>This may be the current stream passed.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage.Dispose">
            <summary>
            Dispose of this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage">
            <summary>
            An abstract <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage"/> suitable for extension by inheritance.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.FileUpdateMode)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage"/> class.
            </summary>
            <param name="updateMode">The update mode.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput">
            <summary>
            Gets a temporary output <see cref="T:System.IO.Stream"/>
            </summary>
            <returns>Returns the temporary output stream.</returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal"></seealso>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Converts the temporary <see cref="T:System.IO.Stream"/> to its final form.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> that can be used to read
            the final storage for the archive.</returns>
            <seealso cref="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.GetTemporaryOutput"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to make a copy of.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to open for direct update.</param>
            <returns>Returns a stream suitable for direct updating.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.BaseArchiveStorage.UpdateMode">
            <summary>
            Gets the update mode applicable.
            </summary>
            <value>The update mode.</value>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage">
            <summary>
            An <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage"/> implementation suitable for hard disks.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipFile,ICCEmbedded.SharpZipLib.Zip.FileUpdateMode)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage"/> class.
            </summary>
            <param name="file">The file.</param>
            <param name="updateMode">The update mode.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.ZipFile)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage"/> class.
            </summary>
            <param name="file">The file.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.GetTemporaryOutput">
            <summary>
            Gets a temporary output <see cref="T:System.IO.Stream"/> for performing updates on.
            </summary>
            <returns>Returns the temporary output stream.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Converts a temporary <see cref="T:System.IO.Stream"/> to its final form.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> that can be used to read
            the final storage for the archive.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of a stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to copy.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="current">The current stream.</param>
            <returns>Returns a stream suitable for direct updating.</returns>
            <remarks>If the <paramref name="current"/> stream is not null this is used as is.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.DiskArchiveStorage.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage">
            <summary>
            An <see cref="T:ICCEmbedded.SharpZipLib.Zip.IArchiveStorage"/> implementation suitable for in memory streams.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage"/> class.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.#ctor(ICCEmbedded.SharpZipLib.Zip.FileUpdateMode)">
            <summary>
            Initializes a new instance of the <see cref="T:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage"/> class.
            </summary>
            <param name="updateMode">The <see cref="T:ICCEmbedded.SharpZipLib.Zip.FileUpdateMode"/> to use</param>
            <remarks>This constructor is for testing as memory streams dont really require safe mode.</remarks>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.FinalStream">
            <summary>
            Get the stream returned by <see cref="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal"/> if this was in fact called.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.GetTemporaryOutput">
            <summary>
            Gets the temporary output <see cref="T:System.IO.Stream"/>
            </summary>
            <returns>Returns the temporary output stream.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.ConvertTemporaryToFinal">
            <summary>
            Converts the temporary <see cref="T:System.IO.Stream"/> to its final form.
            </summary>
            <returns>Returns a <see cref="T:System.IO.Stream"/> that can be used to read
            the final storage for the archive.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.MakeTemporaryCopy(System.IO.Stream)">
            <summary>
            Make a temporary copy of the original stream.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to copy.</param>
            <returns>Returns a temporary output <see cref="T:System.IO.Stream"/> that is a copy of the input.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.OpenForDirectUpdate(System.IO.Stream)">
            <summary>
            Return a stream suitable for performing direct updates on the original source.
            </summary>
            <param name="stream">The original source stream</param>
            <returns>Returns a stream suitable for direct updating.</returns>
            <remarks>If the <paramref name="stream"/> passed is not null this is used;
            otherwise a new <see cref="T:System.IO.MemoryStream"/> is returned.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.MemoryArchiveStorage.Dispose">
            <summary>
            Disposes this instance.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.DescriptorData">
            <summary>
            Holds data pertinent to a data descriptor.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.DescriptorData.CompressedSize">
            <summary>
            Get /set the compressed size of data.
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.DescriptorData.Size">
            <summary>
            Get / set the uncompressed size of data
            </summary>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.DescriptorData.Crc">
            <summary>
            Get /set the crc value.
            </summary>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream">
            <summary>
            This class assists with writing/reading from Zip files.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.#ctor(System.String)">
            <summary>
            Initialise an instance of this class.
            </summary>
            <param name="name">The name of the file to open.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream"/>.
            </summary>
            <param name="stream">The stream to use.</param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner">
            <summary>
            Get / set a value indicating wether the the underlying stream is owned or not.
            </summary>
            <remarks>If the stream is owned it is closed when this instance is closed.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.Close">
            <summary>
            Close the stream.
            </summary>
            <remarks>
            The underlying stream is closed only if <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.IsStreamOwner"/> is true.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.LocateBlockWithSignature(System.Int32,System.Int64,System.Int32,System.Int32)">
            <summary>
            Locates a block with the desired <paramref name="signature"/>.
            </summary>
            <param name="signature">The signature to find.</param>
            <param name="endLocation">Location, marking the end of block.</param>
            <param name="minimumBlockSize">Minimum size of the block.</param>
            <param name="maximumVariableData">The maximum variable data.</param>
            <returns>Eeturns the offset of the first byte after the signature; -1 if not found</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteZip64EndOfCentralDirectory(System.Int64,System.Int64,System.Int64)">
            <summary>
            Write Zip64 end of central directory records (File header and locator).
            </summary>
            <param name="noOfEntries">The number of entries in the central directory.</param>
            <param name="sizeEntries">The size of entries in the central directory.</param>
            <param name="centralDirOffset">The offset of the dentral directory.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteEndOfCentralDirectory(System.Int64,System.Int64,System.Int64,System.Byte[])">
            <summary>
            Write the required records to end the central directory.
            </summary>
            <param name="noOfEntries">The number of entries in the directory.</param>
            <param name="sizeEntries">The size of the entries in the directory.</param>
            <param name="startOfCentralDirectory">The start of the central directory.</param>
            <param name="comment">The archive comment.  (This can be null).</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadLEShort">
            <summary>
            Read an unsigned short in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadLEInt">
            <summary>
            Read an int in little endian byte order.
            </summary>
            <returns>Returns the value read.</returns>
            <exception cref="T:System.IO.IOException">
            An i/o error occurs.
            </exception>
            <exception cref="T:System.IO.EndOfStreamException">
            The file ends prematurely
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadLELong">
            <summary>
            Read a long in little endian byte order.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEUshort(System.UInt16)">
            <summary>
            Write a ushort in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEUint(System.UInt32)">
            <summary>
            Write a uint in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLELong(System.Int64)">
            <summary>
            Write a long in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteLEUlong(System.UInt64)">
            <summary>
            Write a ulong in little endian byte order.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.WriteDataDescriptor(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Write a data descriptor.
            </summary>
            <param name="entry">The entry to write a descriptor for.</param>
            <returns>Returns the number of descriptor bytes written.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipHelperStream.ReadDataDescriptor(System.Boolean,ICCEmbedded.SharpZipLib.Zip.DescriptorData)">
            <summary>
            Read data descriptor at the end of compressed data.
            </summary>
            <param name="zip64">if set to <c>true</c> [zip64].</param>
            <param name="data">The data to fill in.</param>
            <returns>Returns the number of bytes read in the descriptor.</returns>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform">
            <summary>
            ZipNameTransform transforms names as per the Zip file naming convention.
            </summary>
            <remarks>The use of absolute names is supported although its use is not valid 
            according to Zip naming conventions, and should not be used if maximum compatability is desired.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.#ctor">
            <summary>
            Initialize a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform"></see>
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.#ctor(System.String)">
            <summary>
            Initialize a new instance of <see cref="T:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform"></see>
            </summary>
            <param name="trimPrefix">The string to trim from front of paths if found.</param>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.#cctor">
            <summary>
            Static constructor.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.TransformDirectory(System.String)">
            <summary>
            Transform a directory name according to the Zip file naming conventions.
            </summary>
            <param name="name">The directory name to transform.</param>
            <returns>The transformed name.</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.TransformFile(System.String)">
            <summary>
            Transform a windows file name according to the Zip file naming conventions.
            </summary>
            <param name="name">The file name to transform.</param>
            <returns>The transformed name.</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.TrimPrefix">
            <summary>
            Get/set the path prefix to be trimmed from paths if present.
            </summary>
            <remarks>The prefix is trimmed before any conversion from
            a windows path is done.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.MakeValidName(System.String,System.Char)">
            <summary>
            Force a name to be valid by replacing invalid characters with a fixed value
            </summary>
            <param name="name">The name to force valid</param>
            <param name="replacement">The replacement character to use.</param>
            <returns>Returns a valid name</returns>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String,System.Boolean)">
            <summary>
            Test a name to see if it is a valid name for a zip entry.
            </summary>
            <param name="name">The name to test.</param>
            <param name="relaxed">If true checking is relaxed about windows file names and absolute paths.</param>
            <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
            <remarks>Zip path names are actually in Unix format, and should only contain relative paths.
            This means that any path stored should not contain a drive or
            device letter, or a leading slash.  All slashes should forward slashes '/'.
            An empty name is valid for a file where the input comes from standard input.
            A null name is not considered valid.
            </remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipNameTransform.IsValidName(System.String)">
            <summary>
            Test a name to see if it is a valid name for a zip entry.
            </summary>
            <param name="name">The name to test.</param>
            <returns>Returns true if the name is a valid zip name; false otherwise.</returns>
            <remarks>Zip path names are actually in unix format,
            and should only contain relative paths if a path is present.
            This means that the path stored should not contain a drive or
            device letter, or a leading slash.  All slashes should forward slashes '/'.
            An empty name is valid where the input comes from standard input.
            A null name is not considered valid.
            </remarks>
        </member>
        <member name="T:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream">
             <summary>
             This is a DeflaterOutputStream that writes the files into a zip
             archive one after another.  It has a special method to start a new
             zip entry.  The zip entries contains information about the file name
             size, compressed size, CRC, etc.
             
             It includes support for Stored and Deflated entries.
             This class is not thread safe.
             <br/>
             <br/>Author of the original java version : Jochen Hoenicke
             </summary>
             <example> This sample shows how to create a zip file
             <code>
             using System;
             using System.IO;
             
             using ICCEmbedded.SharpZipLib.Core;
             using ICCEmbedded.SharpZipLib.Zip;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             		string[] filenames = Directory.GetFiles(args[0]);
             		byte[] buffer = new byte[4096];
             		
             		using ( ZipOutputStream s = new ZipOutputStream(File.Create(args[1])) ) {
             		
             			s.SetLevel(9); // 0 - store only to 9 - means best compression
             		
             			foreach (string file in filenames) {
             				ZipEntry entry = new ZipEntry(file);
             				s.PutNextEntry(entry);
            
             				using (FileStream fs = File.OpenRead(file)) {
            						StreamUtils.Copy(fs, s, buffer);
             				}
             			}
             		}
             	}
             }	
             </code>
             </example>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new Zip output stream, writing a zip archive.
            </summary>
            <param name="baseOutputStream">
            The output stream to which the archive contents are written.
            </param>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.IsFinished">
            <summary>
            Gets a flag value of true if the central header has been added for this archive; false if it has not been added.
            </summary>
            <remarks>No further entries can be added once this has been done.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.SetComment(System.String)">
            <summary>
            Set the zip file comment.
            </summary>
            <param name="comment">
            The comment text for the entire archive.
            </param>
            <exception name ="ArgumentOutOfRangeException">
            The converted comment is longer than 0xffff bytes.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  The new level will be activated
            immediately.
            </summary>
            <param name="level">The new compression level (1 to 9).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
            <see cref="T:ICCEmbedded.SharpZipLib.Zip.Compression.Deflater"/>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.GetLevel">
            <summary>
            Get the current deflater compression level
            </summary>
            <returns>The current compression level</returns>
        </member>
        <member name="P:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.UseZip64">
            <summary>
            Get / set a value indicating how Zip64 Extension usage is determined when adding entries.
            </summary>
            <remarks>Older archivers may not understand Zip64 extensions.
            If backwards compatability is an issue be careful when adding <see cref="P:ICCEmbedded.SharpZipLib.Zip.ZipEntry.Size">entries</see> to an archive.
            Setting this property to off is workable but less desirable as in those circumstances adding a file
            larger then 4GB will fail.</remarks>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.WriteLeShort(System.Int32)">
            <summary>
            Write an unsigned short in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.WriteLeInt(System.Int32)">
            <summary>
            Write an int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.WriteLeLong(System.Int64)">
            <summary>
            Write an int in little endian byte order.
            </summary>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.PutNextEntry(ICCEmbedded.SharpZipLib.Zip.ZipEntry)">
            <summary>
            Starts a new Zip entry. It automatically closes the previous
            entry if present.
            All entry elements bar name are optional, but must be correct if present.
            If the compression method is stored and the output is not patchable
            the compression for that entry is automatically changed to deflate level 0
            </summary>
            <param name="entry">
            the entry.
            </param>
            <exception cref="T:System.ArgumentNullException">
            if entry passed is null.
            </exception>
            <exception cref="T:System.IO.IOException">
            if an I/O error occured.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            if stream was finished
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            Too many entries in the Zip file<br/>
            Entry name is too long<br/>
            Finish has already been called<br/>
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.CloseEntry">
            <summary>
            Closes the current entry, updating header and footer information as required
            </summary>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            No entry is active.
            </exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the given buffer to the current entry.
            </summary>
            <param name="buffer">The buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">Archive size is invalid</exception>
            <exception cref="T:System.InvalidOperationException">No entry is active.</exception>
        </member>
        <member name="M:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.Finish">
            <summary>
            Finishes the stream.  This will write the central directory at the
            end of the zip file and flush the stream.
            </summary>
            <remarks>
            This is automatically called when the stream is closed.
            </remarks>
            <exception cref="T:System.IO.IOException">
            An I/O error occurs.
            </exception>
            <exception cref="T:ICCEmbedded.SharpZipLib.Zip.ZipException">
            Comment exceeds the maximum length<br/>
            Entry name exceeds the maximum length
            </exception>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.entries">
            <summary>
            The entries for the archive.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.crc">
            <summary>
            Used to track the crc of data added to entries.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.curEntry">
            <summary>
            The current entry being added.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.size">
            <summary>
            Used to track the size of data for an entry during writing.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.offset">
            <summary>
            Offset to be recorded for each entry in the central header.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.zipComment">
            <summary>
            Comment for the entire archive recorded in central header.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.patchEntryHeader">
            <summary>
            Flag indicating that header patching is required for the current entry.
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.crcPatchPos">
            <summary>
            Position to patch crc
            </summary>
        </member>
        <member name="F:ICCEmbedded.SharpZipLib.Zip.ZipOutputStream.sizePatchPos">
            <summary>
            Position to patch size.
            </summary>
        </member>
        <member name="P:Swashbuckle.AspNetCore.Swagger.SwaggerEndpointOptions.SerializeAsV2">
            <summary>
            Return Swagger JSON in the V2 format rather than V3
            </summary>
        </member>
        <member name="P:Swashbuckle.AspNetCore.Swagger.SwaggerEndpointOptions.PreSerializeFilters">
            <summary>
            Actions that can be applied SwaggerDocument's before they're serialized to JSON.
            Useful for setting metadata that's derived from the current request
            </summary>
        </member>
        <member name="P:Swashbuckle.AspNetCore.Swagger.SwaggerOptions.RouteTemplate">
            <summary>
            Sets a custom route for the Swagger JSON/YAML endpoint(s). Must include the {documentName} parameter
            </summary>
        </member>
        <member name="P:Swashbuckle.AspNetCore.Swagger.SwaggerOptions.SerializeAsV2">
            <summary>
            Return Swagger JSON/YAML in the V2 format rather than V3
            </summary>
        </member>
        <member name="P:Swashbuckle.AspNetCore.Swagger.SwaggerOptions.PreSerializeFilters">
            <summary>
            Actions that can be applied to an OpenApiDocument before it's serialized.
            Useful for setting metadata that's derived from the current request
            </summary>
        </member>
    </members>
</doc>
